<?xml version="1.0" ?>
<?xml-stylesheet type="text/xsl" href="style.xsl" ?>
<content lang="en" id="documentation">
    <div class="titlepage">
        <div class="title"><img style="width: 100%; border: 1pt solid #8080a0" src="doctitle.png" /></div>
        <div class="titleversion">Last modified: <last-modified-date>$LastChangedDate: 2014-11-07 13:21:07 +0100 (Fri, 07 Nov 2014) $</last-modified-date> (revision <subversion-revision>$Revision: 891 $</subversion-revision>)</div>
        <div class="pagebreak">&#160;</div>
    </div>
    <p class="dontprintthis">
        <h1>Sooda Documentation</h1>
    </p>
    <p class="toctitle" />

    <table-of-contents />

    <section id="intro">
        <title>Introduction to Sooda</title>
        <section id="whatissooda">
            <title>What is Sooda?</title>
            <body>
                <p>
                    <b>Sooda</b> (Simple Object-Oriented Data Access) is an Object-To-Relational Mapping 
                    software for the <a href="http://www.microsoft.com/NET/">.NET</a> environment.
                    O/R Mapping Software enables you to express your business rules without SQL.
                </p>
                <p>
                    Sooda includes a code generator, which can generate entire Data Access Layer for your application.
                    Each class of the DAL typically corresponds to a database table,
                    its properties map to database columns and relationships map to object references and collections.
                </p>
            </body>
            <section id="features">
                <title>Features</title>
                <body>
                    <p>
                        Sooda supports the following features, which are explained in the following sections:
                    </p>
                    <ul>
                        <li>mapping <a href="#mappingtablestoclasses">one</a> or <a href="#mappingmultipletablestoclasses">more tables</a> to a class</li>
                        <li><a href="#mappingonetomany">one-to-many</a> and <a href="#mappingmanytomany">many-to-many</a> relationships</li>
                        <li><a href="#pathexpressions">path expressions</a>, both in code and the in query language</li>
                        <li><a href="#primarykeys">identity management through L1 caching</a></li>
                        <li><a href="#inheritance">inheritance</a> (two models: table-per-hierarchy (TPH) and table-per-subclass (TPS))</li>
                        <li>strongly-typed, database-based <a href="#schemaconst">enumerations</a></li>
                        <li><a href="#lazyloading">lazy loading</a></li>
                        <li><a href="#serialization">differential serialization and deserialization</a> of uncommitted changes (enables long-running transactions)</li>
                        <li><a href="#querylanguage">LINQ</a></li>
                        <li>strongly-typed <a href="#querylanguage">query language</a> (based on C# operator overloading)</li>
                        <li>text-based <a href="#querylanguage">query language</a> - SOQL</li>
                        <li><a href="#mappingmultipletablestoclasses">vertical partitioning</a> of data (load-on-demand for large columns)</li>
                        <li><a href="#caching">cross-transaction (level-2) caching</a></li>
                        <li><a href="#dynamicfieldsoverview">Dynamic Fields</a> managed at runtime</li>
                    </ul>
                </body>
            </section>
            <section id="supportedplatforms">
                <title>Supported Platforms</title>
                <body>
                    <p>
                        Sooda supports .NET Framework 2.0, 3.5 and 4.0 and Mono profiles 2.0 and 3.5.
                    </p>
                    <p>
                        The following development tools/build environments are supported:
                    </p>
                    <ul>
                        <li>Visual Studio 2008 (.NET Framework 3.5)</li>
                        <li>Visual Studio 2005 (.NET Framework 2.0)</li>
                        <li>NAnt</li>
                    </ul>
                </body>
            </section>
            <section id="supportedrdbms">
                <title>Supported Relational Databases</title>
                <body>
                    <p>
                        The following RDBMSes are supported:
                    </p>
                    <ul>
                        <li>Microsoft SQL Server 2000, 2005, 2008, 2012 (including SQL Server Express Edition)</li>
                        <li>MySQL v4.x</li>
                        <li>PostgreSQL v8.x</li>
                        <li>Oracle 8i, 9i, 10g</li>
                    </ul>
                    <p>
                        Sooda has been used in production systems for at least 9 years and things are generally working smooth.
                        Some graphical and command line tools to support the development are available, but they are generally
                        newer and still require some work.
                    </p>
                </body>
            </section>
            <section id="supportedlanguages">
                <title>Supported Languages</title>
                <body>
                    <p>
                        Sooda supports code generation using CodeDOM technology. In theory any language should be supported,
                        but some languages have problems with their CodeDOM providers or their compilers are buggy.
                        The following languages have been tested:
                    </p>
                    <ul>
                        <li><a href="http://msdn.microsoft.com/vcsharp/">C#</a> - fully supported, code compiles cleanly, supports <a href="#soqltypedqueries">Typed Queries</a>.</li>
                        <li><a href="http://msdn.microsoft.com/vbasic/">VB.NET</a> - fully supported, some warnings may be raised during compilation of the generated code, but they can be ignored.</li>
                        <li><a href="http://www.nemerle.org/">Nemerle</a> - code generation works, needs further investigation</li>
                        <li><a href="http://boo.codehaus.org/">Boo</a> - not supported - compilation fails</li>
                        <li><a href="http://msdn.microsoft.com/en-us/library/3bf5fs13.aspx">JScript.NET</a> - not supported - compilation fails</li>
                        <li><a href="http://ironpython.net">IronPython</a> - code generation used to work, but the necessary API has been removed</li>
                    </ul>
                </body>
            </section>
        </section>
        <section id="basicconcepts">
            <title>Basic Concepts</title>
            <body>
                This section explains basic O/R mapping concepts and provides general overview of Sooda features.
            </body>

            <section id="mappingtablestoclasses">
                <title>Mapping Classes to Tables</title>
                <body>
                    <p>
                        Most applications written in high-level languages use the object-oriented 
                        approach and often they need to store data in relational databases.

                        Working with objects, we use method calls, properties
                        events, collections, inheritance, polymorphism, and so on, while working with relational data 
                        requires us to think in terms of SELECT, INSERT, UPDATE and DELETE SQL operations
                        on rectangular tables.
                    </p>
                    <p>
                        Obviously the two models (object-oriented and relational) are not 
                        compatible. Sooda lets you bridge the gap by providing an object-oriented interface to the database so that
                        you can write code in your favourite high-level language without using SQL at all.
                    </p>
                    <p>
                        Let's see how objects can be stored in a database. Assuming we have a simple class named Employee.
                    </p>
                    <img src="doc0.gif" alt="Employee Class" />
                    <p>
                        Objects of this class can be persisted when we follow the rules of so called "natural mapping", where:
                    </p>

                    <ul>
                        <li>each object is stored in a single row of a single table whose name matches the name of the class</li>
                        <li>each property is stored in a single column, whose name matches the name of the property/field</li>
                        <li>the type of the column corresponds to the type of the property</li>
                    </ul>

                    <p>
                        Applying these "natural mapping" rules to the Employee class, we get the following table:
                    </p>
                    <img src="doc1.gif" alt="Employee Table" />
                    <p>
                        Natural mapping as described above is not always possible/desirable and therefore we need a <a href="#schema">mapping schema</a> to
                        fully describe the mapping for tables/columns/datatypes and more. We can for example:
                        </p>
                    <ul>
                        <li>override database table name (for example TblEmployee instead of Employee). 
                            There are some reserved SQL keywords which cannot be used as table names (<code>SELECT, FROM, WHERE, GROUP</code>)</li>
                        <li>define names of database columns (for example hire_date instead of HireDate). Some databases 
                            impose limitations on the
                            maximum column names so you might want to make them shorter.</li>
                        <li>use other datatypes (such as a column of type "integer" instead of "bit" to store the 
                            value of the "Active" property with "true" and "false" mapped to "1" and "0" respectively)</li>
                        <li>objects may need to be persisted in <a href="#mappingmultipletablestoclasses">more than one table</a></li>
                    </ul>
                </body>
            </section>
            <section id="primarykeys">
                <title>Primary Keys and Object Identity</title>
                <body>
                    <p>
                        Entities in the databases are identified by their primary keys. In object-oriented
                        languages we refer to objects by their references. The references are
                        valid only for a single execution of the program and cannot be stored in a database directly.
                        O/R mapper needs to convert between primary key values and object references 
                        when loading and storing data.
                    </p>
                    <p>
                        In order to participate in O/R mapping each database table needs to have one or more primary key 
                        columns (either natural or surrogate) and you need to tell the mapper which columns are primary keys. 
                        The primary keys must be properly maintained in the database (the best way is to create a UNIQUE index on primary
                        key columns). If you fail to do so (for example when there are many rows sharing the same
                        value in the primary key column), you may get all sorts of undefined behavior.
                    </p>
                    <p>
                        Each object in Sooda knows about the primary key that represents it in the database.
                        <a href="#objectidentity">Transaction-level object cache</a> (L1 cache) is used to map primary keys to objects.
                        This two-way mapping lets Sooda provide <a href="#objectidentity">reference identity</a> for objects
                        it manages.
                    </p>
                    <p>
                        When creating a new object in memory, the primary key needs to be known in advance (before
                        the object is actually stored in the database). Because of this, we cannot use identity columns in
                        databases to provide primary keys, other mechanism to generate primary keys is necessary.
                    </p>
                    <p>
                        Sooda provides <a href="#keygeneration">key generators</a> which may be used for this purpose.
                        The default one uses a special table in the database to manage batched key allocation. Alternatively, for primary
                        keys which are GUIDs, you can use the standard Guid.NewGuid() generation method.
                    </p>
                </body>
            </section>
            <section id="mappingonetomany">
                <title>One-To-Many Relationships</title>
                <body>
                    One-to-many relationships are typically represented as collections of objects related
                    to some particular object (only one). Typical examples are:
                    <ul>
                        <li>customer has a collection of orders (each order has exactly one customer)</li>
                        <li>group has members (each member belongs to exactly one group)</li>
                        <li>mother has children (each child has exactly one mother)</li>
                    </ul>
                    In databases we usually represent relationships as foreign key columns stored in the
                    "child" objects, so to represent the customer-to-orders relationship we have a foreign
                    key column (perhaps named "customer") stored in the "Order" table. The value stored
                    in this column must match the primary key value of the Customer. 
                    
                    The following piece of SQL code demonstrates this for a simple Customer to Order relationship:

                    <code lang="SQL">
                        <![CDATA[
create table Customer
(
    ID int primary key not null,
    Name varchar(64),
    Address1 varchar(64),
    Address2 varchar(64)
);

create table Order
(
    ID int primary key not null,
    -- more columns here
    CustomerID int not null references Customer(ID)
);
                        ]]>
                    </code>

                    <img src="doc2.gif" alt="One-To-Many relationship between Customer and Order" />
                    <p>
                    </p>

                    <p>
                        Sooda makes the task of managing foreign key relationships rather simple by providing
                        a dual view of the relationship: reference from a "child" to its "parent" and a collection
                        of "children" that is a member of the "parent" objects. You only need to specify which property in the
                        "child" object is a reference to the "parent" object. Code generated by Sooda includes the following APIs:
                    </p>
                    <code lang="C#">
class Customer
{
    int ID { get; set; }
    string Name { get; set; }
    ...
    OrderList Orders { get; }
}

class Order
{
    int ID { get; set; }
    Customer Customer { get; set; }
}
                    </code>
                    <p>
                        The OrderList is functionally equivalent to IList&lt;Order&gt; with some filtering
                        and sorting methods <a href="#generatedlistwrappers">included for convenience</a>. Customer is
                        a reference to the Customer class. Sooda lets you write:
                    </p>
                    <code lang="C#">
Customer c;

// create new order
Order o = new Order()
c.Orders.Add(o);
// this is equivalent to the above
o.Customer = c; 
c.Orders.Remove(o);
// get order count
c.Orders.Count; 
// check it the orders contains the specified one
c.Orders.Contains(o); 
// return a sorted collection
c.Orders.OrderBy(sortExpression); 

                    </code>
                    <p>
                       Convenience methods of Sooda collections are described <sectionlink id="generatedlistwrappers" />.
                    </p>
                </body>
            </section>
            <section id="mappingmanytomany">
                <title>Many-To-Many Relationships</title>
                <body>
                    <p>
                        Many-to-many relationships are used in many situations, such as these:
                    </p>
                    <ul>
                        <li>person-to-permission (each person has many permissions, each permission is held by many persons)</li>
                        <li>lecture-to-student (each student attends many lectures, each lecture is attended by many students)</li>
                        <li>and so on</li>
                    </ul>
                    <p>
                        Database representation of many-to-many relationships requires a separate table that will
                        hold pairs of primary keys that are in relationship, such as the Employee2Permission table in the following
                        figure:
                    </p>
                    <img src="doc3.gif" alt="Many-To-Many relationship between Employee and Permission using Employee2Permission" />
                    <p>
                        The SQL used to create this database is:
                    </p>
                    <code lang="SQL">
                        <![CDATA[
create table Employee
(
    ID int primary key not null,
    Name varchar(64),
    Address1 varchar(64),
    Address2 varchar(64)
);

create table Permission
(
    ID int primary key not null,
    PermissionName varchar(64),
);

create table Employee2Permission
(
    EmployeeID int not null references Employee(ID),
    PermissionID int not null references Permission(ID)
)

alter table Employee2Permission add primary key (EmployeeID,PermissionID);
                        ]]>
                    </code>
                    <p>
                        Sooda generates a pair of collection which provide access to objects in the relationship. In this example, we have:
                    </p>
                    <code lang="C#">
class Employee
{
    ...
    PermissionList Permissions { get; }
}

class Permission
{
    ...
    EmployeeList Employees { get; }
}
                    </code>
                    <p>
                        These collections support the same set of operations as one-to-many collections, namely Add(), Remove(), 
                        Contains(), Count and others. The collections are synchronized, no matter which object you
                        use to modify the relationships, the result is the same. In this example you could:
                    </p>
                    <ul>
                        <li>add a Permission to a collection of permissions held by Employee</li>
                        <li>add an Employee to a collection of employees which hold the permission</li>
                    </ul>
                    <code lang="C#">
using (SoodaTransaction t = new SoodaTransaction())
{
    Employee emp = ...;
    Permission perm = ...;

    // the following two lines are equivalent
    emp.Permissions.Add(perm); // add permission to the emp's permission collection
    perm.Employees.Add(emp); // add employee to perm's employees collection

    if (emp.Permissions.Contains(perm))
    {
        Console.WriteLine("Employee is authorized.");
    }

    // this tests essentially the same thing
    if (perm.Employees.Contains(emp))
    {
        Console.WriteLine("Employee is authorized.");
    }    
}
</code>
                </body>
            </section>
            <section id="lazyloading">
                <title>Lazy Loading</title>
                <body>
                    <p>
                        Often you need to operate on an object but you do not need access to its properties.
                        It would be very inefficient to load full record from a database each time
                        a reference to it is needed. For example you do not need to know the name of the employee
                        just to check if he is in relationship with some other objects.
                    </p>
                    <p>
                        Sooda supports lazy loading by maintaining a data structure that holds object data. It 
                        loads the data and initializes the data structures on as-needed basis, which means objects do not allocate 
                        memory for their data values until the properties are accessed.
                    </p>
                    <p>
                        Each object managed by Sooda can be in one of the four states:
                    </p>
                    <ul>
                        <li><b>Data Not Loaded</b> - no properties have been accessed</li>
                        <li><b>Data Loaded</b> - some properties have been read</li>
                        <li><b>Data Not Loaded - Modified</b> - some properties have been written to, but not read from</li>
                        <li><b>Data Loaded - Modified</b> - some properties have been written to, and some have been read from</li>
                    </ul>
                    <img src="doc4.png" alt="Possible lazy loading states of an object" />
                    <p>
                        Each time a property is read in <b>Data Not Loaded</b> or <b>Data Not Loaded-Modified</b> state
                        Sooda needs to access the database to load the data. If a property is only written to, there is no need
                        to even load the data from the database.
                    </p>
                    <p>Lazy loading is described <sectionlink id="loadingobjects" />.</p>
                </body>
            </section>
            <section id="pathexpressions">
                <title>Path expressions and managing referenced objects</title>
                <body>
                    <p>
                        Objects in memory may form graphs: they may include properties which are
                        references to other objects and these objects may have references to other objects 
                        and so on.
                    </p>
                    <p>
                        Sooda supports path expressions both in code and in <a href="#querylanguage">query language</a>
                        which let you access properties of related objects easily. 
                        For example to access the last name of the manager of a person's organization unit:
                    </p>
                    <code lang="C#">
                        // display the last name of person's org unit
                        Console.WriteLine(person.OrganizationUnit.Manager.LastName);
                    </code>
                    <p>
                        You can access collections in the same manner:
                    </p>
                    <code lang="C#">
                        // display the number of org unit members
                        Console.WriteLine(person.OrganizationUnit.Members.Count);
                    </code>
                    <p>
                        Object references are fully lazy-loaded and managed by <a href="#primarykeys">transaction L1 cache</a>
                        so that the number of database accesses is reduced.
                    </p>
                </body>
            </section>
            <section id="mappingmultipletablestoclasses">
                <title>Mapping Multiple Tables to a Single Class</title>
                <body>
                    <p>
                        A class can be mapped to more than one table in the database or it can be split into many logical "tables" which
                        are actually mapped to the same physical table. We may want to do it for many reasons:
                    </p>
                    <ul>
                        <li>database engine limitations - some databases have maximum row size limit, and you may not be able to store
                            long texts in a single table because of this limit. Splitting table in two and performing joins by primary key
                            may be the only option</li>
                        <li>performance - imagine you have some large field which you access infrequently (such as a person's picture). 
                            Loading the field from the database would not be efficient because it would consume time and memory.
                            Lazy loading mechanism works on a table level which means that it loads the entire row from a table each
                            time a single column is accessed. Putting the large column in a separate table helps remediate this issue.
                        </li>
                    </ul>
                    <p>This is the most typical situation where some columns may be placed in a separate table for performance:</p>
                    <img src="doc5.gif" alt="Large columns moved to a separate table" />
                    <p>If the data row size is not a problem, we may still want to do the logical partitioning of data while
                        keeping them in a single table. We only need to tell Sooda to keep some fields together by grouping them in
                        a logical Table.</p>
                    <p>
                        The following example shows the Employee table which contains two large columns which we want to load separately: 
                        Picture which is an image and VoiceSample which is a blob. Possible partitions of this table are marked with
                        separate colors. Note that the primary key column is not marked because it is always present in memory and
                        does not need to be loaded at all.
                    </p>
                    <img src="doc6.gif" alt="Grouping large columns for lazy loading"/>
                    <p>
                        Sooda makes it possible to create a class based on up to 32 physical or logical tables. The only thing they
                        need to have in common is their primary key. This feature is used in inheritance, which is described <sectionlink id="inheritance" />.
                    </p>
                </body>
            </section>
            <section id="inheritance">
                <title>Inheritance</title>
                <body>
                    <p>
                        Inheritance ("is-a" relationship) is an object-oriented programming concept which is not present in
                        relational databases. One of the most important features of inheritance is polymorphism (ability to
                        act on objects through their base classes or interfaces without knowing their exact type).
                    </p>
                    <p>
                        Inheriting classes may introduce additional fields (properties) and we need a way to store them in a database.
                        There are 3 methods of storing inheritance hierarchy in database:
                    </p>
                    <ul>
                        <li><b>TPT</b> or <b>TPS</b>- table per type (or table per subclass) - each class that adds member fields stores them in a separate table</li>
                        <li><b>TPH</b> - table per hierarchy - fields for all classes in the inheritance hierarchy are stored in a single table</li>
                        <li><b>TPC</b> - table per concrete type - each concrete type (non-abstract class) is kept in its own table.</li>
                    </ul>
                    <p>
                        Assuming you have a simple hierarchy of 4 classes:
                    </p>
                    <img src="doc8.gif" alt="Hierarchy of classes" />
                    <p>
                        The TPT representation of this hierarchy looks like this (note that each subclass is stored in its own table,
                        and only the fields added in that subclass are kept there, the other fields are accessible through primary key join):
                    </p>
                    <img src="doc7.gif" alt="TPT(TPS) representation" />
                    <p>
                        TPH model (note that fields from all classes are gathered in a single table and each field from a non-root class
                        is nullable):
                    </p>
                    <img src="doc9.gif" alt="TPH representation" />
                    <p>
                        Or a TPC model (fields from the base class are repeated in all tables):
                    </p>
                    <img src="doc10.gif" alt="TPC representation" />
                    <p>
                        Supporting polymorphism in O/R mapping requires the engine to be able to create instances
                        of the proper subclass on load. This is required because when you load an object from 
                        the database you may get an instance of a subclass.
                        Object references (stored as foreign keys) are also polymorphic (you only store the key value, not the 
                        concrete type). We need a way to be able to quickly determine the concrete class that will
                        represent the object from the database.
                    </p>
                    <p>
                        TPT and TPH storage models require a special column (called discriminator column) to select between subclasses. 
                        This column needs to provide a unique mapping between the concrete class and an integer value
                        (for example 1-QuestionWorkItem, 2-AnalysisWorkItem, 3-BugWorkItem). 
                        Each time an object of a particular class is persisted, a value corresponding to its class is stored in
                        this column and on load this value is used to recreate object of the proper class.
                        TPC model does not need this column but makes it more difficult to access objects in a polymorphic manner,
                        because you need to perform a UNION select or make multiple queries in order to fetch all objects.
                    </p>
                    <p>
                        Polymorphic access enables you to write:
                    </p>
                    <code lang="C#">
<![CDATA[
WorkItem wi = WorkItem.Load(3);
if (wi is QuestionWorkItem)
{
    QuestionWorkItem qwi = (QuestionWorkItem)wi;

    Console.WriteLine("question: {0}", qwi.Question);
}

// display concrete types of all work items
foreach (WorkItem wi in WorkItem.GetList(true))
{
    Console.WriteLine("wi: {0}", wi.GetType().FullName);
}

]]>
                    </code>
                    <p>
                        Sooda supports TPT and TPH, but <b>does not support TPC model</b> because it is less efficient
                        than the other two and requires complex SQL queries to be generated.
                    </p>
                    <p>
                        Sooda extends the concept of "tables" on which each class is based to mean not only physical tables
                        but also vertical table partitions. This way you can create a mixture of TPT and TPH in your program.
                        For example you can store the hierarchy in TWO tables instead of one. You can also
                        store most commonly used subclasses in a single table but move rarely used or "heavy" data (such as blobs) 
                        to separate physical tables.
                    </p>
                </body>
            </section>
            <section id="querylanguage">
                <title>Query Language</title>
                <body>
                    <p>
                        We need a way to retrieve objects from the database based on the specified criteria. SQL is inappropriate for
                        this, because it does not make use of concepts such as:
                    </p>
                    <ul>
                        <li>path expressions (explicit joins are necessary)</li>
                        <li>collections (both one-to-many and many-to-many)</li>
                        <li>inheritance</li>
                        <li>enumerations</li>
                    </ul>
                    <p>
                        Sooda supports three object-oriented query languages:
                    </p>
                    <ul>
                        <li>text-based query language called <a href="#soqltext">SOQL</a></li>
                        <li>a <a href="#soqltypedqueries">strongly-typed</a>, in-code variant of SOQL implemented using C# operator overloading</li>
                        <li><a href="#linq">LINQ</a></li>
                    </ul>
                    <p>
                        All of them let you use path expressions and collections to write join-free powerful
                        object-oriented queries. This is described <sectionlink id="soql" />.
                    </p>
                </body>
            </section>
            <section id="caching">
                <title>Cross-transaction (Level 2) Caching</title>
                <body>
                    <p>
                        Frequent use of single rows from the database (which is common for all O/R mapping products) can be
                        expensive. The cost of an SQL server roundtrip can be quite high. Sooda implements in-memory caching of objects
                        retrieved from the SQL database (both single rows and collections) so that the speed of processing is improved.
                    </p>
                    <p>
                        The <a href="#cachingapi">Caching section</a> explains things in detail.
                    </p>
                </body>
            </section>
            <section id="dynamicfieldsoverview">
                <title>Dynamic Fields</title>
                <body>
                    <p>
                        Sooda supports creation and deletion of fields at runtime.
                        If this feature is enabled, fields can be added to any Sooda class.
                        When you add a field, Sooda creates a database table with the requested column type and optionally a foreign key constraint.
                        Dynamic fields can be accessed from Sooda objects and queries just like the fields defined in the mapping schema.
                    </p>
                    <p>
                        This feature is described<sectionlink id="dynamicfields" />.
                    </p>
                </body>
            </section>
        </section>
    </section>
    <section id="gettingstarted">
        <title>Getting Started</title>
        <body>
            <p>
                Sooda comes with a graphical wizard that can be used to automatically add Sooda support to your Visual Studio project.
                In this tutorial we will use it to create a simple C# application that exercises various features of Sooda. We will be
                using the <code>Northwind</code> database that comes with MSSQL Server but any database should be ok.
            </p>
        </body>
        <section id="gettingstartedwizard">
            <title>Configuring Sooda project</title>
            <body>
                <p>
                    Let's start by creating an empty C# Console application project in Visual Studio. After the project has been created
                    and saved to disk (you need to save your projects explicitly when using Visual Studio Express Editions), run the wizard
                    by clicking on the "Add Sooda Support to Visual Studio Project" shortcut on the Start menu:
                </p>
                <img src="docwizardlaunch.gif" class="screenshot66" />
                <p>
                    The first step of the wizard is a greeting message that reminds the user to prepare a database 
                    and choose a Visual Studio project file to configure. Choose the project by clicking <code>Browse</code>.
                    We can proceed to the next step by clicking the <code>Next</code> button.
                </p>
                <img src="docwizard1.gif" class="screenshot66" />
                <p>
                    In the second step of the wizard you need to specify database server and credentials used to connect to the database.
                    Make sure the account used to connect has the right to create additional tables in the database or you will not be able
                    to complete the wizard (using a local administrator account and Windows Authentication should be sufficient in most cases).
                    Click <code>Next</code> to proceed to the database selection:
                </p>
                <img src="docwizard2.gif" class="screenshot66" />
                <p>
                    The third step of the wizard prompts you to choose one of the databases that are running on the server. Choose <code>Northwind</code> and click <code>Next</code>.
                </p>
                <img src="docwizard3.gif" class="screenshot66" />
                <p>
                    The last page of the wizard presents a list of actions the wizard can perform for you. The default set of options should
                    be just fine, and clicking <code>Finish</code> will add Sooda support to your project as requested.
                </p>
                <img src="docwizard4.gif" class="screenshot66" />
                <p>If you choose to set advanced options by clicking the <code>Advanced Options</code> button, the wizard will present
                    you with a list of more settings each followed by the <code>Explain</code> link that will direct you to the appropriate
                    section of the documentation.
                </p>
                <img src="docwizard4a.gif" class="screenshot66" />
                <p>
                    Once you have set up your project it is time to compile it. Switch to Visual Studio and click "Build" (note that you will
                    get warnings about project file modifications - choose to Reload your project when prompted).
                </p>
                <p>
                    It is possible that you get the following error when building your project.
                </p>
                <code lang="C#">
                    error CS0234: The type or namespace name 'Drawing' does not exist in the namespace 'System' (are you missing an assembly reference?)
                </code>
                <p>
                    If you do, add 'System.Drawing.dll' reference to your project and recompile. This error may occur if you
                    use have any pictures stored in the database (which is the case with <code>Northwind</code> database).
                </p>
                <p>
                    Note how the Wizard generated the following files for your project:
                </p>
                <ul>
                    <li><code>projectname.soodaproject</code> - that stores <a href="#soodaproject">code generation settings</a></li>
                    <li><code>SoodaSchema.xml</code> - that contains the <a href="#schema">object-to-relational mapping schema</a></li>
                    <li><code>App.config</code> - that contains runtime configuration settings</li>
                </ul>
                <p>
                    In addition to these your project has been modified to automatically launch the <a href="#soodastubgen">SoodaStubGen utility</a>
                    on each build and optionally to launch <a href="#soodacompilestubs">SoodaCompileStubs</a> to precompile stubs to a DLL.
                </p>
            </body>
        </section>
        <section id="gettingstartedrenamingclasses">
            <title>Renaming classes</title>
            <body>
                <p>
                    Class names detected by the wizard are plural nouns, because this is how tables are named in the <code>Northwind</code>
                    database. For example we have <code>Territories</code> instead of <code>Territory</code>.
                    Using plurals in class names is not a good idea so we should fix it by renaming the classes.
                </p> 
                <p>
                    To do this, open <code>SoodaSchema.xml</code> and replace all plural class names with the appropriate singular forms.
                    Make sure to replace only class names not table names, so it is best to use the following renaming strategy:
                </p>
                <ol>
                    <li>replace <code>"Territories"</code> with <code>"Territory"</code> (quotes should be included in the 
                        Search For and Replace With strings)</li>
                    <li>replace <code>&lt;table name="Territory" /&gt;</code> with <code>&lt;table name="Territories" /&gt;</code></li>
                </ol>
                <p>
                    Repeat the above steps to rename:
                </p>
                <ul>
                    <li><code>Categories</code> with <code>Category</code></li>
                    <li><code>Customers</code> with <code>Customer</code></li>
                    <li><code>Employees</code> with <code>Employee</code></li>
                    <li><code>Orders</code> with <code>Order</code></li>
                    <li><code>Products</code> with <code>Product</code></li>
                    <li><code>Region</code> with <code>Region</code></li>
                    <li><code>Shippers</code> with <code>Shipper</code></li>
                    <li><code>Suppliers</code> with <code>Supplier</code></li>
                    <li><code>Territories</code> with <code>Territory</code></li>
                </ul>
                <p>
                    In addition, you should give meaningful names to all collections declared with
                    <x><collectionOneToMany /></x> and <x><collectionManyToMany /></x>. You should
                    remove <code>CollectionOf</code> and trailing digits from the names.
                </p>
                <p>
                    Remove the following files for classes that are no longer present 
                    or you will get errors about some non-existent stub classes.
                </p>
                <ul>
                    <li>Categories.cs</li>
                    <li>Customers.cs</li>
                    <li>Employees.cs</li>
                    <li>Orders.cs</li>
                    <li>Products.cs</li>
                    <li>Regions.cs</li>
                    <li>Shippers.cs</li>
                    <li>Suppliers.cs</li>
                    <li>Territories.cs</li>
                </ul>
                <p>
                    When you are done, rebuild your project.
                </p>
            </body>
        </section>
        <section id="gettingstartedcode">
            <title>Adding example code to your project</title>
            <body>
                <p>
                    It is now time to add some code to the project that will demonstrate the use of DAL classes generated by Sooda.
                    By default Sooda generates one class for each table found in the database and the name of the class corresponds to
                    the name of the table as described <sectionlink id="soodaschematoolgenschema" />.
                </p>
                <p>
                    Before you can use Sooda objects, you need to create an instance of <a href="#soodatransaction">SoodaTransaction</a> 
                    class. You can only access your objects within the transaction and after the transaction is closed, object references
                    are not valid. Typically you create a <code>SoodaTransaction</code> object in a <code>using()</code> clause.
                </p>
                <p>
                    To begin, add the following <code>using</code> clauses to the top of your <code>Program.cs</code> source file 
                    replacing <code>YOURNAMESPACE</code> with the namespace of the project:
                </p>
                <code lang="C#">
                    using Sooda;
                    using YOURNAMESPACE.TypedQueries;
                </code>
                <p>
                    Copy the following piece of code and paste it to replace the generated <code>Main()</code> method:
                </p>
                <code lang="C#">
                    public static void Main()
                    {
                        // you cannot access Sooda objects here

                        using (SoodaTransaction tran = new SoodaTransaction())
                        {
                            // access your objects here

                            // commit all changes made within transaction
                            tran.Commit();
                        }

                        // you cannot access Sooda objects here
                    }
                </code>
                <p>
                    We are now ready to test various Sooda features. Let's start with simple object loading. To load an object given its
                    primary key, you can use the generated <code>Load()</code> static method. The following code loads a row from the 
                    <code>Territories</code> table and displays its <code>TerritoryDescription</code>. Note that you use the 
                    (renamed) class names instead of the table names in your code.
                </p>
                <code lang="C#">
                    Territory t = Territory.Load("98104");
                    Console.WriteLine("Territory is: {0}", t.TerritoryDescription);
                </code>
                <p>
                    When you run this program, it should display:
                </p>
                <pre class="csharp">Territory is: Seattle</pre>
                <p>
                    To see what region Seattle belongs to, we can use the <a href="#pathexpressions">path expression</a> <code>t.Region.RegionDescription</code>:
                </p>
                <code lang="C#">
                    Territory t = Territory.Load("98104");
                    Console.WriteLine("Territory is: {0}", t.TerritoryDescription);
                    Console.WriteLine("Region is: {0}", t.Region.RegionDescription);
                </code>
                <p>
                    We can use <code>foreach()</code> to enumerate all employees from Seattle:
                </p>
                <code lang="C#">
                    Territory t = Territory.Load("98104");

                    foreach (Employee e in t.Employees)
                    {
                        Console.WriteLine("name: {0} {1} id: {2}", e.LastName, e.FirstName, e);
                    }
                </code>
                <p>
                    There is one: <code>Michael Suyama</code> and his Employee ID is <code>6</code>. 
                    Let's see a list of his all superiors:
                </p>
                <code lang="C#">
                    Employee michaelSuyama = Employee.Load(6);

                    for (Employee e = michaelSuyama; e != null; e = e.ReportsTo)
                    {
                        Console.WriteLine("id={0} name={1} {2} reports to={3}", 
                             e.EmployeeID, e.LastName, e.FirstName, e.ReportsTo);
                    }
                </code>
                <p>
                    Running this code presents us with a list of 3 people and their IDs:
                </p>
                <code lang="C#">
                    id=6 name=Suyama Michael reports to=5
                    id=5 name=Buchanan Steven reports to=2
                    id=2 name=Fuller Andrew reports to=
                </code>
                <p>
                    What if we wanted to find people by their names? 
                    Sooda supports three query languages: <a href="#linq">LINQ</a>,
                    <a href="#soqltypedqueries">typed queries</a> (supported only in C#) and <a href="#soqltext">SOQL</a>.
                </p>
                <code lang="C#"><![CDATA[
                    foreach (Employee emp in Employee.Linq().Where(e => e.LastName == "Suyama"))
                    {
                        Console.WriteLine("{0}", emp.FirstName);
                    }
                ]]></code>
                <p>
                    Same query using Typed Queries:
                </p>
                <code lang="C#">
                    foreach (Employee emp in Employee.GetList(EmployeeField.LastName == "Suyama"))
                    {
                        Console.WriteLine("{0}", emp.FirstName);
                    }
                </code>
                <p>
                    Same query using SOQL:
                </p>
                <code lang="C#">
                    foreach (Employee emp in Employee.GetList(new SoodaWhereClause("LastName == {0}", "Suyama")))
                    {
                        Console.WriteLine("{0}", emp.FirstName);
                    }
                </code>
                <p>
                    LINQ and Typed Queries have the advantage of queries being validated at compile time.
                    This is great when developing large ever-changing projects, as you can immediately know the impact
                    of removing a field or changing its data type.
                </p>
                <p>
                    In all three Sooda query languages you use <a href="#soqlpathexpressions">path expressions</a>
                    instead of SQL <code>JOIN</code> operators.
                    The following example displays the details of all shipments made via "Speedy Express"
                    carrier that have more than 3 items:
                </p>
                <code lang="C#">
                    <![CDATA[
                    foreach (Order o in Order.GetList(
                        OrderField.ShipVia.CompanyName == "Speedy Express" &&
                        OrderField.Items.Count > 3))
                    {
                        Console.WriteLine("Order #{0} Date: {1}", o.OrderID, o.OrderDate);
                        Console.WriteLine("Ship to: {0} {1} {2} {3} {4}", 
                                o.ShipName, o.ShipAddress, 
                                o.ShipCity, o.ShipPostalCode, 
                                o.ShipCountry);


                        for (int i = 0; i < o.Items.Count; ++i)
                        {
                            Product p = Product.Load(o.Items[i].Product);

                            Console.WriteLine("  {0}. {1} {2} x {3}", i, 
                                p.ProductName, p.UnitPrice, o.Items[i].Quantity);
                        }
                        //Console.WriteLine("o: {0}", o.Items.Count);
                    }
                    ]]>
                </code>
                <p>
                    Creating and modifying objects is easy. To create objects you simply use the familiar <code>new</code> 
                    construct. To create new order you would write:
                </p>
                <code lang="C#">
                    Order o = new Order();
                </code>
                <p>
                    To modify objects, just set their appropriate properties:
                </p>
                <code lang="C#">
                    o.ShipCity = "Redmond";
                    o.ShipCountry = "US";
                    o.ShipPostalCode = "98052";
                    o.ShipAddress = "One Microsoft Way";
                </code>
                <p>
                    When you are done with object modifications, you can call the <code>Commit()</code> method on the transaction
                    object to save your changes to the database.
                </p>
            </body>
        </section>
    </section>
    <section id="schema">
        <title>O/R Mapping Schema</title>
        <body>
            <p>
                O/R Mapping Schema defines the mapping between CLI classes and database tables. 
            </p>
            <p>
                The schema is contained in an XML file that is the input to <a href="#soodastubgen">SoodaStubGen utility</a> which
                generates class stubs. You can write the XML file by hand or you can use a tool, such as 
                <a href="#soodaschematool">SoodaSchemaTool</a> to generate it for you by reverse-engineering the database.
                Note that it is not possible to generate the mapping schema in a fully automated manner. There are 
                things that simply cannot be retrieved from the database (such as inheritance relationships, named constants, many-to-many
                relationship names), anyway the tools can give you a good approximation of the actual schema.
            </p>
            <p>
                The root of the XML document is the <x><schema /></x> element with the appropriate XML namespace (<code>http://www.sooda.org/schemas/SoodaSchema.xsd</code>).
                Child elements of the <x><schema /></x> define classes, relations and so on, as described below.
            </p>
            <code lang="XML">
                <![CDATA[
                <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                    <datasource />

                    <class />
                    <class />
                    <class />
                    <class />

                    <relation />
                    <relation />
                </schema>
                ]]>
            </code>
        </body>
        <section id="schemadatasources">
            <title>Data Sources - <x><datasource /></x></title>
            <body>
                <p>
                    Data Sources are defined with the <x><datasource /></x> element. A data source represents a 
                    connection to the database (or other store) where entities are stored. Each data source has a name and type. 
                    Sooda currently supports only <a href="#sqldatasource">Sql Data Source</a>, but
                    it is (theoretically) possible to add more data source types. Unless specified otherwise, the 
                    default data source for a class or relation is "<code>default</code>", which you need to have defined.
                </p>
                <p>
                    While Sooda supports no other data source types, the declaration that should be present at the beginning of each
                    mapping schema is:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <datasource name="default" type="Sooda.Sql.SqlDataSource" />
                    </schema>
                    ]]>
                </code>
                <p>
                    You can define additional SQL-based data sources for example to connect to multiple databases at once. Sooda
                    will keep a single connection to each data source, but will not create one until you use an object that is based on
                    this data source.
                </p>
            </body>
        </section>
        <section id="schemaclasses">
            <title>Classes - <x><class /></x></title>
            <body>
                <p>
                    Classes are defined using <x><class /></x> elements. Each class is based on 
                    one or more tables, each represented by a <x><table /></x> element. 
                    The following table lists available
                    attributes of the <x><class /></x> element (bold ones are required).
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Class name - used by <a href="#soodastubgen">SoodaStubGen</a> to generate 
                                    the class skeleton, stub and related classes (factory, list wrapper, typed queries and so on).
                                    Details about the generated code can be found <sectionlink id="generatedcode" />.
                                </td>
                            </tr>
                            <tr>
                                <td>cardinality</td>
                                <td>ClassCardinality</td>
                                <td>Specifies the approximate number of instances of this class (number of rows in a table).
                                    Possible values are:
                                    <ul>
                                        <li><b>Small</b> - up to 20-30</li>
                                        <li><b>Medium</b> - more than Small, up to 200-300</li>
                                        <li><b>Large</b> - more than a few hundred</li>
                                    </ul>
                                    The default value is <b>Medium</b>. You may want to specify other values as a hint to the cache optimizer.
                                    Other than that, this value is not used.
                                </td>
                            </tr>
                            <tr>
                                <td>datasource</td>
                                <td>string</td>
                                <td>Specifies the name of the <a href="#sqldatasource">data source</a> for this class. The default name is "default".</td>
                            </tr>
                            <tr>
                                <td>extBaseClassName</td>
                                <td>string</td>
                                <td>Specifies the name of the base class that this class should inherit from. By default each class N inherits 
                                    from N_Stub which in turn inherits from SoodaObject. Set this option to make the stub class inherit from some other class.
                                    Note that the class must ultimately inherit from SoodaObject (either directly or indirectly).
                                </td>
                            </tr>
                            <tr>
                                <td>label</td>
                                <td>string</td>
                                <td>Name of the property that provides the human readable "identity" of the object. For example the 
                                    "Person" class might have a label of "Name" or "Email", the "Location" class
                                    might have a label of "Address".
                                    The label is used to generate the default implementation of ToString() for object.
                                </td>
                            </tr>
                            <tr>
                                <td>keygen</td>
                                <td>string</td>
                                <td>Specifies a method that will be used to generate primary keys for newly created objects. 
                                    The following options are supported:
                                    <ul>
                                        <li><b>guid</b> - generate GUID keys in-memory by calling Guid.NewGuid()</li>
                                        <li><b>integer</b> - pregenerates integer keys in the database by storing them in the KeyGen table. This is the default.</li>
                                        <li><b>long</b> - pregenerates long (64-bit) keys in the database by storing them in the KeyGen table.</li>
                                        <li><b>none</b> - don't generate a key automatically</li>
                                    </ul>
                                    Alternatively you can provide a name of the class that implements IPrimaryKeyGenerator that will provide primary keys. 
                                    This class call a webservice or use other means necessary to generate keys in a coordinated manner, guaranteeing that
                                    no two sessions will ever get the same primary key.
                                </td>
                            </tr>
                            <tr>
                                <td>inheritFrom</td>
                                <td>string</td>
                                <td>
                                    Specifies the base class. This parameter is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>defaultPrecommitValue</td>
                                <td>depends on primary key type</td>
                                <td>
                                    Specifies the default precommit value for this class. This is the value that will be INSERTed into
                                    the database for each not-nullable column that does not have a value specified. You can override it on the
                                    <a href="#schemafield"><x><field /></x></a> level.
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorValue</td>
                                <td>depends on primary key type</td>
                                <td>
                                    Specifies the value of the subclass selector field that determines this object type. This parameter 
                                    is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorField</td>
                                <td>string</td>
                                <td>
                                    Specifies the name of the subclass selector field that determines this object type. This parameter 
                                    is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>cached</td>
                                <td>bool</td>
                                <td>
                                    Caching hint. The actual interpretation depends on the <a href="#caching">caching policy</a> that is in effect.
                                </td>
                            </tr>
                            <tr>
                                <td>cacheCollections</td>
                                <td>bool</td>
                                <td>
                                    Collection caching hint. The actual interpretation depends on the <a href="#caching">caching policy</a> that is in effect.
                                </td>
                            </tr>
                            <tr>
                                <td>disableTypeCache</td>
                                <td>bool</td>
                                <td>Disable type cache for this type. This parameter is described in the <a href="#schemainheritance">inheritance section</a></td>
                            </tr>
                            <tr>
                                <td>triggers</td>
                                <td>bool</td>
                                <td>Determines whether <a href="#triggers">triggers</a> should be generated for this class.</td>
                            </tr>
                            <tr>
                                <td>readOnly</td>
                                <td>boolean</td>
                                <td>
                                    Generates read-only class. No property setters are generated in such case 
                                    and some scenarios are optimized.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
        </section>
        <section id="schematable">
            <title>Tables - <x><table /></x></title>
            <body>
                <p>
                    <x><table /></x> elements are used to define the mapping from database tables to classes and relations as described
                    <sectionlink id="mappingtablestoclasses" />. Each class is based on at least one <x><table /></x> element. Each table consists of <x><field /></x> 
                    elements which represent columns in a database and properties in C#/VB. Each table must have at least one
                    field which is marked as the primary key. Compound primary keys (formed by multiple fields with primaryKey attribute)
                    are supported, but tables with zero primary keys are not allowed.
                </p>
                <p>
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="className">
                        <table name="tableName1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                        <table name="tableName2">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                        <table name="tableName3">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    The typical definition of a class that is based on a single table looks like this:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Person">
                        <table name="Person">
                            <field name="Id" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Location" type="String" size="40" />
                            <field name="PictureBlob" type="Image" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    <x><field /></x> elements are discussed in depth <sectionlink id="schemafield" />.
                </p>
                <p>
                    Objects may need to be <a href="#mappingmultipletablestoclasses">stored in multiple tables</a> for efficiency reasons. 
                    In the following example we have two tables - one has employee ID, Name, Salary, HireDate and Active flag, 
                    the other stores his/her Picture (potentially very large piece of binary data that encodes the person's photo). 
                    By storing the picture in a separate table we can avoid reading from it until the data is actually needed.
                </p>
                <img src="doc5.gif" alt="Large columns moved to a separate table" />
                <p>
                    This is represented by the following fragment of schema:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                        <table name="EmployeePicture">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Picture" type="Image" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    Each <x><table /></x> is a unit for the load operation, which means whenever you access
                    one field from a table, the entire table row gets loaded and is cached for further accesses. This is easy way 
                    to implement fine-grained <a href="#lazyloading">lazy loading</a> by splitting your fields in groups that are always accessed together.
                </p>
                <p>
                    It is possible to have two <x><table /></x> elements that are bound to the same physical database table. You only need to repeat
                    the primary key field in each <x><table /></x> element. This allows for column-based lazy loading without the need to create
                    additional database tables. For example, the following Employee class uses mentioned partitioning feature
                    to avoid loading Picture and VoiceSample with other columns.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Picture" type="Image" />
                        </table>
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="VoiceSample" type="Blob" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    The table definition looks like this (different lazy loading groups are marked with different colors):
                </p>
                <img src="doc11.gif" alt="Lazy loading groups" />
                <p>
                    Example: We have 4 objects: Adam (Person, with primary key 1), Eva (with primary key 2), 
                    Mary (with primary key 3), John (with primary key 4). Let's assume they are represented by the 
                    corresponding variable names and see how lazy loading works as we access their properties and
                    display them.
                </p>

                <code lang="C#">
                    <![CDATA[
                    Person adam;
                    Person eva;
                    Person mary;
                    Person john;

                    // 1. read Adam's name - this causes a SELECT on a database.
                    Console.WriteLine(adam.Name); 

                    // 2. read Adam's address - database access is not needed because the appropriate row
                    // from the database has been loaded in step #1
                    Console.WriteLine(adam.Location); 

                    // 3. access the picture of Adam - we need to access a database
                    Console.WriteLine(adam.Picture); 

                    // 4. we load PictureBlob for Eva (note that neither Name nor Location is loaded yet)
                    Console.WriteLine(eva.Picture); 

                    // 5. access the Name of Eva - we load it along with her Location
                    Console.WriteLine(eva.Name); 

                    // 6. location already loaded in step #5 - no database read here
                    Console.WriteLine(eva.Location); 

                    // 7. read Adam's name - no database access - already loaded in step #1
                    Console.WriteLine(adam.Name); 

                    // 8. read Adam's picture - no database access - already loaded #3
                    Console.WriteLine(adam.Picture); 

                    // 9. read Adam's voice sample - causes a select on a database
                    Console.WriteLine(adam.VoiceSample.Length); 
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemafield">
            <title>Fields - <x><field /></x></title>
            <body>
                <p>
                    <x><field /></x> elements define the mapping between database columns and object properties or fields in relation table.
                    Each field represents a single column in the database.
                </p>

                <p>
                    Usage in a class definition:
                </p>

                <code lang="XML">
                    <![CDATA[
                    <class name="class1">
                        <table name="table1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                    </class>
                    ]]>
                </code>

                <p>
                    Usage in many-to-many relation definition:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <relation name="class1">
                        <table name="table1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" primaryKey="true" />
                        </table>
                    </relation>
                    ]]>
                </code>

                <p>
                    The following attributes are available on the <x><field /></x> element. Attributes marked with bold are required:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Field name - used by <a href="#soodastubgen">SoodaStubGen</a> to generate 
                                    the C#/VB.NET property 
                                </td>
                            </tr>
                            <tr>
                                <td><b>type</b></td>
                                <td>FieldDataType</td>
                                <td>Data type. See the <a href="#schemadatatypes">supported data types</a> for more information.</td>
                            </tr>
                            <tr>
                                <td>dbcolumn</td>
                                <td>string</td>
                                <td>Name of the database column. If it is not specified, Sooda assumes this is the same
                                    as 'name'</td>
                            </tr>
                            <tr>
                                <td>size</td>
                                <td>integer</td>
                                <td>Data type size.</td>
                            </tr>
                            <tr>
                                <td>precision</td>
                                <td>integer</td>
                                <td>Data type precision.</td>
                            </tr>
                            <tr>
                                <td>references</td>
                                <td>string</td>
                                <td>Name of the class that this field references. The referenced class must have a single-field (i.e. not
                                    compound) primary key. It is not possible to automatically generate references to classes 
                                    with compound primary keys, but it is possible to do it in code.</td>
                            </tr>
                            <tr>
                                <td>onDelete</td>
                                <td>DeleteAction</td>
                                <td>The action to be taken when the referenced object is deleted (valid when <b>references</b> is not empty).
                                    <ul>
                                        <li><b>Nothing</b> - do nothing, the programmer will take care of updating/deleting the 
                                            appropriate object references. Failing to do so will result in referential integrity violation</li>
                                        <li><b>Nullify</b> - set this field value to null (possible only for nullable fields)</li>
                                        <li><b>Cascade</b> - delete this object</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>prefetch</td>
                                <td>integer</td>
                                <td>Prefetch level for this field. See the <a href="#prefetch">prefetching objects</a> section for more information.</td>
                            </tr>
                            <tr>
                                <td>nullable</td>
                                <td>boolean</td>
                                <td>Allow this field to hold the null value. Exact <a href="#generatedproperties">representation of the null value</a> depends on options passed to <a href="#soodastubgen">SoodaStubGen</a>.</td>
                            </tr>
                            <tr>
                                <td>readOnly</td>
                                <td>boolean</td>
                                <td>This field cannot be modified (no property setter is generated).</td>
                            </tr>
                            <tr>
                                <td>forceTrigger</td>
                                <td>boolean</td>
                                <td>Always generate <a href="#triggers">triggers</a> for this field even if <code>triggers</code> attribute for the enclosing class is set to <code>false</code>.</td>
                            </tr>
                            <tr>
                                <td>primaryKey</td>
                                <td>boolean</td>
                                <td>Mark this field as primary key. Each <a href="#schematable"><x><table /></x></a> must have at least one field marked as primary key.</td>
                            </tr>
                            <tr>
                                <td>precommitValue</td>
                                <td>depends on data type</td>
                                <td>The value to be used when <a href="#precommit">precommitting</a> not-nullable field and the value is not yet provided. Makes sense only for not-null fields.</td>
                            </tr>
                            <tr>
                                <td>find</td>
                                <td>boolean</td>
                                <td>
                                    Generate "finder" method for this field. The method will be named <code>FindByNNN</code> where <code>NNN</code> is the name of the field and will return 
                                    an instance of the class the field is defined in that has field NNN set to the passed value.
                                    For example, when you declare:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Class1">
                                            <table name="Table1">
                                                <field name="Id" type="Integer" primaryKey="true" />
                                                <field name="Name" type="String" find="true" />
                                            </table>
                                        </class>
                                        ]]>
                                    </code>
                                    <p>
                                        SoodaStubGen will generate:
                                    </p>
                                    <code lang="C#">
                                        class Class1
                                        {
                                            ...
                                            public static Class1 FindByName(string name)
                                            {
                                                // 
                                            }
                                            ...
                                        }
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>findList</td>
                                <td>boolean</td>
                                <td>
                                    Generate list "finder" method for this field. The method will be named <code>FindListByNNN</code> where <code>NNN</code> is the name of the field and will return 
                                    a list of objects that have NNN set to the passed value.
                                    For example, when you declare:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Class1">
                                            <table name="Table1">
                                                <field name="Id" type="Integer" primaryKey="true" />
                                                <field name="Name" type="String" findList="true" />
                                            </table>
                                        </class>
                                        ]]>
                                    </code>
                                    <p>
                                        SoodaStubGen will generate:
                                    </p>
                                    <code lang="C#">
                                        class Class1
                                        {
                                            ...
                                            public static Class1List FindListByName(string name)
                                            {
                                                // 
                                            }
                                            ...
                                        }
                                    </code>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    There is no support for compound properties (that would map to more than one field), but it is relatively easy 
                    to do it by hand by adding a new property of the required type.
                </p>
            </body>
            <section id="schemadatatypes">
                <title>Supported data types</title>
                <body>
                    <p>
                        The following data types are supported for the <code>type</code> attribute of <a href="#schemafield"><x><field /></x></a>:
                    </p>
                    <div class="table">
                        <table>
                            <col style="font-family: Consolas, Courier New" />
                            <col style="font-family: Consolas, Courier New" />
                            <col style="font-family: Consolas, Courier New" />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>C# Type</th>
                                    <th>Database Type</th>
                                    <th>Comments</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td valign="top">Integer</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>int</li>
                                            <li>SqlInt32</li>
                                            <li>Nullable&lt;int&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">int (32-bit)</td>
                                    <td valign="top">For databases that do not support 32-bit integers (such as Oracle) you can use the appropriate numeric type</td>
                                </tr>
                                <tr>
                                    <td valign="top">Long</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>long</li>
                                            <li>SqlInt64</li>
                                            <li>Nullable&lt;long&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">bigint (64-bit)</td>
                                    <td valign="top">For databases that do not support 64-bit integers (such as Oracle) you can use the appropriate numeric type</td>
                                </tr>
                                <tr>
                                    <td valign="top">Boolean</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>bool</li>
                                            <li>SqlBoolean</li>
                                            <li>Nullable&lt;bool&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">bit</td>
                                    <td valign="top">The data provider should return the value in response to calling IDataReader.GetBoolean().</td>
                                </tr>
                                <tr>
                                    <td valign="top">BooleanAsInteger</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>bool</li>
                                            <li>SqlBoolean</li>
                                            <li>Nullable&lt;bool&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">int</td>
                                    <td valign="top">The database stores true as 1 and false as 0. When reading any value other than zero is considered "true" and zero is considered "false"</td>
                                </tr>
                                <tr>
                                    <td valign="top">Decimal</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>decimal</li>
                                            <li>SqlDecimal</li>
                                            <li>Nullable&lt;decimal&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">decimal</td>
                                    <td valign="top">
                                        The Decimal value type is appropriate for financial calculations requiring large numbers of 
                                        significant integral and fractional digits and no round-off errors.
                                    </td>
                                </tr>
                                <tr>
                                    <td valign="top">Float</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>float</li>
                                            <li>SqlSingle</li>
                                            <li>Nullable&lt;float&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">float</td>
                                    <td valign="top">32-bit precision floating point</td>
                                </tr>
                                <tr>
                                    <td valign="top">Double</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>double</li>
                                            <li>SqlDouble</li>
                                            <li>Nullable&lt;double&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">real</td>
                                    <td valign="top">64-bit precision floating point</td>
                                </tr>
                                <tr>
                                    <td valign="top">DateTime</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>DateTime</li>
                                            <li>SqlDateTime</li>
                                            <li>Nullable&lt;DateTime&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>datetime</li>
                                            <li>smalldatetime</li>
                                            <li>timestamp</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Date and/or time value</td>
                                </tr>
                                <tr>
                                    <td valign="top">String</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>String</li>
                                            <li>SqlString</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>nvarchar</li>
                                            <li>ntext</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Unicode String</td>
                                </tr>
                                <tr>
                                    <td valign="top">AnsiString</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>String</li>
                                            <li>SqlString</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>varchar</li>
                                            <li>text</li>
                                        </ul>
                                    </td>
                                    <td valign="top">ANSI String (8-bit characters)</td>
                                </tr>
                                <tr>
                                    <td valign="top">Blob</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>byte[]</li>
                                            <li>SqlBinary</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>binary</li>
                                            <li>varbinary</li>
                                            <li>image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Block of bytes</td>
                                </tr>
                                <tr>
                                    <td valign="top">Guid</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>Guid</li>
                                            <li>SqlGuid</li>
                                            <li>Nullable&lt;Guid&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>uniqueidentifier</li>
                                        </ul>
                                    </td>
                                    <td valign="top">128-bit randomly generated unique identifier.
                                        GUID is not guaranteed to be unique, but the number of GUIDS (2^128) is so large that the possibility of collision is very small.</td>
                                </tr>
                                <tr>
                                    <td valign="top">TimeSpan</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>TimeSpan</li>
                                            <li>Nullable&lt;TimeSpan&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>int</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Timespan value represented as integral number of seconds.</td>
                                </tr>
                                <tr>
                                    <td valign="top">Image</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>System.Drawing.Image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>binary</li>
                                            <li>varbinary</li>
                                            <li>image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Block of bytes interpreted as image(picture) by the System.Drawing.Image class</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
        </section>
        <section id="schemaconst">
            <title>Named Constants - <x><const /></x></title>
            <body>
                <p>
                    The <x><const /></x> element defines <a href="#generatedenums">named constants</a> to be generated. 
                    Each constant has a name and value, whose type depends on the primary key type of this class. Constants are
                    not supported for classes with compound primary keys or where the type of the primary key is other than Integer or
                    String.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class>
                        ...
                        <const name="..." value="..." />
                    </class>
                    ]]>
                </code>
                <p>
                    Example:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="User">
                        <table name="User">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                        </table>

                        <const name="Administrator" value="1" />
                        <const name="Guest" value="2" />
                        <const name="SystemUser" value="2" />
                    </class>
                    ]]>
                </code>
                <p>
                    Once you have defined the constants you may use them instead of calling classname.GetRef(). Note that you cannot
                    pass the instance of <a href="#soodatransaction">SoodaTransaction</a> so constants are limited to 
                    be used in the context of implicit transaction.
                </p>
                <code lang="C#">
                    User.GetRef(1) == User.Administrator
                    User.GetRef(2) == User.Guest
                    User.GetRef(3) == User.SystemUser
                </code>
            </body>
        </section>
        <section id="schema1N">
            <title>One-To-Many Relationships - <x><collectionOneToMany /></x></title>
            <body>
                <p>
                    One-to-many relationships are defined using <x><collectionOneToMany /></x> which needs to be placed inside <x><class /></x> element.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="className">
                        <field />
                        <field />
                        <field />
                        <field />
                        <collectionOneToMany name="COLLECTION_NAME" class="CHILD_CLASS" foreignField="FOREIGN_FIELD" />
                    </class>
                    ]]>
                </code>
                <p>
                    In short, it defines a collection named COLLECTION_NAME whose items are of class CHILD_CLASS where the value of
                    FOREIGN_FIELD equals to this object's primary key. In other words this is a list of objects referencing this object
                    through the specified reference field.
                </p>
                <p>
                    Sooda also supports additional attribute named <code>where</code> which can be used to define where clause to
                    be used when fetching objects. This can be used to create filtered collections:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Group">
                        <collectionOneToMany name="Members" class="Person" foreignField="Group" />
                        <collectionOneToMany name="VipMembers" class="Person" foreignField="Group" where="IsVip = True" />
                    </class>
                    ]]>
                </code>
                <p>
                    The above example defines two collections in the Group class: one named <code>Members</code> holds all members of
                    the group, the other is named <code>VipMembers</code> and holds only members who are VIPs.
                </p>
                <p>
                    <b>CAUTION:</b> Collections defined with "where" are not recommended because they do not automatically reflect
                    the state of child objects when you manually change the foreignField. Collections without where clause
                    do not exhibit this problem.
                </p>
                <p>
                    The details about generated code can be found <sectionlink id="generatedcollections" />.
                </p>
            </body>
        </section>
        <section id="schemaNN">
            <title>Many-To-Many Relationships - <x><collectionManyToMany /></x> and <x><relation /></x></title>
            <body>
                <p>
                    Many-to-many relationships are defined using 
                    <x><collectionManyToMany /></x> in cooperation with the <x><relation /></x>.
                    The <x><collectionManyToMany /></x> needs to be placed inside <x><class /></x> element
                    and <x><relation /></x> needs to be placed inside <x><schema /></x> element.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema>
                        <class name="className">
                            ...
                            <collectionManyToMany name="COLLECTION_NAME" relation="RELATION" foreignField="FOREIGN_FIELD" />
                        </class>

                        <relation name="RELATION">
                            <table name="RELATION_TABLE">
                                <field name="f1" type="t1" primaryKey="true" references="R1" />
                                <field name="f2" type="t2" primaryKey="true" references="R2" />
                            </table>
                        </relation>
                    </schema>
                    ]]>
                </code>
                <p>
                    The <x><relation /></x> element defines a relation (table) that resolves many-to-many relationships.
                    It must include exactly two fields, which are references to other tables. 
                </p>
                <p>
                    Each record in this table represents a relationships between two objects pointed at by the fields.
                    For example, assuming we have a relation Contact2Group with 2 columns: contact_id and group_id
                    and it contains a row where contact_id=1 and group_id=7 it means that contact[1] and group[7] are in
                    (some) relationship. The name of the relationship is established by <x><collectionManyToMany /></x>.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <relation name="Contact2Group">
                        <table name="Contact2Group">
                            <field name="TheContact" type="Integer" references="Contact" primaryKey="true" />
                            <field name="TheGroup" type="Integer" references="Group" primaryKey="true" />
                        </table>
                    </relation>
                    ]]>
                </code>
                <p>
                    Each side of the relation has a multiplicity of "many", which means each contact may be in relationship 
                    with many groups and each group can be in relationship with many contacts. This is represented
                    by a pair of strongly typed collections.
                </p>
                <p>
                    The collections are declared using <x><collectionManyToMany /></x>.
                </p>
                <code lang="C#">
                    class Contact
                    {
                        GroupList Groups { get; }
                    }

                    class Group
                    {
                        ContactList Members { get; }
                    }
                </code>
                <p>
                    The <x><collectionManyToMany /></x> declaration accepts the following attributes:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Collection name</td>
                            </tr>
                            <tr>
                                <td><b>relation</b></td>
                                <td>string</td>
                                <td>Name of the relation (table) that represents the relationship.</td>
                            </tr>
                            <tr>
                                <td><b>foreignField</b></td>
                                <td>string</td>
                                <td>Name of the field defined in <x><relation /></x> that points back at the
                                    object that declares the collection. For example, considering the Contact2Group relation defined above,
                                    you should put this in <x><class name="Contact" /></x> to get Contact.Groups collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Contact">
                                            ...
                                            <collectionManyToMany name="Groups" relation="Contact2Group" foreignField="TheContact" />
                                        </class>
                                        ]]>
                                    </code>
                                    Symmetrically, you should put this in <x><class name="Group" /></x> to get the Group.Members collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Group">
                                            ...
                                            <collectionManyToMany name="Members" relation="Contact2Group" foreignField="TheGroup" />
                                        </class>
                                        ]]>
                                    </code>
                                    You can of course choose not to declare collections. This is a way to get unidirectional relationships.
                                </td>
                            </tr>
                            <tr>
                                <td>masterField</td>
                                <td>integer (0 or 1)</td>
                                <td>The ordinal of the field defined in <x><relation /></x> that points at the referenced object.
                                    Specifying this attribute is equivalent to providing the appropriate value of foreignField, but
                                    the meaning is reversed. The following declaration declares Contact.Groups and Group.Members collections:
                                    Then you should put this in <x><class name="Contact" /></x> to get Groups collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Contact">
                                            ...
                                            <collectionManyToMany name="Groups" relation="Contact2Group" masterField="1" />
                                        </class>
                                        ]]>
                                    </code>
                                    Symmetrically, you should put this in <x><class name="Group" /></x> to get the Members collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Group">
                                            ...
                                            <collectionManyToMany name="Members" relation="Contact2Group" masterField="0" />
                                        </class>
                                        ]]>
                                    </code>
                                    <b>
                                        OBSOLETE WARNING: It is recommended not to use masterField, but use foreignField instead. masterField
                                        is provided only for compatibility purposes and may be removed in future versions.
                                    </b>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    The details about generated code can be found in <sectionlink id="generatedcollections" />.
                </p>
            </body>
        </section>
        <section id="schemainclude">
            <title>Include Files - <x><include /></x></title>
            <body>
                <p>
                    Schemas can include one another. This is a way to split complex domain models into many manageable files
                    which are subject to separate compilation and code generation.
                </p>
                <p>
                    You need to use the <x><include /></x> to include another schema. The following attributes are supported
                    (attributes marked with bold are required).
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>schema</b></td>
                                <td>string</td>
                                <td>Path to the included schema. 
                                    The path is relative to the directory where the including schema is located.
                                </td>
                            </tr>
                            <tr>
                                <td><b>namespace</b></td>
                                <td>string</td>
                                <td>Namespace of the included schema. Sooda will generate the appropriate <b>using</b> clause.</td>
                            </tr>
                            <tr>
                                <td><b>assembly</b></td>
                                <td>string</td>
                                <td>Name of the assembly (without *.dll extension) that contains classes generated from the schema</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Example usage (assuming that SoodaSchema.xml is located in c:\MyProject the included file 
                    should be located in c:\MyProject\SharedBusinessObjects\SoodaSchema.xml):
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <include schema="SharedBusinessObjects/SoodaSchema.xml" namespace="MyCompany.SharedBusinessObjects" assembly="MyCompany.SharedBusinessObjects" />
                    </schema>
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemainheritance">
            <title>Inheritance</title>
            <body>
                <p>
                    In order to define <a href="#inheritance">inheritance relationship</a> you need to designate one class which will serve
                    as a root of the inheritance hierarchy and make other inherit (directly or indirectly) from it.
                    Attributes which control inheritance are specified at the <x><class /></x> level. They are:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>subclassSelectorField</td>
                                <td>string</td>
                                <td>
                                    <p>
                                        Specifies the name of the subclass selector field that determines this object type. The
                                        field must be defined in this <x><class /></x>, in the first <x><table /></x> and must
                                        be either integer or string. Based on the value stored in this field Sooda is
                                        able to instantiate objects of the appropriate class in a polymorphic manner.
                                        Values stored in this field correspond to concrete (non-abstract) classes and are defined
                                        using <code>subclassSelectorValue</code>. See examples below.
                                    </p>
                                    <p>
                                        The class that defines subclassSelectorField is named the root of inheritance hierarchy.
                                        You cannot put subclassSelectorField in any class that inherits from another class 
                                        (to form sub-hierarchies). This feature might be added in future versions of Sooda.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>inheritFrom</td>
                                <td>string</td>
                                <td>
                                    Inherits from the specified class. The class must either be the root of the inheritance hierarchy
                                    or inherit (directly or indirectly) from such a class. It is an error to inherit from a class
                                    that does not ultimately derive from a root class (that has <code>subclassSelectorField</code> defined).
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorValue</td>
                                <td>integer or string</td>
                                <td>
                                    <p>
                                        Specifies the value of the subclass selector field that determines this object type. This parameter
                                        must be is specified for each concrete (non-abstract) class in the inheritance hierarchy.
                                        Sooda will instantiate objects of the appropriate type based on a value of the subclassSelectorField.
                                        If the value is equal to subclassSelectorValue for a particular class, an instance of this
                                        class will be created to represent the object.
                                    </p>
                                    <p>
                                        If you do not specify the value for subclassSelectorValue, <a href="#soodaschematool">SoodaStubGen</a>
                                        will generate an abstract class that cannot be instantiated programmatically.
                                    </p>
                                    <p>
                                        Values provided in subclassSelectorValue are also used in polymorphic queries to
                                        limit the selected objects to instances of a particular class. For example if you
                                        get a list of objects of a particular class you may get objects of this class (provided that they are
                                        not abstract) and all non-abstract classes that derive from it, either directly or indirectly.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    The following table summarizes possible combinations of the above attributes:
                </p>
                <div class="table">
                    <table>
                        <col align="center" valign="top" width="10%" />
                        <col align="center" valign="top" width="10%" />
                        <col align="center" valign="top" width="10%" />
                        <col width="70%" />
                        <thead>
                            <tr>
                                <th>subclassSelectorField</th>
                                <th>subclassSelectorValue</th>
                                <th>inheritFrom</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>A class that does not participate in inheritance hierarchy</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>defined</td>
                                <td>not defined</td>
                                <td>Root non-abstract class. Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>Root abstract class (cannot create instances). Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>Non-root abstract class. Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>defined</td>
                                <td>Non-root non-abstract class. Can have subclasses. Can create instances.</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>(any)</td>
                                <td>defined</td>
                                <td><b style="color: red">Not allowed.</b> Cannot define a class that has both subclassSelectorField and inherits from another class</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>not defined</td>
                                <td><b style="color: red">Not allowed.</b> When providing subclassSelectorValue you need to also provide subclassSelectorField or inheritFrom</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Sooda supports two models of inheritance mapping: table-per-hierarchy (TPH) and table-per-subclass (TPS) as described <sectionlink id="inheritance" />.
                    They only differ in actual table names used to store fields in subclasses, so the configuration is similar. Assuming
                    the familiar table of WorkItems structure we can map it to classes using the provided schema:
                </p>
                <img src="doc7.gif" alt="TPT(TPS) representation of inheritance hierarchy" />
                <p>
                    The schema that maps this to a class hierarchy using TPS model is:
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <!-- Root class of the inheritance hierarchy. -->
                            <!-- Note that it is abstract because it does not define subclassSelectorValue -->
                            <class name="WorkItem" subclassSelectorField="Type">
                                <table name="WorkItem">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Type" type="Integer" />
                                    <field name="AssignedTo" type="Integer" />
                                    <field name="AssignedDate" type="DateTime" />
                                    <field name="DueDate" type="DateTime" />
                                </table>
                            </class>

                            <!-- Concrete class stored in QuestionWorkItem table, identified by Type=1 -->
                            <class name="QuestionWorkItem" subclassSelectorValue="1">
                                <table name="QuestionWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Question" type="String" size="40" />
                                    <field name="Answer" type="String" size="40" />
                                </table>
                            </class>
                            <!-- Concrete class stored in AnalysisWorkItem table, identified by Type=2 -->
                            <class name="AnalysisWorkItem" subclassSelectorValue="2">
                                <table name="AnalysisWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Subject" type="String" size="40" />
                                </table>
                            </class>

                            <!-- Concrete class stored in BugWorkItem table, identified by Type=3 -->
                            <class name="BugWorkItem" subclassSelectorValue="3">
                                <table name="BugWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="BugID" type="Integer" />
                                    <field name="BugDescription" type="String" size="40" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    The mapping in TPH model is very similar. You only need to change the table names, so
                    that they are all "TPH_WorkItem". We will also rename fields by prefixing them with acronyms
                    of concrete subclasses they belong to:
                </p>
                <img src="doc9.gif" alt="TPH model" />
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <!-- Root class of the inheritance hierarchy. -->
                            <!-- Note that it is abstract because it does not define subclassSelectorValue -->
                            <class name="WorkItem" subclassSelectorField="Type">
                                <table name="TPH_WorkItem">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Type" type="Integer" />
                                    <field name="AssignedTo" type="Integer" />
                                    <field name="AssignedDate" type="DateTime" />
                                    <field name="DueDate" type="DateTime" />
                                </table>
                            </class>

                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=1 -->
                            <class name="QuestionWorkItem" subclassSelectorValue="1">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Question" dbcolumn="QWI_Question" type="String" size="40" />
                                    <field name="Answer" dbcolumn="QWI_Answer" type="String" size="40" />
                                </table>
                            </class>
                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=2 -->
                            <class name="AnalysisWorkItem" subclassSelectorValue="2">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Subject" dbcolumn="AWI_Subject" type="String" size="40" />
                                </table>
                            </class>

                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=3 -->
                            <class name="BugWorkItem" subclassSelectorValue="3">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="BugID" dbcolumn="BWI_BugID" type="Integer" />
                                    <field name="BugDescription" dbcolumn="BWI_BugDescription" type="String" size="40" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemaprecommitvalues">
            <title>Precommit Values</title>
            <body>
                <p>
                    There are situations where Sooda needs to temporarily store an object in a database.
                    This is called <i>precommit</i> and is described <sectionlink id="precommit" />.
                </p>
                <p>
                    Typically Sooda objects can be stored in a database without problems.
                    One notable exception are not-nullable fields which are null because there were not initialized yet.
                </p>
                <p>
                    In new Sooda objects, not-nullable fields of simple types are initialized with "zero" values:
                </p>
                <div class="table">
                    <table>
                        <thead>
                            <tr>
                                <th>Data Type</th>
                                <th>"Zero" Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td valign="top">Integer</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Long</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Boolean</td>
                                <td valign="top">false</td>
                            </tr>
                            <tr>
                                <td valign="top">BooleanAsInteger</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Decimal</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">Float</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">Double</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">DateTime</td>
                                <td valign="top">00:00:00.0000000, January 1, 0001 (DateTime.MinValue)</td>
                            </tr>
                            <tr>
                                <td valign="top">String</td>
                                <td valign="top">(empty string)</td>
                            </tr>
                            <tr>
                                <td valign="top">AnsiString</td>
                                <td valign="top">(empty string)</td>
                            </tr>
                            <tr>
                                <td valign="top">Blob</td>
                                <td valign="top">(zero-length blob)</td>
                            </tr>
                            <tr>
                                <td valign="top">Guid</td>
                                <td valign="top">00000001-0000-0000-0000-000000000000</td>
                            </tr>
                            <tr>
                                <td valign="top">TimeSpan</td>
                                <td valign="top">00:00:00</td>
                            </tr>
                            <tr>
                                <td valign="top">Image</td>
                                <td valign="top">(zero-length blob)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Note that not-nullable string fields are initialized with an empty string instead of a null.
                </p>
                <p>
                    Not-nullable reference fields cannot be initialized and pose a problem to temporarily
                    storing an object in a database.
                    Historically Sooda includes highly-configurable solution to this problem called <i>precommit values</i>.
                    At the schema level you can choose one of the strategies:
                </p>
                <ul>
                    <li>
                        <x><defaultPrecommitValues>true</defaultPrecommitValues></x> is the default and means to use
                        "zero" precommit values for foreign keys, as specified in the table above.
                    </li>
                    <li>
                        <x><defaultPrecommitValues>false</defaultPrecommitValues></x> makes Sooda throw an exception
                        should there be precommit without a precommit value specified otherwise.
                    </li>
                    <li>
                        <x><defaultPrecommitValues>null</defaultPrecommitValues></x> is a new mechanism that makes Sooda
                        simply insert nulls on precommit. This however requires the database fields to be nullable.
                    </li>
                </ul>
                <p>
                    <x><defaultPrecommitValues>null</defaultPrecommitValues></x> is recommended because of its simplicity.
                    Below we describe the whole mechanism of configuring precommit values.
                </p>
                <p>
                    There are four levels of precommit values, listed in the order of precedence:
                </p>
                <ol>
                    <li><b>per-field precommit value</b> - to be used for a particular field</li>
                    <li><b>per-class precommit value</b> - used for fields that reference to this class</li>
                    <li><b>per-datatype precommit value</b> - you can decide the value for each data type. For example you 
                        may want to store -1 for all not-null integer fields or 2000-01-01 00:00:00 for all DateTime fields</li>
                    <li><b>per-schema precommit strategy</b> - as described above.</li>
                </ol>
                <p>
                    <b>Per-field precommit values</b> are defined on each <x><field /></x> using precommitValue attribute. The
                    following example defines a precommitValue for the User.Manager field.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <class name="User" defaultPrecommitValue="-1">
                                <table name="_User">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Name" type="String" size="40" />
                                    <field name="Manager" type="Integer" references="User" precommitValue="1111" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    In order to define <b>per-class precommit value</b>, you use the defaultPrecommitValue attribute on a class.
                    Typically you use this feature when your database uses foreign key constraints and defaultPrecommitValue
                    is a value of an object that is known to exist in the table.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <class name="User" defaultPrecommitValue="-1">
                                <table />
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    You can use <x><precommitValue /></x> elements in your schema to define <b>per-datatype precommit value</b>. This example
                    defines a precommit value of -1 for Integer fields, <i>***NONE***</i> string for all String fields and <i>***NOTHING***</i>
                    for all AnsiString fields. You should pick a value that you do not commonly search for in your queries.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <precommitValue type="Integer" value="-1" />
                            <precommitValue type="String" value="***NONE***" />
                            <precommitValue type="AnsiString" value="***NOTHING***" />
                        </schema>
                    ]]>
                </code>
            </body>
        </section>
    </section>
    <section id="compilation">
        <title>Compilation</title>
        <section id="compilationprocess">
            <title>Compilation Process</title>
            <body>
                <p>
                    Sooda provides a utility called <a href="#soodastubgen">SoodaStubGen</a> that generates stub source code for 
                    the Data Access Layer. The generated source code needs to be compiled with a standard C#/VB compiler to 
                    produce a working assembly. This section describes the compilation process in detail.
                </p>
                <p>
                    It is recommended to run SoodaStubGen as part of your (preferably fully automated and repeatable) build process so Sooda supports 
                    calling stub generator from a batch file, NAnt script or Visual Studio 2005/2008/2010 solution.
                </p>
                <p>
                    Sooda supports two compilation modes:
                </p>
                <ul>
                    <li><a href="#compilationprocessstandard">Standard Stub Compilation</a> - stubs and business classes are compiled together in a single compiler pass. 
                        This should be compatible with most languages and compilers, but can be slow for really large schemas (which generate huge stub classes). This mode also
                        causes Visual Studio to slow down.
                    </li>
                    <li><a href="#compilationprocessseparate">Separate Stub Compilation</a> - enables stubs to be precompiled to a separate *.dll,
                        which speeds up large builds but has some drawbacks which are described below.</li>
                </ul>
                <p>
                    Separate compilation of stubs is difficult because of cyclic dependency between stub classes and skeleton
                    classes, which exists because:
                </p>

                <ul>
                    <li>skeleton classes must <b>inherit</b> from stub classes</li>
                    <li>stub classes must <b>return references</b> to skeleton classes.</li>
                </ul>

                <p>
                    The following figure describes the problem. Note how Book_Stub class must be able to return references
                    to Person class and Person_Stub must be able to return Book objects. At the same time Book inherits
                    from Book_Stub and Person inherits from Person_Stub:
                </p>
                <img src="doc14.png" alt="Cyclic dependency between stubs and skeleton classes" />

                <p style="color: red">
                    <b>CAUTION</b> Separate Stub Compilation relies on the ability of C# compiler to compile DLLs which
                    reference each other (cyclic dependencies). SoodaCompileStubs is used to ensure the proper bootstrapping
                    of such inter-dependent DLLs. Microsoft C# compiler is supported
                    but Mono Project Compiler (mcs) is not because it is unable to properly handle cyclic references.
                </p>
            </body>
            <section id="compilationprocessstandard">
                <title>Standard Stub Compilation</title>
                <body>
                    <p>
                        Standard Stub Compilation is a process of building Sooda-based data access library, which uses two utilities:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> which generates stub source code</li>
                        <li>C#/VB Compiler which compiles stub and application code together</li>
                    </ol>
                    <p>
                        The following figure provides an overview of the standard stub compilation process:
                    </p>
                    <img src="doc12.png" alt="Standard stub compilation" />
                    <p>
                        On input the process requires an XML document with <a href="#schema">O/R Mapping Schema</a>, typically
                        stored in a file named <code>SoodaSchema.xml</code>. Arguments to <a href="#soodastubgen">SoodaStubGen</a> 
                        can be either passed on the command line or through a special <a href="#soodaproject">XML project file</a> which
                        is easier to manage.
                    </p>
                    <p>
                        Build steps to produce business objects assembly are:
                    </p>
                    <ol>
                        <li>SoodaStubGen produces two files:
                            <ul>
                                <li><b>_Stubs.cs</b> (the extension is different for other languages) - stub source file</li>
                                <li><b>_DBSchema.bin</b> - resources file</li>
                            </ul>
                            It also generates one "skeleton" file for each <a href="#schemaclasses">class</a> defined in schema.
                            The files are named <code>ClassName.cs</code> where ClassName is the name of the class.
                            <b>The skeleton is only generated in the first run and is never automatically regenerated</b>
                            You can add your own properties and business methods in the skeleton and your changes will be preserved
                            when rebuilding project. "Skeleton" inherits from a "stub" class so you get access to all its
                            properties and methods.
                        </li>
                        <li>
                            Compiler (such as csc.exe for C# or vbc.exe for Visual Basic.NET) compiles the skeleton and stub files
                            together to produce business objects assembly (*.dll).
                        </li>
                    </ol>
                </body>
            </section>
            <section id="compilationprocessseparate">
                <title>Separate Stub Compilation</title>
                <body>
                    <p>
                        Separate Stub Compilation is a process in which you precompile stubs to a separate DLL and
                        rebuild the DLL only when the schema changes. This can save compile time for very large schemas
                        and can also make Visual Studio run faster (for some reason Visual Studio 2005 does not perform very
                        well on very large source files which SoodaStubGen creates).
                    </p>

                    <p>
                        The following utilities are required:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> which generates stub source code and source files necessary
                        to generate mini-stubs and full stubs.</li>
                    <li><a href="#soodacompilestubs">SoodaCompileStubs</a> which precompiles stubs to a DLL.</li>
                        <li>C#/VB Compiler which compiles application code referencing the precompiled stub DLL.</li>
                    </ol>
                    <p>
                        The following figure provides an overview of the separate stub compilation process:
                    </p>
                    <img src="doc13.png" alt="Separate stub compilation" />
                    <p>
                        The steps of the separate stub compilation are:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> generates stub source code for: stubs, mini-stubs and mini-skeletons as described <sectionlink id="compilationprocessfiles" />.</li>
                        <li><a href="#soodacompilestubs">SoodaCompileStubs</a> is invoked to bootstrap the stubs library. This process consists of the following steps:
                            <ol type="a">
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.Stubs.dll</code> from <code>_MiniStubs.csx</code>. 
                                    The DLL references Sooda.dll only.</li>
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.dll</code> from <code>_MiniSkeleton.csx</code> referencing
                                    <code>OutputAssemblyName.Stubs.dll</code> built in the previous step.</li>
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.Stubs.dll</code> from <code>_Stubs.csx</code> replacing
                                    the DLL built in the first step. The newly compiled DLL references <code>OutputAssemblyName.dll</code> built in the
                                    second step.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </body>
            </section>
            <section id="compilationprocessfiles">
                <title>Files used during the compilation process</title>
                <body>
                    <p>
                        The following files are created or used during the compilation process:
                    </p>
                    <div class="table">
                        <table>
                            <col />
                            <col width="70pt" align="center" />
                            <col width="70pt" align="center" />
                            <col width="70pt" align="center" />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Location</th>
                                    <th>Provided by user</th>
                                    <th>Generated</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>SoodaSchema.xml</td>
                                    <td>any</td>
                                    <td>Yes</td>
                                    <td>Yes/No</td>
                                    <td>Defines <a href="#schema">mapping schema</a>. Can be written by hand or 
                                        reverse-engineered from an existing database with the <a href="#soodaschematool">SoodaSchemaTool utility</a>.</td>
                                </tr>
                                <tr>
                                    <td>ProjectName.soodaproject</td>
                                    <td>any</td>
                                    <td>Yes</td>
                                    <td>No</td>
                                    <td>Defines code generation parameters. 
                                        The format of this file is described <sectionlink id="soodaproject" />.
                                        You may choose to not use this file, but pass all code generation parameters as command line arguments
                                        to <a href="#soodastubgen">SoodaStubGen utility</a> instead.</td>
                                </tr>
                                <tr>
                                    <td>_DBSchema.bin</td>
                                    <td>output directory</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        Binary version of SoodaSchema.xml. 
                                        Enables access to schema-level metadata at runtime. Must be embedded into the assembly that
                                        contains business objects. Optimized for fast loading and small size by using binary serialization.
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.cs</td>
                                    <td>output directory</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            Generated code for stub classes, list wrappers, factories and other opaque types that 
                                            should be compiled together to build a Data Access Layer. 
                                            More information about the generated code is available 
                                            in the <a href="#generatedcode">Generated Code section</a>.
                                        </p>
                                        <p>
                                            The exact extension of this file matches the selected language and is cs for C# and vb for VB.NET. 
                                            Other CodeDOM providers have their specific extensions.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>ClassName.cs</td>
                                    <td>output directory</td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            Skeleton classes. They are generated by <a href="#soodastubgen">SoodaStubGen</a> 
                                            the first time it is executed and are not regenerated later.
                                        </p>
                                        <p>
                                            You can put your business methods in these files. There is one skeleton class for 
                                            each <x><class /></x> as defined in the <a href="#schema">mapping schema</a>.
                                            Each class N is stored in a file named "output directory/N.cs" (for C#) 
                                            and this cannot be changed by the user.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Generated code for stub classes, list wrappers, factories and other opaque types that 
                                            should be compiled together to build a Data Access Layer stubs library.  
                                            More information about the generated code is available 
                                            in the <a href="#generatedcode">Generated Code section</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_MiniStubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Miniature version of generated code for stub classes, list wrappers, factories.
                                            Miniature stub classes do not rely on skeleton classes so they can be compiled separately 
                                            during the <a href="#compilationprocessseparate">separate compilation bootstrap procedure</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_MiniSkeleton.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Miniature version of skeleton classes. The skeleton classes have no code other than
                                            constructors and they inherit from the appropriate stub classes. This is a temporary file
                                            and is used
                                            during the <a href="#compilationprocessseparate">separate compilation bootstrap procedure</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Same as _Stubs.cs, but located in _Stubs.csx. This file is compiled to create the stubs
                                            assembly.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>OutputAssemblyName.Stubs.dll</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            The resulting stubs assembly. You should reference this file each time you reference
                                            OutputAssemblyName.dll.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>OutputAssemblyName.dll</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                           Mini-skeletons assembly. Should not be removed or your application will not build properly.
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
            <section id="compilationprocessnant">
                <title>NAnt</title>
                <body>
                    <p>
                        Sooda supports NAnt tasks that can be used to automate the build process. They are contained in
                        the Sooda.NAnt.Tasks library and must be loaded before they can be used:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <loadtasks assembly="${sooda.dir}/Sooda.NAnt.Tasks.dll" />
                        </project>
                        ]]>
                    </code>
                    <p>
                        <x><sooda-generate-code /></x> task is an equivalent of the <a href="#soodastubgen">SoodaStubGen utility</a>.
                        Usage:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <loadtasks assembly="${sooda.dir}/Sooda.NAnt.Tasks.dll" />
                            <sooda-generate-code project="path/to/proj.soodaproject" />
                        </project>
                        ]]>
                    </code>
                    <p>
                        This is equivalent to calling SoodaStubGen with the name of the <a href="#soodaproject">soodaproject</a> file as an argument:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <exec program="${sooda.dir}/SoodaStubGen.exe" commandline="path/to/proj.soodaproject" />
                        </project>
                        ]]>
                    </code>
                    <p>
                        Once you have generated the stubs you should compile the skeleton classes, stub classes and embedded resources
                        into a DLL. <x><csc /></x> task should be used for that. The following example is taken from Sooda
                        unit tests:
                    </p> 
                    <code lang="XML">
                        <![CDATA[
                        <csc target="library" output="${sooda.dir}/Sooda.UnitTests.BaseObjects.dll" debug="true">
                            <references>                                  
                                <include name="${sooda.dir}/Sooda.dll" />
                                <include name="System.Data.dll" asis="true" />
                            </references>
                            <sources basedir="tests/BaseObjects">
                                <include name="*.cs" />
                            </sources>
                            <resources basedir="tests/BaseObjects" prefix="Sooda.UnitTests.BaseObjects" dynamicprefix="true">
                                <include name="_DBSchema.*" />
                            </resources>
                        </csc>
                        ]]>
                    </code>
                </body>
            </section>
            <section id="compilationvisualstudio">
                <title>Visual Studio</title>
                <body>
                    <p>
                        Automating Visual Studio builds using Sooda relies on the <code>Pre-Build Event</code> setting which invokes
                        <a href="#soodastubgen">SoodaStubGen.exe</a> and optionally <a href="#soodacompilestubs">SoodaCompileStubs.exe</a>.
                        It is possible to pass arbitrary command-line arguments to these commands, but it is recommended to use 
                        <a href="#soodaproject">Sooda Project Files</a> which make this process a simpler to manage.
                    </p>
                    <p>
                        To set the Pre-Build Event command line, open project properties in Visual Studio and locate "<code>Build Events</code>".
                        Recommended Pre-Build Event command line is (for .NET 2.0 / Visual Studio 2005)
                    </p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-2.0\SoodaStubGen.exe" "$(ProjectName).soodaproject"
                    </code>
                    <p>
                        SOODA_DIR environment variable must be set properly (it is automatically initialized by the installer). You may want to adjust
                        the path if you installed Sooda manually in some other location.
                    </p>
                    <p>
                        To call <a href="#soodacompilestubs">SoodaCompileStubs</a> from within Visual Studio, add the appropriate code:
                    </p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-2.0\SoodaCompileStubs.exe" $(ProjectName) "$(ProjectDir)Stubs" "$(ProjectDir)AssemblyInfo.cs"
                    </code>
                </body>
            </section>
        </section>
        <section id="soodaproject">
            <title>Sooda Project Files - *.soodaproject</title>
            <body>
                <p>
                    Sooda Project Files are used to control the generation of stub source code with the <a href="#soodastubgen">SoodaStubGen utility</a>. 
                    Project files are easier to read and maintain than command-line arguments passed to SoodaStubGen.
                    Visual Studio supports Intellisense so editing them is easy, even without documentation.
                </p>
                <p>
                    Sooda Project file must be saved in a file with <code>*.soodaproject</code> extension.
                    It is an XML file, whose root element is <x><sooda-project /></x> and its
                    XML Namespace is <code>http://www.sooda.org/schemas/SoodaProject.xsd</code>
                </p>
                <code lang="XML">
                    <![CDATA[
                    <sooda-project xmlns="http://www.sooda.org/schemas/SoodaProject.xsd">
                        <!-- parameters go here -->
                    </sooda-project>                
                    ]]>
                </code>
                <p>
                    The following table describes elements which can be used in Sooda Project files:
                </p>
                <div class="table">
                    <table style="table-layout: fixed; width: 100%">
                        <col style="font-family: Consolas, Courier New; width: 4cm" />
                        <col style="font-family: Consolas, Courier New; width: 2cm" />
                        <col />
                        <thead>
                            <tr>
                                <th>XML Element</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>schema-file</td>
                                <td>string</td>
                                <td>Path to the file that defines the <a href="#schema">mapping schema</a>.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><schema-file>MySoodaSchema.xml</schema-file></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>language</td>
                                <td>string</td>
                                <td>Specifies the programming language. Possible (case insensitive) values are:
                                    <ul>
                                        <li><b>CS, C#, CSharp</b></li>
                                        <li><b>VB, VB.NET</b></li>
                                        <li><b>C++/CLI</b></li>
                                        <li><b>MC++</b> - Managed C++</li>
                                        <li>alternatively you can provide a fully qualified class name (including assembly, primary key token) 
                                            of the CodeDOM provider.
                                        </li>
                                    </ul>
                                    <p>
                                        The default is <b>C#</b>.
                                    </p>
                                    <p>
                                        Examples:
                                    </p>
                                    <p>C#:</p>
                                    <pre class="XML">
                                        <x><language>c#</language></x>
                                    </pre>
                                    <p>VB.NET:</p>
                                    <pre class="XML">
                                        <x><language>vb</language></x>
                                    </pre>
                                    <p>Boo:</p>
                                    <pre class="XML">
                                        <x><language>Boo.Lang.CodeDom.BooCodeProvider, Boo.Lang.CodeDom</language></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-assembly</td>
                                <td>string</td>
                                <td>Name of the output assembly without the DLL extension.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-assembly>MyAssembly</output-assembly></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-namespace</td>
                                <td>string</td>
                                <td>Name of the output namespace.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-namespace>MyNamespace</output-namespace></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-path</td>
                                <td>string</td>
                                <td>Output path. By default it is "." which represents current working directory.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-path>src\MyBusinessObjects</output-path></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>nullable-representation<br/>not-null-representation</td>
                                <td>string</td>
                                <td>Specifies how nullable and not-nullable fields are mapped to properties.
                                    Possible methods are discussed <sectionlink id="soodaprojectprimitiverep" />.
                                    <p>
                                        Default value for nullable representation is <b>SqlType</b> and 
                                        default not-null representation is <b>Raw</b>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                    <x><nullable-representation>Boxed</nullable-representation></x><br/>
                                    <x><not-null-representation>Raw</not-null-representation></x>
                            </pre></td>
                            </tr>
                            <tr>
                                <td>null-propagation</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Enable null propagation for nullable properties and reference properties:
                                    </p>
                                    <pre class="XML">
                                        <x><null-propagation>true</null-propagation></x>
                                    </pre>
                                    <p>
                                        Enabling this option causes the following prolog code to be emitted for all property
                                        getters:
                                    </p>
                                    <code lang="C#">
                                        if (this == null)
                                            return null;
                                    </code>
                                    <p>
                                        Without this feature we would get a <code>NullReferenceException</code> when traversing a path
                                        expression where one of the non-trailing elements is null. Consider this code:
                                    </p>

                                    <code lang="C#">
                                        OrgUnit o = this.OrganizationUnit.Parent.Parent.Parent;
                                    </code>

                                    <p>
                                        Assuming that <code>this.OrganizationUnit.Parent == null</code>, this code will throw a 
                                        <code>NullReferenceException</code> when built without null propagation. When null propagation
                                        is enabled, however, it will assign <code>null</code> to <code>o</code> without throwing an exception.
                                    </p>
                                    <p>
                                        This feature is experimental and should be used with caution.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>loader-class</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Generate Load(), GetRef(), GetList(), FindByXXX() and FindListByXXX() static methods in a separate class called ClassNameLoader instead
                                        of ClassName.
                                    </p>
                                    <pre class="XML">
                                        <x><loader-class>true</loader-class></x>
                                    </pre>
                                    <p>
                                        Some languages such as VJ# do not properly support inherited classes having the
                                        same public static method with different return type (which would be needed to support inheritance
                                        in Sooda). To remedy this problem, this option causes the methods to be moved to a separate class.
                                    </p>
                                    <p>
                                        When <x><loader-class /></x> is set to <code>false</code>, you can use the following methods to load objects:
                                    </p>
                                    <code lang="C#">
                                        Contact.Load(10);
                                        Contact.GetRef(10);
                                        Contact.TryGet(10);
                                        Contact.GetList(whereClause);
                                        Contact.LoadSingleObject(whereClause);
                                    </code>
                                    <p>
                                        When <x><loader-class /></x> is set to <code>true</code>, you can use the following methods to load objects:
                                    </p>
                                    <code lang="C#">
                                        ContactLoader.Load(10);
                                        ContactLoader.GetRef(10);
                                        ContactLoader.TryGet(10);
                                        ContactLoader.GetList(whereClause);
                                        ContactLoader.LoadSingleObject(whereClause);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>with-typed-queries</td>
                                <td>boolean</td>
                                <td>
                                    <p>This option causes the <a href="#soodastubgen">SoodaStubGen utility</a> to 
                                        emit <a href="#soqltypedqueries">SQOL typed queries</a>. By default it is <code>true</code>, you
                                        can disable typed queries if you plan to use <a href="#soqltext">text-based queries</a> exclusively.
                                    </p>
                                    <pre class="XML">
                                        <x><with-typed-queries>true</with-typed-queries></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>stubs-compiled-separately</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Enables <a href="#compilationprocessseparate">separate compilation of stubs</a>.
                                    </p>
                                    <pre class="XML">
                                        <x><stubs-compiled-separately>true</stubs-compiled-separately></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>file-per-namespace</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Write each namespace to a separate file:
                                    </p>
                                    <ul>
                                        <li><code>_Stubs.cs</code> - assembly-level attributes</li>
                                        <li><code>_Stubs.OutputNamespace.cs</code> - list wrappers and class loaders</li>
                                        <li><code>_Stubs.OutputNamespace.Stubs.cs</code> - stubs, factories, private typed query expression classes</li>
                                        <li><code>_Stubs.OutputNamespace.TypedQueries</code> - public typed query expression classes</li>
                                    </ul>
                                    <p>
                                        When this option is set to false, all files are written to <code>_Stubs.cs</code>.
                                    </p>
                                    <pre class="XML">
                                        <x><file-per-namespace>true</file-per-namespace></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>base-class-name</td>
                                <td>string</td>
                                <td>
                                    <p>
                                        Specifies the name of the class that all stubs should ultimately derive from. If you do not specify
                                        this parameter, all root stubs classes will derive from the SoodaObject class.
                                    </p>
                                    <pre class="XML">
                                        <x><base-class-name>AdditionalBaseClass</base-class-name></x>
                                    </pre>
                                    <p>
                                        More ways to override base classes are discussed <sectionlink id="generatedclasshierarchy" />.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>embed-schema
                                    type</td>
                                <td>Xml|Binary</td>
                                <td>
                                    <p>Specifies the method of embedding schema in the result DLL. Can be either <code>Xml</code> or <code>Binary</code>.
                                        <code>Binary</code> causes the schema to be serialized in binary format, while <code>Xml</code> stores the schema in the XML format.
                                        You should use <code>Binary</code> (which is the default), because it gives better startup times and smaller file sizes, but if you need to perform some 
                                        text-level parsing of the XML, you can choose <code>Xml</code>.
                                    </p>
                                    <pre class="XML">
                                        <x><embed-schema>Binary</embed-schema></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>external-projects</td>
                                <td>array</td>
                                <td>
                                    <p>
                                        Defines external projects (such as Visual Studio projects) that need to be updated each time a new class is added to the schema. 
                                        Each project is represented by <x><project type="..." file="..." /></x>. 
                                        The following example XML defines a Visual Studio 2005 project: 
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <external-projects>
                                            <project type="vs2005" file="MyProject.vs2005.csproj" />
                                        </external-projects>
                                        ]]>
                                    </code>
                                    <p>
                                        The paths are relative to the output directory. The following project types are available:
                                    </p>
                                    <ul>
                                        <li><b>vs2005</b> - Visual Studio 2005</li>
                                        <li><b>null</b> - no project file</li>
                                    </ul>
                                    <p>
                                        Note that files (such as source files and embedded resources) can only be added to projects, they
                                        are not removed automatically. If you remove a class from the <a href="#schema">mapping schema</a>, 
                                        you need to manually remove the appropriate file from your project.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
            <section id="soodaprojectprimitiverep">
                <title>Primitive Representations</title>
                <body>
                    The following values are for <code>nullable-representation</code> and <code>not-null-representation</code>:
                    <div class="table">
                        <table style="table-layout: fixed; width: 100%">
                            <col style="font-family: Consolas, Courier New; width: 3cm" />
                            <col />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Boxed</td>
                                    <td>Use boxing to represent nullable values. Null value is represented 
                                        as <code>null</code> reference, but a cast is required to get to get the value. 
                                        This representation is not recommended because of the lack of the type safety.

                                        <code lang="C#">
                                            // test for null
                                            if (x.Field1 != null)
                                            {
                                                // retrieve non-null value
                                                int v = (int)x.Field1;

                                                // WARNING - no type checking at compilation time occurs
                                                // so the following will compile, but will fail at runtime:
                                                bool b = (bool)x.Field1;

                                                // set to null
                                                x.Field1 = null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Raw</td>
                                    <td>Represent nullable fields as properties of primitive types (int,bool,DateTime) 
                                        completely ignoring their null value. This is suitable for not-null fields, 
                                        but may be a bad idea for nullable fields.

                                        <code lang="C#">
                                            // retrieve non-null value
                                            int v = (int)x.Field1;

                                            // set to not null
                                            x.Field1 = 42;
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>RawWithIsNull</td>
                                    <td>Represent nullable fields as a pair of properties - one is of primitive 
                                        type and returns the value of the field, the other called <b>FieldName_IsNull</b> returns the 
                                        null flag for the field.

                                        <code lang="C#">
                                            // test for null
                                            if (!x.Field1_IsNull)
                                            {
                                                // retrieve non-null value
                                                int v = x.Field1;

                                                // set to null
                                                x._SetNull_Field1();

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>SqlType</td>
                                    <td>
                                        Represent nullable fields as the corresponding SqlTypes (value types from the System.Data.SqlTypes namespace).
                                        The following SqlTypes are available:
                                        <ul>
                                            <li>SqlInt32</li>
                                            <li>SqlInt64</li>
                                            <li>SqlBoolean</li>
                                            <li>SqlDateTime</li>
                                            <li>SqlDecimal</li>
                                            <li>SqlSingle</li>
                                            <li>SqlDouble</li>
                                            <li>SqlBinary</li>
                                            <li>SqlGuid</li>
                                        </ul>

                                        <code lang="C#">
                                            // test for null
                                            if (!x.Field1.IsNull)
                                            {
                                                // retrieve non-null value
                                                int v = x.Field1.Value;

                                                // set to null
                                                x.Field1 = SqlInt32.Null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Nullable</td>
                                    <td>
                                        <p>
                                            Use <code>Nullable&lt;T&gt;</code> types.
                                            The following nullable types are supported:
                                        </p>
                                        <ul>
                                            <li>Nullable&lt;int&gt; - int?</li>
                                            <li>Nullable&lt;long&gt; - long?</li>
                                            <li>Nullable&lt;bool&gt; - bool?</li>
                                            <li>Nullable&lt;DateTime&gt; - DateTime?</li>
                                            <li>Nullable&lt;decimal&gt; - decimal?</li>
                                            <li>Nullable&lt;float&gt; - float?</li>
                                            <li>Nullable&lt;double&gt; - double?</li>
                                            <li>Nullable&lt;Guid&gt; - Guid?</li>
                                        </ul>
                                        <code lang="C#">
                                            // test for null
                                            if (x.Field1 != null)
                                            {
                                                // retrieve non-null value, no other casts are allowed here
                                                int v = (int)x.Field1;

                                                // set to null
                                                x.Field1 = null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
        </section>
    </section>
    <section id="runtimeconfiguration">
        <title>Runtime configuration</title>
        <body>
            <p>
                Some aspects of Sooda-generated Data Access Library can be controlled at runtime. They are:
            </p>
            <ul>
                <li>Data Source configuration - such as connection string, connection type, SQL dialect and more - described <sectionlink id="configuringdatasources" />.</li>
                <li>Caching - described <sectionlink id="cachingapi" />.</li>
                <li>Logging - described <sectionlink id="logging" />.</li>
            </ul>
            <p>
                Configuration parameters are typically stored in <a href="#configuration">configuration files</a>, 
                but there are other possibilities as explained later in this section.
            </p>
        </body>
        <section id="configuration">
            <title>Configuration Files</title>
            <body>
                <p>
                    Sooda configuration files are usually managed by the .NET configuration mechanism and the parameters
                    are stored in application configuration files (<code>App.config</code>) as described <sectionlink id="configurationappconfig" />.
                    If you have many programs that share runtime configuration, Sooda can be configured from a
                    shared XML configuration file. This feature is described <sectionlink id="configurationxml" />.
                    If you have developed your own configuration mechanism, you can write a specialized Sooda 
                    configuration provider for it as described <sectionlink id="configurationcustom" />.
                </p>
            </body>
            <section id="configurationappconfig">
                <title>App.config - style configuration</title>
                <body>
                    <p>
                        By default Sooda configuration parameters are stored in standard .NET configuration files named
                        <code>ApplicationName.exe.config</code> or <code>Web.config</code> in a section named <x><appSettings /></x>. 
                        More information about .NET Configuration files is available in <a href="http://msdn.microsoft.com/en-us/library/1fk1t1t0.aspx">MSDN Library</a>.
                    </p>
                    <p>
                        Each data source configuration entry has a form:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <add name="dataSourceName.parameterName" value="parameterValue" />
                        ]]>
                    </code>
                    <p>
                        <code>dataSourceName</code> is the name of the datasource (usually "<code>default</code>") and <code>parameterName</code> 
                        is the name of the setting for that datasource. The value of the setting is stored in <code>parameterName</code>.
                        Possible setting names are described <sectionlink id="configuringdatasources" />.
                    </p>
                    <p>
                        Some global options can also be set this way. Global options use the "<code>sooda</code>" prefix instead of a data source name.
                        They are described <sectionlink id="configurationglobal" />.
                    </p>
                    <p>
                        The following configuration file defines two settings for the "default" data source: <code>connectionString</code> and <code>sqlDialect</code>.
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <configuration>
                            <appSettings>
                                <add key="default.connectionString" value="Integrated Security=true;Server=.;Database=MyDatabase" />
                                <add key="default.sqlDialect" value="mssql" />
                            </appSettings>
                        </configuration>
                        ]]>
                    </code>
                </body>
            </section>
            <section id="configurationxml">
                <title>Shared XML configuration</title>
                <body>
                    <p>
                        There are situations where multiple applications need to share the same set of configuration parameters.
                        Instead of keeping multiple copies of Sooda-specific configuration, you can store the settings in
                        a single XML file which is read by the applications.
                    </p>
                    <p>
                        The format of the file is very simple. Each parameter is enclosed in an XML element and nesting is used to
                        group parameters for a single datasource. The root element of the configuration file is not important,
                        which means you can embed the Sooda-specific XML elements in any XML file as long as you can
                        add your own elements.
                    </p>
                    <p>
                        The following example demonstrates XML configuration file equivalent to the App.config 
                        shown above.
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <configuration>
                            <default>
                                <connectionString>Integrated Security=true;Server=.;Database=MyDatabase</connectionString>
                                <sqlDialect>mssql</sqlDialect>
                            </default>
                        </configuration>
                        ]]>
                    </code>
                    <p>
                        XML config files also support per-host overrides. Assuming the configuration file is 
                        read from <code>sooda.config.xml</code>, Sooda looks for <code>sooda.config.HOSTNAME.xml</code> 
                        where <code>HOSTNAME</code> is the name of the machine the application is running on. If the 
                        host-specific configuration file is found, Sooda reads it as well and any settings specified in this
                        file take precedence over the common configuration.
                    </p>
                    <p>
                        Sooda looks for an XML configuration file in the application base directory. If the file is not found
                        the parent directory is scanned, then its grandparent and so on until the file is found or until
                        ten levels of directory hierarchy have been scanned or the root directory has been reached. 
                        Assuming that your application is stored in <code>c:\myprojects\mysystem1\app1\bin\Debug\app.exe</code>
                        and the name of the configuration file is: <code>sooda.config.xml</code>, 
                        and Sooda will look for it in the following locations:
                    </p>
                    <ol>
                        <li>c:\myprojects\mysystem1\app1\bin\Debug\sooda.config.xml</li>
                        <li>c:\myprojects\mysystem1\app1\bin\sooda.config.xml</li>
                        <li>c:\myprojects\mysystem1\app1\sooda.config.xml</li>
                        <li>c:\myprojects\mysystem1\sooda.config.xml</li>
                        <li>c:\myprojects\sooda.config.xml</li>
                        <li>c:\sooda.config.xml</li>
                    </ol>
                    <p>
                        As you can see, this is convenient because you can keep the settings for all applications making up
                        entire system in a single file (<code>c:\myprojects\mysystem1\sooda.config.xml</code>) and
                        all applications will be able to read it.
                    </p>
                    <p>
                        To use XML configuration files, add this line of code to the <code>AssemblyInfo.cs</code>
                        file of your <a href="http://msdn2.microsoft.com/en-us/library/system.reflection.assembly.getentryassembly.aspx">entry assembly</a>.
                    </p>
                    <code lang="C#">
                        using Sooda;

                        [assembly: SoodaConfig(XmlConfigFileName="sooda.config.xml")]
                    </code>
                    <p>
                        Alternatively you can add these two entries in the application configuration file:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <configuration>
                            <appSettings>
                                <add key="sooda.config" value="xmlconfig" />
                                <add key="sooda.xmlconfigfile" value="sooda.config.xml" />
                            </appSettings>
                        </configuration>
                        ]]>
                    </code>
                    <p>
                        By default the HOSTNAME part of the file name is the name of the machine as returned by <code>Environment.MachineName</code>, but you can add the <code>sooda.hostname</code> 
                        application configuration setting to override it:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <configuration>
                            <appSettings>
                                <add key="sooda.hostname" value="ALTERNATIVEHOSTNAME" />
                            </appSettings>
                        </configuration>
                        ]]>
                    </code>
                </body>
            </section>
            <section id="configurationcustom">
                <title>Custom configuration</title>
                <body>
                    <p>
                        If you have developed your own configuration mechanism, you can get Sooda to use it by creating a class
                        that implements the <code>Sooda.Config.ISoodaConfigProvider</code> interface and telling Sooda to use it.
                        The interface has only one method: <code>string GetString(string)</code> which must read a configuration
                        setting with the specified name. The setting name is of the form <code>dataSourceName.parameterName</code>.
                    </p>
                    <p>
                        To register your configuration provider in a declarative manner, you can either use an assembly-level attribute 
                        or an application configuration file entry. Assuming you have created a class <code>MyProvider</code> 
                        that implements <code>ISoodaConfigProvider</code>
                        interface, just add the following code to your <code>AssemblyInfo.cs</code>:
                    </p>
                    <code lang="C#">
                        using Sooda;

                        [assembly: SoodaConfig(ProviderType=typeof(MyNamespace.MyProvider))]
                    </code>
                    <p>
                        If you prefer to use the application configuration file, add the <code>sooda.config</code> entry containing
                        the fully qualified name of the type (including assembly name, version and public key token).
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <configuration>
                            <appSettings>
                                <add key="sooda.config" value="MyNamespace.MyProvider, MyAssembly, Version=..., PublicKeyToken=..." />
                            </appSettings>
                        </configuration>
                        ]]>
                    </code>
                    <p>
                        To register the config provider programmatically, just call <code>SoodaConfig.SetConfigProvider()</code> 
                        in your <code>Main()</code> method:
                    </p>
                    <code lang="C#">
                        using Sooda;
                        using Sooda.Config;

                        class Program
                        {
                            public static void Main(string[] args)
                            {
                                // create the config provider object
                                ISoodaConfigProvider provider = new MyNamespace.MyProvider();

                                // make it active
                                SoodaConfig.SetConfigProvider(provider);
                            }
                        }
                    </code>
                </body>
            </section>
        </section>
        <section id="configuringdatasources">
            <title>Data Source Configuration</title>
            <body>
                <p>
                    You can configure your data source either declaratively using the <a href="#configuration">configuration file</a>
                    or in code by properties of the <code>SqlDataSource</code> objects.
                </p>
                <div class="table">
                    <table style="table-layout: fixed">
                        <col style="font-size: 90%; width: 35mm; text-align: center" />
                        <col style="font-size: 90%; width: 35mm; text-align: center" />
                        <thead>
                            <tr>
                                <th>Configuration setting</th>
                                <th>Property</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td align="center" valign="top">sqlDialect</td>
                                <td align="center" valign="top">SqlBuilder</td>
                                <td>
                                    <p>
                                        Controls the database-specific SQL generation. The following values can be specified:
                                    </p>
                                    <ul>
                                        <li><code>mssql</code> - Microsoft SQL Server 2000 and 2005</li>
                                        <li><code>oracle</code> - Oracle 8i and above</li>
                                        <li><code>mysql</code> - MySQL 4.x and above</li>
                                        <li><code>postgresql</code> - PostgreSQL 8.x and above</li>
                                    </ul>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.sqlDialect" value="postgresql" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                    <p>
                                        To change the dialect in code, set the <code>SqlBuilder</code> property to an object 
                                        implementing <code>ISqlBuilder</code>. The following classes are available:
                                    </p>
                                    <ul>
                                        <li><code>SqlServerBuilder</code> - Microsoft SQL Server 2000 and 2005</li>
                                        <li><code>OracleBuilder</code> - Oracle 8i and above</li>
                                        <li><code>MySqlBuilder</code> - MySQL 4.x and above</li>
                                        <li><code>PostgreSqlBuilder</code> - PostgreSQL 8.x and above</li>
                                    </ul>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="C#">
                                        using (SqlDataSource sds = new SqlDataSource("default"))
                                        {
                                            sds.SqlBuilder = new MySqlBuilder();
                                            // change other properties before calling Open()
                                            sds.Open();
                                        }
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">commandTimeout</td>
                                <td align="center" valign="top">CommandTimeout</td>
                                <td>
                                    <p>
                                        Specifies the maximum amount of time (in seconds) that SQL queries are allowed to execute
                                        before they are terminated.
                                    </p>
                                    <p>
                                        The default value of <code>CommandTimeout</code> is 30 seconds. The following example
                                        demonstrates a way to change it to 60 seconds:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.commandTimeout" value="60" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">queryTimeTraceInfo<br/>queryTimeTraceWarn</td>
                                <td align="center" valign="top">QueryTimeTraceInfo<br/>QueryTimeTraceWarn</td>
                                <td>
                                    <p>
                                        Control the SQL trace output depending on query time. If the query execution time is
                                        below <code>QueryTimeTraceInfo</code> (floating point time in seconds), log output is emitted at the lowest possible
                                        level (<code>Trace</code>). If the query execution time is between <code>QueryTimeTraceInfo</code>
                                        and <code>QueryTimeTraceWarn</code>, the query is logged at the <code>Info</code> level. Queries
                                        which take more than <code>QueryTimeTraceWarn</code> seconds to execute are logged at the <code>Warn</code>
                                        level.
                                    </p>
                                    <p>
                                        The default value of <code>QueryTimeTraceWarn</code> is 10 seconds 
                                        and <code>QueryTimeTraceInfo</code> defaults to 2 seconds. 
                                        The following configuration settings set the Info threshold to 0.5 seconds and Warn 
                                        threshold to one second.
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.queryTimeTraceInfo" value="0.5" />
                                                <add key="default.queryTimeTraceWarn" value="1.0" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">disableTransactions</td>
                                <td align="center" valign="top">DisableTransactions</td>
                                <td>
                                    <p>
                                        Disables the use of SQL transactions. Setting this to <code>true</code> is 
                                        possible but <font color="red">NOT RECOMMENDED</font> because <a href="#precommit">precommit operation</a>
                                        may modify the database itself. If the transactions are not used, such modifications cannot be rolled
                                        back in case of any error which may lead to data corruption. The default value is: <code>false</code>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.disableTransactions" value="true" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">stripWhitespaceInLogs</td>
                                <td align="center" valign="top">StripWhitespaceInLogs</td>
                                <td>
                                    <p>
                                        When this parameter is set to <code>true</code>, Sooda logs SQL queries with whitespace stripped which makes them all single-line.
                                        Log messages which have their whitespace stripped are easier to parse with simple utilities such as <code>grep</code> but
                                        are less readable to a human. The default value is: <code>false</code>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.stripWhitespaceInLogs" value="true" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">indentQueries</td>
                                <td align="center" valign="top">IndentQueries</td>
                                <td>
                                    <p>
                                        Specifies whether queries sent to the RDBMS should be indented with 
                                        the whitespace characters to represent their nesting levels.
                                        Setting this to <code>true</code> makes queries more human-readable,
                                        while setting it to <code>false</code> can reduce network traffic
                                        between the SQL server and application host. The default value is: <code>false</code>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.indentQueries" value="true" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">useSafeLiterals</td>
                                <td align="center" valign="top">UseSafeLiterals</td>
                                <td>
                                    <p>
                                        Controls the use of ADO.NET parameters. When this parameter is set to 
                                        <code>false</code> (which is the default), Sooda replaces all literals
                                        (such as numbers, strings, dates) with ADO.NET parameters. When this parameter
                                        is set to <code>true</code>, some literals which are known to be safe
                                        from the <a href="http://en.wikipedia.org/wiki/SQL_Injection">SQL injection</a> standpoint
                                        are not passed as parameters which improves SQL statement readability.
                                    </p>
                                    <p>
                                        The following literals can be passed unmodified:
                                    </p>
                                    <ul>
                                        <li>integer values</li>
                                        <li>string values shorter than 500 characters which consist of latin 
                                            letters A-Z, a-z, digits 0-9, space, dot, comma, hyphen, percent, underscore and at (@) character.</li>
                                    </ul>
                                    <p>
                                        All other literals (especially datetime literals) are always passed as ADO.NET parameters.
                                    </p>
                                    <p>
                                        The following example enables the use of safe literals:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.useSafeLiterals" value="true" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">disableUpdateBatch</td>
                                <td align="center" valign="top">DisableUpdateBatch</td>
                                <td>
                                    <p>
                                        Disables batched updates. If this parameter is set to <code>true</code>
                                        update commands (such as <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) 
                                        cannot be batched and are always executed in separate ADO.NET commands.
                                        The default value for this <code>true</code> except for Microsoft SQL Server where it
                                        is <code>false</code>.
                                    </p>
                                    <p>
                                        When batched updates are enabled, SQL can send multiple semicolon-separated DML instructions.
                                        When you insert five objects in a single transaction, Sooda might persist them in a single 
                                        batch:
                                    </p>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(100,'aaa');
                                        INSERT INTO T1(id,name) values(101,'aaa');
                                        INSERT INTO T1(id,name) values(102,'aaa');
                                        INSERT INTO T1(id,name) values(103,'aaa');
                                        INSERT INTO T1(id,name) values(104,'aaa');
                                    </code>
                                    <p>
                                        When query batching is not enabled, five round trips to the server are required which may
                                        degrade performance:
                                    </p>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(100,'aaa');
                                    </code>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(101,'aaa');
                                    </code>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(102,'aaa');
                                    </code>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(103,'aaa');
                                    </code>
                                    <code lang="SQL">
                                        INSERT INTO T1(id,name) values(104,'aaa');
                                    </code>
                                    <p>
                                        The following example disables batched updates:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.disableUpdateBatch" value="true" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">connectionType</td>
                                <td align="center" valign="top">ConnectionType</td>
                                <td>
                                    <p>
                                        Specifies fully qualified name of the data provider connection type. For example, to connect to 
                                        PostgreSQL database using Npgsql driver use:
                                    </p>
                                    <p>
                                        The default value is <code>sqlclient</code> which is a shortcut for specifying
                                        <code>System.Data.SqlClient.SqlConnection</code>
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.connectionType" value="Npgsql.NpgsqlConnection, Npgsql, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">connectionString</td>
                                <td align="center" valign="top">ConnectionString</td>
                                <td>
                                    <p>
                                        Specifies database connection string.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="default.connectionString" 
                                                     value="server=127.0.0.1;user id=jaak;password=jaak;database=SoodaUnitTests;encoding=unicode" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">upperLike</td>
                                <td align="center" valign="top">UpperLike</td>
                                <td>
                                    <p>
                                        When this parameter is <code>true</code>, both sides of the SQL operator <code>LIKE</code>
                                        are wrapped in <code>UPPER</code> functions. This can be used to search case-insensitively
                                        when the <code>LIKE</code> operator matches case-sensitively.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
        </section>
        <section id="configurationglobal">
            <title>Global Configuration</title>
            <body>
                <p>
                    Sooda has some options which are not data source specific. These options have the name prefix <code>sooda</code>.
                </p>
                <div class="table">
                    <table style="table-layout: fixed">
                        <col style="font-size: 90%; width: 70mm; text-align: center" />
                        <thead>
                            <tr>
                                <th>Configuration setting</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td align="center" valign="top">sooda.connectionopenretries</td>
                                <td>
                                    <p>
                                        Specifies number of tries of opening a database connection.
                                    </p>
                                    <p>
                                        If the data provider's <code>Connection.Open()</code> method throws an exception,
                                        it is executed again until it succeeds or the number of calls exceeds <code>sooda.connectionopenretries</code>.
                                        The default value is 2.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">sooda.hostname</td>
                                <td>
                                    <p>
                                        Overrides the HOSTNAME part of the configuration file, which is normally the machine name
                                        as returned by <code>Environment.MachineName</code>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <configuration>
                                            <appSettings>
                                                <add key="sooda.hostname" value="ALTERNATIVEHOSTNAME" />
                                            </appSettings>
                                        </configuration>
                                        ]]>
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">sooda.innerjoins</td>
                                <td>
                                    <p>
                                        Enables use of <code>INNER JOIN</code> in SQL queries,
                                        which can be more effective than <code>OUTER JOIN</code>.
                                        Defaults to <code>false</code>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td align="center" valign="top">sooda.oracleClientAutoCommitBugWorkaround</td>
                                <td>
                                    <p>
                                        Enables a workaround for a bug in Microsoft's OracleClient in .NET 3.5 SP1.
                                        The bug causes transactions to be autocommitted in certain conditions.
                                        The bug and the workaround are described
                                        <a href="http://social.msdn.microsoft.com/forums/en-US/adodotnetdataproviders/thread/d4834ce2-482f-40ec-ad90-c3f9c9c4d4b1/">here</a>.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
        </section>
    </section>
    <section id="api">
        <title>Application Programming Interface</title>
        <section id="soodatransaction">
            <title>SoodaTransaction</title>
            <body>
                <p>
                    Each database-backed object in Sooda is associated with a transaction represented by 
                    an instance of SoodaTransaction class. Transactions provide database connection management,
                    identity management (ensuring reference-level object identity as mentioned <sectionlink id="primarykeys" />).
                </p>
                <p>
                    In order to support identity management, transactions implement an L1 cache of all alive objects. SoodaTransaction
                    is able to return a cached object given the <code>(className,primaryKeyValue)</code> pair.
                </p>
                <p>
                    No object can live outside the transaction and object state is not defined after the transaction
                    has been closed. Keeping a transaction open for a longer period of time is not recommended because it consumes
                    unmanaged resources, such as database connections.
                </p>
                <p>
                    Transactions need to be closed when they are no longer needed and if you fail to ensure that, otherwise
                    you may get all sorts of unmanaged resource leaks. Typical usage pattern for a Sooda transaction 
                    that ensures the transaction is properly closed is presented below. It makes use of the
                    IDisposable pattern and the C# using() statement:
                </p>
                <code lang="C#">
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // perform operations on Sooda objects here
                        t.Commit();
                    }
                </code>
                <p>
                    In order to support long-running transactions, Sooda supports a <a href="#serialization">differential
                        serialization mechanism</a>, which lets you persist uncommitted changes made within transaction to an XML document, 
                    and deserialize them later, perhaps in a different process or a different machine.
                </p>
            </body>
            <section id="soodatransactioncreating">
                <title>Creating and managing transactions</title>
                <body>
                    <p>
                        Instances of <code>SoodaTransaction</code> must be created before any operation
                        on O/R-mapped objects. You need to properly close the transaction after you are
                        done with the objects. The best way to ensure that your transaction is closed
                        regardless of any exceptions that may occur is to use the <code>IDisposable</code> 
                        pattern and C# <code>using()</code> statement:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            // perform operations on Sooda objects here
                            t.Commit();
                        }
                    </code>
                    <p>
                        This code is equivalent to:
                    </p>
                    <code lang="C#">
                        SoodaTransaction t = new SoodaTransaction();
                        try
                        {
                            // operations here
                            t.Commit();
                        }
                        finally
                        {
                            t.Dispose();
                        }
                    </code>
                    <p>
                        Transactions need to be explicitly committed to properly save all changes made to objects.
                        If you fail to do so, the transaction is rolled back by default.
                    </p>
                    <p>
                        Each transaction must be associated with a mapping schema which is embedded as a resource into the 
                        compiled DAL assembly. You need to configure the transaction to use the appropriate assembly. 
                        There are several ways to do it depending on how you are planning to use your DAL:
                    </p>
                    <ol>
                        <li>By passing the assembly as an argument to <code>SoodaTransaction</code> constructor:
                            <code lang="C#">
                                // _DatabaseSchema class is generated by StubGen.
                                using (SoodaTransaction t = new SoodaTransaction(typeof(_DatabaseSchema).Assembly))
                                {
                                }
                            </code>
                        </li>
                        <li>By setting the <code>ObjectsAssembly</code> property of an open transaction:
                            <code lang="C#">
                                using (SoodaTransaction t = new SoodaTransaction())
                                {
                                    t.ObjectsAssembly = typeof(_DatabaseSchema).Assembly;
                                }
                            </code>
                        </li>
                        <li>By setting the static property <code>SoodaTransaction.DefaultsObjectAssembly</code> which establishes default value for <code>ObjectsAssembly</code> on newly created transactions
                            <code lang="C#">
                                // you need to do it only once
                                SoodaTransaction.DefaultObjectsAssembly = typeof(_DatabaseSchema).Assembly;

                                using (SoodaTransaction t = new SoodaTransaction())
                                {
                                }
                            </code>
                        </li>
                        <li>By setting the assembly name in the <a href="#configuration">configuration file</a>.
                            <code lang="XML">
                                <![CDATA[
                                <configuration>
                                    <appSettings>
                                        <add key="sooda.defaultObjectsAssembly" value="MyObjectsAssembly" />
                                    </appSettings>
                                </configuration>
                                ]]>
                            </code>
                            <p>If your objects assembly is in the GAC, you need to use a fully qualified assembly name:</p>
                            <code lang="XML">
                                <![CDATA[
                                <configuration>
                                    <appSettings>
                                        <add key="sooda.defaultObjectsAssembly" value="MyObjectsAssembly, Version=1.1.12.1512, Culture=neutral, PublicKeyToken=0123456789abcdef" />
                                    </appSettings>
                                </configuration>
                                ]]>
                            </code>
                        </li>
                        <li>By adding <code>SoodaStubAssemblyAttribute</code> to all assemblies that will create SoodaTransaction objects
                            <code lang="C#">
                                using MyBusinessObjects;

                                [assembly: SoodaStubAssembly(typeof(_DatabaseSchema))]

                                class C1
                                {
                                    public static void Main()
                                    {
                                        using (SoodaTransaction t = new SoodaTransaction())
                                        {
                                        }
                                    }
                                }
                            </code>
                        </li>
                    </ol>
                </body>
            </section>
            <section id="soodatransactionimplicit">
                <title>Implicit transactions</title>
                <body>
                    <p>
                        As mentioned earlier, every object which inherits from <code>SoodaObject</code> must be associated with an instance
                        of <code>SoodaTransaction</code>. There are three ways to materialize objects which will be discussed in further sections:
                    </p>
                    <ul>
                        <li><a href="#creatingobjects">creating new objects</a> - using <code>new</code></li>
                        <li><a href="#loadingobjects">loading objects</a>- with <code>Load()</code> and <code>GetRef()</code>, <code>FindByXXX()</code>, <code>LoadSingleObject()</code></li>
                        <li><a href="#loadingbyquery">loading collections of objects</a> - with <code>GetList()</code>, <code>FindListByXXX()</code></li>
                    </ul>
                    <p>
                        All these methods need a transaction object. It would be inconvenient
                        to require the transaction reference to be passed explicitly, therefore Sooda supports the concept of 
                        implicit active transaction (returned by the <code>SoodaTransaction.ActiveTransaction</code> static property).
                        Implicit transaction is used when no explicit transaction is specified.
                    </p>
                    <p>
                        SoodaStubGen generates all APIs in two versions: one that takes <code>SoodaTransaction</code> object as 
                        parameter and the other that assumes implicit transaction. 
                    </p>
                    <p><b>Using implicit transactions:</b></p>
                    <code lang="C#">
                        using (SoodaTransaction transaction = new SoodaTransaction())
                        {
                            Person person;
                            PersonList personList;

                            // object construction - implicit transaction
                            person = new Person();

                            // load single objects
                            person = Person.Load(10);
                            person = Person.GetRef(10);
                            person = Person.LoadSingleObject(PersonField.Name == "Mary Manager");
                            person = Person.FindByName("Mary Manager");

                            // load collection
                            personList = Person.GetList(PersonField.Name == "Mary Manager");
                            personList = Person.FindListByName("Mary%");
                        }
                    </code>
                    <p><b>Explicit transactions:</b> (note that each method call receives transaction as its first argument)</p>
                    <code lang="C#">
                        using (SoodaTransaction transaction = new SoodaTransaction(SoodaTransactionOptions.NoImplicit))
                        {
                            Person person;
                            PersonList personList;

                            // object construction - explicit transaction passed to constructor
                            person = new Person(transaction);

                            // load single objects - transaction passed as first argument
                            person = Person.Load(transaction, 10);
                            person = Person.GetRef(transaction, 10);
                            person = Person.LoadSingleObject(transaction, PersonField.Name == "Mary Manager");
                            person = Person.FindByName(transaction, "Mary Manager");

                            // load collection - transaction passed as first argument
                            personList = Person.GetList(transaction, PersonField.Name == "Mary Manager");
                            personList = Person.FindListByName(transaction, "Mary%");
                        }
                    </code>
                    <p>
                        When you create a new <code>SoodaTransaction</code> object it is automatically 
                        stored in <code>SoodaTransaction.ActiveTransaction</code> unless you
                        pass <code>SoodaTransactionOptions.NoImplicit</code> argument to the constructor. 
                        The property is restored to its previous value when the transaction is closed/disposed, 
                        which means you can nest transactions in an intuitive manner:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t1 = new SoodaTransaction())
                        {
                            // t1 is implicit transaction
                            using (SoodaTransaction t2 = new SoodaTransaction())
                            {
                                // t2 is implicit transaction
                                using (SoodaTransaction t3 = new SoodaTransaction())
                                {
                                    // t3 is implicit transaction
                                }
                                // t2 is implicit transaction
                            }
                            // t1 is implicit transaction
                        }
                    </code>
                    <p>
                        <code>SoodaTransaction.ActiveTransaction</code> reference is usually stored in thread local storage, 
                        but other storage strategies are possible, as described <sectionlink id="activetransactionmanagement" />.
                    </p>
                    <p>
                        All examples in this document use implicit transactions.
                    </p>
                </body>
            </section>
        </section>
        <section id="creatingobjects">
            <title>Creating objects</title>
            <body>
                <p>
                    To create a new persistent object in Sooda you simply invoke its constructor, optionally passing the transaction
                    reference. There are 3 constructors generated by Sooda:
                </p>
                <ul>
                    <li>default constructor - takes no arguments and associates newly created object with the implicit transaction</li>
                    <li>constructor which takes <code>SoodaTransaction</code> as an argument - associates newly created object with the specific transaction</li>
                    <li>special constructor which takes <code>SoodaConstructor</code> as an argument - this 
                       constructor should never be called by the user code and is used internally by Sooda</li>
               </ul>
               <p>
                   Typical code to create an object, set its properties and save to the database is:
               </p>
               <code lang="C#">
                   using (SoodaTransaction t = new SoodaTransaction())
                   {
                        // create new object

                        Person p = new Person();

                        // set properties
                        p.Name = "Nancy Newcomer";
                        p.Sex = "F";
                        p.Address = "1 Microsoft Way";
                        p.ZipCode = "98052";
                        p.City = "Redmond";
                        p.State = "WA";
                        p.BirthDate = new DateTime(1980, 1, 1);

                        // commit
                        t.Commit();
                   }
               </code>
               <p>
                   Sooda allows you to create more than one object in the transaction and will properly handle situations where
                   two newly created objects are dependent on one another. SQL <code>INSERT</code> operations
                   will be properly ordered when <code>Commit()</code> is called, to ensure that all foreign
                   key constraints are preserved.
                   The following example demonstrates this:
               </p>

               <code lang="C#">
                   using (SoodaTransaction t = new SoodaTransaction())
                   {
                        // We have a new customer who whishes to make his first order of two items
                        // We want to make this transactional

                        Customer c = new Customer();
                        Order o = new Order();
                        OrderItem i1 = new OrderItem();
                        OrderItem i2 = new OrderItem();

                        c.Name = "Caroline Customer";
                        c.Address = "...";

                        o.ShipTo = c.Address;
                        o.Customer = c;

                        i1.ItemType = Item.Foo;
                        i1.Quantity = 10;

                        i2.ItemType = Item.Bar;
                        i2.Quantity = 10;

                        o.Items.Add(i1);
                        o.Items.Add(i2);

                        t.Commit();

                        // Sooda properly orders the SQL INSERT statements:
                        //
                        // insert into Customer ...
                        // insert into Order ...
                        // insert into OrderItem ...
                        // insert into OrderItem ...
                        //
                        // SQL statements issued in a different order would violate
                        // referential identity constraints
                   }
               </code>
            </body>
        </section>
        <section id="loadingobjects">
            <title>Loading objects</title>
            <body>
                <p>
                    There are various ways to load objects from the database depending on the desired result:
                </p>
                <ul>
                    <li>Get a reference to the object without loading any data from the database (lazy loading)</li>
                    <li>Load single object from the database given its primary key</li>
                    <li>Load single object or list of objects that match the specified criteria</li>
                    <li>Load all objects from a collection</li>
                </ul>
            </body>
            <section id="loadingobjectsgetref">
                <title>Loading objects by primary key</title>
                <body>
                    <p>
                        Sooda provides two ways to get a reference to an object given its primary key:
                    </p>
                    <ul>
                        <li><code>ClassName.GetRef()</code> - gets a reference to an object without loading its data</li>
                        <li><code>ClassName.Load()</code> - gets a reference to an object and loads its data</li>
                    </ul>
                    <p>
                        Lazy loading is a way to get a reference to the object without actually loading data from the
                        database. Property values will be loaded on first read access. Getting object reference is very fast
                        and should be used when we do not need actual object data, just its reference, as 
                        described <sectionlink id="lazyloading" />.
                    </p>
                    <p>
                        The following example demonstrates basic concepts of lazy loading:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            Employee emp;

                            //////////////////////////////////////////


                            // get a reference to an object - no database access here
                            emp = Employee.GetRef(3);

                            // first READ - this causes the object to be loaded
                            // (roughly equivalent to SELECT * FROM Employee WHERE id = 3)
                            Console.WriteLine(emp.Name);

                            // display hire date - no need to access the database 
                            // as the data is already loaded
                            Console.WriteLine(emp.HireDate);

                            //////////////////////////////////////////

                            // get a reference and load object data
                            emp = Employee.Load(5);

                            // no database access here - data is already in memory
                            Console.WriteLine(emp.Name);

                            // no database access here - data is already in memory
                            Console.WriteLine(emp.HireDate);

                            //////////////////////////////////////////

                            // get a reference to another object

                            emp = Employee.GetRef(7);

                            // change the state of the object
                            // we do not need to load the object at all!
                            emp.Active = false;

                            // commit changes. this sends the following SQL to the database:
                            // UPDATE Employee SET Active=false WHERE ID=7
                            t.Commit();

                        }
                    </code>
                    <p>
                        Reference fields use <code>GetRef()</code> internally so that when you access a property that returns another object
                        this object usually starts in the <code>Data Not Loaded</code> state.
                    </p>
                    <p>
                        Note that it is not always possible to provide a reference to an object without loading its data, so GetRef() 
                        may sometimes need to load the data. When you invoke <code>GetRef()</code> or <code>Load()</code> on an
                        object of class that has subclasses, Sooda needs to load a record from the database to check the concrete type
                        to instantiate. Fortunately Sooda has a Factory Cache mechanism to avoid loading
                        records more than once as described <sectionlink id="factorycache" />.
                    </p>
                </body>
            </section>
            <section id="loadingbyquery">
                <title>Loading objects that match specific criteria</title>
                <body>
                    <p>
                        Sooda uses a <a href="#soql">query language called SOQL</a> to select
                        objects that meet the specific criteria. To get a list of matching objects you 
                        use the <code>GetList()</code> method. 
                        To load a single object by SOQL query use <code>LoadSingleObject()</code>.
                    </p>
                    <p>
                        <code>GetList()</code> method is overloaded to support various usage scenarios.
                        The most complex variant of the method takes five parameters, but <a href="#soodastubgen">SoodaStubGen</a>
                        also generates simplified variants of the GetList() method which only accept 1, 2, 3 or 4 parameters. There are
                        32 overloads generated for each class.
                    </p>
                    <code lang="C#">
                        GetList(transaction, whereClause, topCount, orderBy, options);
                    </code>
                    <p>
                        The parameters are:
                    </p>
                    <ul>
                        <li><code>transaction</code> - (optional) transaction reference, in case it is omitted <code>SoodaTransaction.ActiveTransaction</code> is used</li>
                        <li><code>whereClause</code> - filter clause, either <code>SoodaWhereClause</code> for textual queries or
                            <code>SoqlBooleanExpression</code> for typed queries.</li>
                        <li><code>topCount</code> - (optional) maximum number of objects to retrieve - this is equivalent to <code>SELECT TOP n</code> SQL query</li>
                        <li><code>orderBy</code> - (optional) specifies ordering of result objects</li>
                        <li><code>options</code> - (optional) various flags</li>
                    </ul>
                    <p>
                        <code>ClassName.GetList()</code> returns an instance of <code>ClassNameList</code> which is a type-safe wrapper over
                        <code>ISoodaObjectList</code> and implements <code>IList</code> and <code>IList&lt;ClassName&gt;</code>.
                        More information about collections is given <sectionlink id="collectionapi" />.
                    </p>
                    <p>
                        For example, you can use the following code to run <a href="#soqltext">text-based SOQL query</a> to fetch at most 5 Persons living in Redmond, WA:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                new SoodaWhereClause("City={0} and State={1}", 
                                    "Redmond", "WA"), 5))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                    </code>
                    <p>
                        To run a typed query:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA"))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        To order the results by last name:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA", 
                                SoodaOrderBy.Ascending("LastName")))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        Options you can pass to <code>GetList()</code> are flags defined in 
                        the <code>SoodaSnapshotOptions</code> enumeration.:
                    </p>
                    <ul>
                        <li><code>Default</code> - Default options</li>
                        <li><code>NoTransaction</code> - Do not apply changes made in transaction. Use this option to perform a 
                            database snapshot or when you are sure that none of transaction objects will affect the result. 
                            This helps speed things up a bit.</li>
                        <li><code>NoWriteObjects</code> - Do not precommit objects. Precommit is described <sectionlink id="precommit" />.</li>
                        <li><code>VerifyAfterLoad</code> - Verify after load. In case of a precommit it is possible that the result
                            list will include extra objects. Enabling this option causes the resulting objects to be re-evaluated
                            in memory</li>
                        <li><code>KeysOnly</code> - Load only the primary key values. Objects will be materialized but fields other than primary keys will require a database query.</li>
                        <li><code>Cache</code> - Fetch collection items from cache if possible.</li>
                        <li><code>NoCache</code> - Do not load the collection from cache even if it would be possible to do so</li>
                        <li><code>PrefetchRelated</code> - Use prefetch definition from the schema to load related objects automatically</li>
                    </ul>
                    <p>
                        The most commonly used option here is <code>NoWriteObjects</code> which can be used to disable precommit. 
                        This example demonstrates passing this option to <code>GetList()</code>. Passing SoodaSnapshotOptions.NoWriteObjects
                        causes "<code>Nancy Newcomer</code>" not to be included in the list of returned objects. If we omitted this flag,
                        Sooda would <a href="#precommit">precommit</a> <code>newPerson</code> object by making the SQL <code>INSERT</code> and Nancy Newcomer would be
                        returned by the <code>GetList()</code>.
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            // add a person, whose address matches the following SOQL query
                            Person newPerson = new Person();

                            newPerson.Name = "Nancy Newcomer";
                            newPerson.City = "Redmond";
                            newPerson.State = "WA";

                            // GetList() without precommit - Nancy Newcomer is 
                            // not returned

                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA",
                                SoodaSnapshotOptions.NoWriteObjects))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }

                            // GetList() with precommit - Nancy Newcomer included 
                            // in the list of matching objects

                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA"))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                </body>
            </section>
        </section>
        <section id="collectionapi">
            <title>Collections</title>
            <body>
                <p>
                    There are 3 types of collections in Sooda:
                </p>
                <ul>
                    <li>one-to-many collections</li>
                    <li>many-to-many collections</li>
                    <li>snapshot collections</li>
                </ul>
                <p>
                    One-to-many collections are returned by properties declared with <a href="#schema1N"><x><collectionOneToMany /></x></a>.
                    Many-to-many collections are returned by properties declared with <a href="#schemaNN"><x><collectionManyToMany /></x></a>.
                    All other collection APIs return snapshot collections.
                </p>
                <p>
                    All collection types implement unified interface named <code>ISoodaObjectList</code>
                    but not all methods of this interface can be called in all cases. The table below summarizes that.
                </p>
                <p>
                    The <code>ISoodaObjectList</code> interface has the following methods:
                    (<i>OTM</i> means One-To-Many collections, <i>MTM</i> is Many-To-Many collections, <i>SNAP</i> - snapshots):
                </p>
                <div class="table">
                    <table style="width: 100%; table-layout: fixed">
                        <col style="width: 3cm;align=center" />
                        <col style="width: 1cm;align=center" />
                        <col style="width: 1cm;align=center" />
                        <col style="width: 1cm;align=center" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>OTM</th>
                                <th>MTM</th>
                                <th>SNAP</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Indexer:get</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Gets the item at the specified position.
                                    <code lang="C#">
                                        o = collection[0];
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Indexer:set</td>
                                <td>No</td>
                                <td>No</td>
                                <td>Yes</td>
                                <td>Sets the item at the specified position.
                                    <code lang="C#">
                                        collection[0] = o;
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Add(o)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Adds object <code>o</code> to the collection.
                                    <code lang="C#">
                                        collection.Add(o);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Remove(o)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Removes object <code>o</code> from the collection.
                                    <code lang="C#">
                                        collection.Remove(o);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Contains(o)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Determines whether specific object <code>o</code> is contained in the collection.
                                    <code lang="C#">
                                        if (collection.Contains(o))
                                        {
                                            // o is in the collection
                                        }
                                        else
                                        {
                                            // o is not in the collection
                                        }
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>IndexOf(o)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Gets the position of an object <code>o</code> within the collection.
                                    <code lang="C#">
                                        int pos = collection.IndexOf(o);

                                        if (pos >= 0)
                                        {
                                            // o is in the collection at position 'pos'
                                        }
                                        else
                                        {
                                            // o is not in the collection
                                        }
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Insert(p,o)</td>
                                <td>No</td>
                                <td>No</td>
                                <td>Yes</td>
                                <td>Inserts object <code>o</code> at the specified position <code>p</code>.
                                    <code lang="C#">
                                        collection.Insert(3,o);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>RemoveAt(p)</td>
                                <td>No</td>
                                <td>No</td>
                                <td>Yes</td>
                                <td>Removes object at the specified position <code>p</code>.
                                    <code lang="C#">
                                        collection.RemoveAt(3);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Clear()</td>
                                <td>No</td>
                                <td>No</td>
                                <td>Yes</td>
                                <td>Removes all items from the collection.
                                    <code lang="C#">
                                        collection.Clear();
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>CopyTo(a,o)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Copies the collection to the provided Array <code>a</code> starting at offset <code>o</code>.
                                    <code lang="C#">
                                        // create array to hold collection items
                                        Person[] array = new Person[collection.Count];

                                        // copy them
                                        collection.CopyTo(array,0);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Count</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Returns the number of objects in the collection.
                                    <code lang="C#">
                                        int count = collection.Count;
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>IsReadOnly</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Determines whether the collection is read only.</td>
                            </tr>
                            <tr>
                                <td>IsFixedSize</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Determines whether the collection has fixed size.</td>
                            </tr>
                            <tr>
                                <td>GetEnumerator</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Gets the enumerator that returns all collection items. 
                                    This can be used with <code>foreach()</code> to iterate over the collection.
                                    <code lang="C#">
                                        // foreach() uses GetEnumerator() internally
                                        foreach (Person p in collection)
                                        {
                                        }
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>GetItem(p)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Gets the object at the specified position <code>p</code>.
                                    <code lang="C#">
                                        collection.GetItem(10);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>GetSnapshot()</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new snapshot collection containing all objects of the collection.
                                    <code lang="C#">
                                        newCollection = collection.GetSnapshot();
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>SelectFirst(n)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new collection containing first <code>n</code> objects of the original collection.
                                    <code lang="C#">
                                        // select first 5 objects
                                        newCollection = collection.SelectFirst(5);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>SelectLast(n)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new collection containing last <code>n</code> objects of the original collection.
                                    <code lang="C#">
                                        // select last 5 objects
                                        newCollection = collection.SelectLast(5);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>SelectRange(s,e)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new collection containing objects <code>s</code> to <code>e-1</code> of the original collection.
                                    <code lang="C#">
                                        // select objects 3,4,5,6 from the collection 
                                        // (7th object is not included in the result)
                                        newCollection = collection.SelectLast(3,7);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Filter(f)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new collection containing objects that match the specified filter <code>f</code> which can be:
                                    <ul>
                                        <li>an instance of the <b>SoodaObjectFilter</b> delegate</li>
                                        <li>an instance of <b><code>SoodaWhereClause</code></b> for <a href="#soqltext">textual queries</a></li>
                                        <li>an instance of <b><code>SoqlBooleanExpression</code></b> for <a href="#soqltypedqueries">typed queries</a></li>
                                    </ul>

                                    <p>Examples (all filter out the person named "Mary Manager"):</p>
                                    <code lang="C#">
                                        bool FilterMethod(SoodaObject obj)
                                        {
                                            Person p = (Person)obj;

                                            return p.Name != "Mary Manager";
                                        }

                                        // filter by delegate
                                        collection2 = collection.Filter(
                                            new SoodaObjectFilter(this.FilterMethod));

                                        // filter by where clause
                                        collection2 = collection.Filter(
                                            new SoodaWhereClause("Name != {0}", 
                                                "Mary Manager"));

                                        // filter by typed boolean expression
                                        collection2 = collection.Filter(
                                            PersonField.Name != "Mary Manager");
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>Sort(ex)</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>Creates a new collection with objects sorted according to the specified order expression <code>ex</code>. The order can be:
                                    <ul>
                                        <li>field name or <a href="#pathexpressions">path expression</a>. The string can also specify "asc" or "desc" string
                                            for ascending/descending specification (default is "asc") and can include
                                            multiple fields to sort by. 
                                        </li>
                                    </ul>
                                    <p>Examples:</p>
                                    <code lang="C#">
                                        // sort by Name in ascending order
                                        collection2 = collection.Sort("Name");

                                        // sort by Name in descending order
                                        collection2 = collection.Sort("Name desc");

                                        // sort by Age in ascending order then by Name in descending order:
                                        collection2 = collection.Sort("Age asc,Name desc");

                                        // sort by the group manager's Name in ascending order:
                                        collection2 = collection.Sort("Group.Manager.Name asc");
                                    </code>
                                    <ul>
                                        <li>SOQL expression (typically created with <a href="#soqltypedqueries">typed queries</a> syntax)</li>
                                        <li>SOQL expression and ascending/descending specification</li>
                                    </ul>

                                    <p>Examples:</p>
                                    <code lang="C#">
                                        // sort by Name in ascending order
                                        collection2 = collection.Sort(PersonField.Name);

                                        // sort by Name in descending order
                                        collection2 = collection.Sort(PersonField.Name, SortOrder.Descending);

                                        // sort by the group manager's Name in ascending order:
                                        collection2 = collection.Sort(PersonField.Group.Manager.Name, SortOrder.Ascending);
                                    </code>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    <a href="#soodastubgen">SoodaStubGen utility</a> generates type-safe 
                    wrappers for each class, called <code>ClassNameList</code> where <code>ClassName</code> is the name of the 
                    <x><class /></x> defined <sectionlink id="schema" />. Collections returned from <code>ClassName.GetList()</code>,
                    one-to-many and many-to-many collections are wrapped with the appropriate type-safe wrappers.                    
                    The wrappers inherits from <code>SoodaObjectCollectionWrapper</code> or <code>SoodaObjectCollectionWrapperGeneric&lt;T&gt;</code> 
                    and implements the following set of interfaces:
                </p>
                <ul>
                    <li><code>IEnumerable</code></li>
                    <li><code>IList</code></li>
                    <li><code>ICollection</code></li>
                    <li><code>ISoodaObjectList</code></li>

                    <li><code>IEnumerable&lt;T&gt;</code> - .NET 2.0 and above</li>
                    <li><code>IList&lt;T&gt;</code> - .NET 2.0 and above</li>
                    <li><code>ICollection&lt;T&gt;</code> - .NET 2.0 and above</li>
                </ul>
                <p>The following example shows the typical usage of collections. 
                    As you can see the amount of boilerplate code is reduced to minimum:</p>
                <code lang="C#">
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // load Customer from the database
                        Customer c = Customer.Load(10);

                        // loop through the customer's orders and display their summaries
                        // c.Orders is a one-to-many collection
                        foreach (Order o in c.Orders)
                        {
                            Console.WriteLine("o.OrderDate: {0}", o.OrderDate);
                            Console.WriteLine("o.ShipTo: {0}", o.ShipTo);

                            Console.WriteLine("Item count: {0}", o.Items.Count);

                            // now display the details of each ordered item
                            foreach (OrderItem it in o.Items)
                            {
                                Console.WriteLine("item: {0} quantity: {1}", it.ItemType, it.Quantity);
                            }
                        }

                        // create new order with 2 items

                        Order newOrder = new Order();
                        newOrder.ShipTo = c.Address;

                        OrderItem i1 = new OrderItem();
                        OrderItem i2 = new OrderItem();

                        c.Name = "Caroline Customer";
                        c.Address = "...";
                        c.Orders.Add(newOrder);

                        i1.ItemType = Item.Foo;
                        i1.Quantity = 10;

                        i2.ItemType = Item.Bar;
                        i2.Quantity = 10;

                        o.Items.Add(i1);
                        o.Items.Add(i2);

                        // display orders sorted by their date

                        foreach (Order o in c.Orders.Sort(OrderField.Date))
                        {
                            Console.WriteLine("Order #{0} Date: {1}", o.OrderID, o.Date);
                        }
                    }
                </code>
            </body>
        </section>
        <section id="objectidentity">
            <title>Object Identity Management</title>
            <body>
                <p>
                    Sooda guarantees reference identity for objects retrieved from a database. It means
                    that if we make 2 or more queries which retrieve a particular row from the 
                    database in the same <a href="#soodatransaction">transaction</a>
                    they are guaranteed to be mapped to the same object (not just two objects that are equal).
                    It means that you can modify the object through either any of the references and 
                    you will be modifying the same object, so the state is going to be consistent.
                    Mechanism that ensures object identity is called Level 1 (transaction-level) caching.
                </p>
                <p>
                    The following example demonstrates multiple ways to acquire references to objects 
                    and the identity assertions that Sooda guarantees:
                </p>
                <code lang="C#">
                    <![CDATA[
                        // load person 
                        Person p1 = Person.GetRef(10);

                        // get a reference to a person
                        Person p2 = Person.GetRef(10);

                        // load person by text-based query
                        Person p3 = Person.LoadSingleObject(new SoodaWhereClause("Id = 10"));

                        // load person by typed query
                        Person p4 = Person.LoadSingleObject(PersonField.Id == 10);

                        // some O/R mappers only guarantee this:

                        Assert.AreEqual(p1, p2);
                        Assert.AreEqual(p1, p3);
                        Assert.AreEqual(p1, p4);

                        // but Sooda also provides reference identity guarantee

                        Assert.AreSame(p1, p2);
                        Assert.AreSame(p1, p3);
                        Assert.AreSame(p1, p4);

                        //
                        // NOTATION (using NUnit-syntax):
                        //
                        // Assert.AreSame(a,b) asserts that Object.ReferenceEquals(a,b)
                        // Assert.AreEqual(a,b) asserts that a.Equals(b) and b.Equals(a)
                        //
                    ]]>
                </code>
                <p>
                    There are methods and properties of the <code>SoodaTransaction</code> class that let you to control
                    the object cache mechanism:
                </p>
                <ul>
                    <li><code>UseWeakReferences</code> property - enables weak references to be used for L1 cache management. Setting this property to <code>true</code>
                        causes Sooda to keep track of <b>unmodified</b> objects in transactions using weak references. This makes them
                        subject to be garbage-collected when the memory is low. 
                        Modified (dirty) objects are always registered using strong references.
                        Because unmodified objects can always be retrieved from the database, this approach is useful
                        when you are dealing with a large number of read-only objects that are cheap to reload from the database.
                    </li>
                    <li><code>DirtyObjects</code> property - returns a collection of dirty objects (objects modified within
                        the transaction)</li>
                    <li><code>DeletedObjects</code> property - returns a collection of objects marked for delete</li>
                    <li><code>FindObjectWithKey(className,keyValue,expectedType)</code> method -&#160;returns a cached object whose class name 
                        is <code>className</code> and primary key is <code>keyValue</code>. If the object is not found in L1 cache or if the object
                        is not of <code>expectedType</code>, this function returns <code>null</code>.</li>
                    <li><code>GetObject(className,keyValueString)</code> method - gets a reference to the object of the specified class
                        and primary key. The primary key is given as a string, so this method is best suited for scripting/web environment
                        where the primary key can be passed in a URL. This method does not pre-load object data
                        into memory, that is it is equivalent to <code>ClassName.GetRef(keyValue)</code> method.</li>
                    <li><code>LoadObject(className,keyValueString)</code> method - same as <code>GetObject(className,keyValueString)</code> 
                        but preloads object data into memory. It is an equivalent of the <code>ClassName.Load(keyValue)</code> method.</li>
                    <li><code>GetNewObject(className)</code> - creates a new object of specified class. It is same as
                        creating a new instance of the object by calling the constructor and passing current transaction as an argument.</li>
                </ul>
            </body>
        </section>
        <section id="serialization">
            <title>Serialization and Deserialization</title>
            <body>
                <p>
                    Transactions in Sooda are meant to be short-lived, because each SoodaTransaction manages
                    one or more open database connections which should be short-lived.
                    It is not recommended to keep the database connections open for a longer period of time because 
                    it might negatively impact system scalability.
                </p>
                <p>
                    There are cases when long-lived transactions are desired, such as in a web application that
                    gathers user input from many web pages, makes incremental changes to the database and commits the transaction
                    once at the very end of the process. Sooda provides differential serialization
                    mechanism that allows you to capture the state of an open transaction and store it in an XML document.
                    This XML document can be persisted to some medium (such as a file, buffer in memory, ASP.NET Session 
                    state or ViewState) and restored in a new transaction later. 
                    The transaction can be restored in another thread, process, or even on another machine, as long as the target 
                    environment has access to the original database.
                </p>
                <p>
                    The API for serialization and deserialization is very simple. It consists of methods named <code>Serialize()</code> and 
                    <code>Deserialize()</code> respectively. The serialization code is presented below:
                </p>
                <code lang="C#">
                    <![CDATA[
                    using (SoodaTransaction tran = new SoodaTransaction())
                    {
                        // create, modify or delete objects here

                        Customer c = Customer.Load(1);
                        c.Address = "New Address";

                        // do not call Commit(), but call Serialize() instead
                        string serializedXml = tran.Serialize();

                        // write the state of transaction to a file
                        File.WriteAllText("c:\\temp\\transaction.xml", serializedXml);
                    }
                    ]]>
                </code>

                <p>
                    To deserialize the transaction in a new environment, just use the <code>Deserialize()</code> method:
                </p>

                <code lang="C#">
                    <![CDATA[
                    using (SoodaTransaction tran = new SoodaTransaction())
                    {
                        // load the transaction from a file
                        string serializedXml = File.ReadAllText("c:\\temp\\transaction.xml");

                        tran.Deserialize(serializedXml);

                        // load the object
                        Customer c = Customer.Load(1);

                        // verify that deserialization worked
                        Assert.AreEqual("New Address, c.Name);

                        // All object modifications uncommitted in 
                        // previous transaction are reflected here
                        // you can either commit them here or serialize again
                        // and deserialize in yet another place

                        tran.Commit();
                    }
                    ]]>
                </code>
                <p>
                    The XML returned by the <code>Serialize()</code> method should be treated as opaque (you should not assume
                    anything about its structure), but is generally human-readable. Sample transaction dump is presented below:
                </p>
                <code lang="XML">
                    <![CDATA[
                        <transaction>
                          <object mode="insert" class="Announcement">
                            <key ordinal="0" type="int32" value="1" />
                          </object>
                          <object mode="insert" class="ActivityObjectInsert">
                            <key ordinal="0" type="int32" value="222" />
                          </object>
                          <object mode="update" class="Announcement">
                            <key ordinal="0" type="int32" value="1" />
                            <field name="TimeStamp" type="datetime" value="07/19/2006 09:26:10" />
                            <field name="ActiveFlag" type="boolint" value="true" />
                            <field name="Description" type="string" value="we have a network problem blah blah blah" />
                            <field name="Type" type="int32" value="1" />
                            <field name="ValidFrom" type="datetime" value="07/19/2006 09:26:10" />
                            <field name="ValidUntil" type="datetime" value="07/19/2006 09:26:10" />
                          </object>
                          <object mode="update" class="ActivityObjectInsert">
                            <key ordinal="0" type="int32" value="222" />
                            <field name="ClassName" type="string" value="Announcement" />
                            <field name="KeyValue" type="int32" value="1" />
                            <field name="TimeStamp" type="datetime" value="07/19/2006 09:26:10" />
                            <field name="Person" type="int32" value="1" />
                            <field name="Type" type="int32" value="4" />
                            <field name="SummaryPlainText" type="string" value="Object has been created" />
                            <field name="SummaryCRTFFile" type="string" value="" />
                            <field name="Action" type="int32" value="2" />
                          </object>
                        </transaction>                
                        ]]>
                </code>
            </body>
        </section>
        <section id="soodaobject">
            <title>SoodaObject</title>
            <body>
                <p>
                    Stub classes generated by <a href="#soodastubgen">SoodaStubGen utility</a> are derived from
                    <code>SoodaObject</code> which provides some common methods and infrastructure for storing
                    object data, caching, lazy loading, <a href="#triggers">triggers</a> and more. 
                    This section describes public API exposed by 
                    <code>SoodaObject</code> class. More details are available in the source code comments.
                </p>
                <p>
                    <code>SoodaObject</code> exposes no public properties, only methods. All properties
                    visible from outside of the object are generated by <a href="#soodastubgen">SoodaStubGen</a>. 
                    Public methods of <code>SoodaObject</code> are:
                </p>
                <ul>
                    <li><code>bool AreFieldUpdateTriggersEnabled()</code> - returns a value indicating whether field 
                        update triggers (<code>BeforeFieldUpdate</code> and <code>AfterFieldUpdate</code>) are enabled.
                        More information about field update triggers can be found <sectionlink id="triggers" />.</li>
                    <li><code>bool EnableFieldUpdateTriggers()</code> - enables field update triggers and returns a boolean value indicating their state before enabling</li>
                    <li><code>bool DisableFieldUpdateTriggers()</code> - disables field update triggers and returns a boolean value indicating their state before disabling</li>
                    <li><code>bool EnableFieldUpdateTriggers(bool flag)</code> - enables or disables field update triggers based on the boolean flag. This function returns the previous state of triggers. 
                        <p>
                            An ordinary pattern for disabling field update triggers for some region of code is presented below.
                        </p>

                        <code lang="C#">
                            bool oldValue = obj.DisableFieldUpdateTriggers();
                            try
                            {
                                // modify object - no BeforeFieldUpdate or AfterFieldUpdate triggers are called
                                obj.Name = "New Name";
                                obj.Age = 123;
                            }
                            finally
                            {
                                // restore field update triggers to the saved state
                                obj.EnableFieldUpdateTriggers(oldValue);
                            }
                        </code>

                    </li>
                    <li><code>void ForcePostCommit()</code> - forces the postcommit trigger (<code>AfterObjectUpdate()</code>) to be called even if there are no changes to object's internal state</li>
                    <li><code>bool IsInsertMode()</code> - returns a value indicating whether the object is in insert mode (that is, it has been created in the transaction). Note that it does not indicate
                        that object has not been inserted into the database yet, because of possible <a href="#precommit">precommit</a>.</li>
                    <li><code>SoodaTransaction GetTransaction()</code> - returns a reference to the transaction that manages this object.</li>
                    <li><code>void MarkForDelete()</code> - marks the object for deletion and executes any cascade deletes on all objects that reference this object. 
                        Sooda issues SQL DELETE statement as soon as objects are marked for deletion, 
                        but since the transaction is not committed until the very end, this operation can be reversed. 
                        Deleting objects immediately helps Sooda detect any foreign key constraint violations.</li>
                    <li><code>bool IsMarkedForDelete()</code> - returns a value indicating whether the object has been marked for deletion.</li>
                    <li><code>bool IsFieldDirty(fieldNumber)</code> - returns a value indicating whether the specified field (indicated by its ordinal) is dirty.</li>
                    <li><code>bool SetFieldDirty(fieldNumber,dirty)</code> - sets or clears the specified field's dirty flag, which causes it to be saved to the database on commit. 
                        Sooda normally manages the dirty flag automatically, but you might want to override it in certain situation. Use with caution.</li>
                    <li><code>bool IsObjectDirty()</code> - returns a value indicating whether the object has been modified in the transaction. Note that resetting field statuses back to non-dirty does not automatically make the object non-dirty. 
                        Only <code>Commit()</code> or <code>Rollback()</code> clears this flag.</li>
                    <li><code>ClassInfo GetClassInfo()</code> - gets the <code>ClassInfo</code> object that include the schema-level metadata about the class. More information about <code>ClassInfo</code> is available <sectionlink id="schemaapi" />.</li>
                    <li><code>string GetObjectKeyString()</code> - returns a unique string that includes object's primary key. The string is of the form <code>"ClassName[PrimaryKeyValue]"</code>, for example <code>"Person[10]"</code> 
                        or <code>"Employee[1234]"</code>.</li>
                    <li><code>object GetPrimaryKeyValue()</code> - returns a primary key of the object. For scalar (single-columns) primary keys actual values (integer or string) are returned, for multi-column primary keys this function 
                        returns an instance of the <code>SoodaTuple</code> class.</li>
                    <li><code>object Evaluate(SoqlExpression expression[, bool throwOnError])</code> - evaluates the <a href="#soql">SOQL expression</a> in memory and returns its value. <code>throwOnError</code> causes 
                        the function to either throw exception or return <code>null</code> on error (such as null reference exception).</li>
                    <li><code>string GetLabel()</code> - evaluates the label property and returns its string value. The name of the label 
                        property is defined with the <a href="#schemaclasses"><x><class label="..." /></x> declaration</a> in the schema file.</li>
                </ul>
                    
            </body>
        </section>
        <section id="triggers">
            <title>Triggers</title>
            <body>
                <p>
                    Sooda supports application triggers (as opposed to database triggers) which are fired each time one of the following events occurs:
                </p>
                <ul>
                    <li>object is inserted into a database</li>
                    <li>object is updated</li>
                    <li>object is deleted</li>
                    <li>field is modified</li>
                </ul>
                <p>
                    There are two variants of each trigger: "before" trigger and "after" trigger. Triggers are methods declared 
                    in the <code>SoodaObject</code> class 
                    that can be overridden in skeleton classes generated by the <a href="#soodastubgen">SoodaStubGen utility</a>.
                    Overriding a "before" trigger allows you to prevent some operation (such as field modification) from happening
                    while "after" triggers are called after the operation has been already performed. 
                </p>
                <p>
                    They object-level triggers have canonical names:
                </p>
                <ul>
                    <li><code>void BeforeObjectInsert()</code> - fires immediately before an object is inserted into the database</li>
                    <li><code>void AfterObjectInsert()</code> - fires after all objects have been inserted into the database and committed, once for each object.</li>
                    <li><code>void AfterObjectUpdate()</code> - fires immediately before an object is updated</li>
                    <li><code>void AfterObjectDelete()</code> - fires after all objects have been updated and committed, once for each object.</li>
                    <li><code>void BeforeObjectDelete()</code> - fires immediately before the object is deleted</li>
                    <li><code>void AfterObjectDelete()</code> - fires after the object has been deleted and committed</li>
                </ul>
                <p>
                    The field-level trigger methods are:
                </p>
                <ul>
                    <li><code>void BeforeFieldUpdate(string fieldName, object oldValue, object newValue)</code> - fires immediately before any of the fields is updated</li>
                    <li><code>void AfterFieldUpdate(string fieldName, object oldValue, object newValue)</code> - fires immediately after any the fields has been modified</li>
                    <li><code>void BeforeFieldUpdate_FieldName(object oldValue, object newValue)</code> - fires immediately before field FieldName is modified</li>
                    <li><code>void AfterFieldUpdate_FieldName(object oldValue, object newValue)</code> - fires immediately after field FieldName has been modified</li>
                </ul>
                <p>
                    To prevent the field update from happening, you need to override the "before" trigger method and throw an exception from it. 
                    The following example demonstrates overriding the triggers:
                </p>

                <code lang="C#">
                    <![CDATA[
    public class Person : Person_Stub
    {
        // constructors omitted

        protected override void BeforeObjectInsert()
        {
            base.BeforeObjectInsert();
            Console.WriteLine("Object is about to be inserted.");
        }

        protected override void AfterObjectInsert()
        {
            base.AfterObjectInsert();
            Console.WriteLine("Object has been inserted.");
        }

        protected override void BeforeObjectUpdate()
        {
            base.BeforeObjectUpdate();
            Console.WriteLine("Object is about to be updated.");
        }

        protected override void AfterObjectUpdate()
        {
            base.AfterObjectUpdate();
            Console.WriteLine("Object has been updated.");
        }

        protected override void BeforeObjectDelete()
        {
            base.BeforeObjectDelete();
            Console.WriteLine("Object is about to be deleted.");
        }

        protected override void AfterObjectDelete()
        {
            base.AfterObjectDelete();
            Console.WriteLine("Object has been deleted.");
        }

        protected override void BeforeFieldUpdate_Age(object oldValue, object newValue)
        {
            base.BeforeFieldUpdate_Age(oldValue, newValue);
            Console.WriteLine("Modifying field Age from {0} to {1}", oldValue, newValue);

            if (newValue.Equals(42))
            {
                // this exception prevents the field update from happening when the user
                // attempts to change Age to 42.
                throw new Exception("Cannot set Age to 42!");
            }
        }

        protected override void AfterFieldUpdate_Age(object oldValue, object newValue)
        {
            base.AfterFieldUpdate_Age(oldValue, newValue);
            Console.WriteLine("Field Age has been modified from {0} to {1}", oldValue, newValue);
        }
    }
        ]]>
            </code>
            <p>
                Object-level triggers are always available and cannot be disabled. You can disable field-level triggers 
                (BeforeFieldUpdate_xxx and AfterFieldUpdate_xxx) either at stub generation stage or at runtime.
                The former option is useful to reduce the amount of generated code, because stub classes can get pretty large 
                when you declare many fields in a class.
            </p>
            <p>
                <a href="#soodastubgen">SoodaStubGen</a> provides two ways to disable the generation of field-level triggers. You can
                disable them at the class level, by specifying <x><class triggers="false" /></x> and you can enable
                them individually at the field level by specifying <x><field forceTrigger="true" /></x>. For example:
            </p>
            <code lang="XML">
                <![CDATA[
                <schema>
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                    </class>
                    <class name="Vehicle" triggers="false">
                        <table name="Vehicle">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Price" type="Decimal" />
                            <field name="Description" type="String" size="40" forceTrigger="true" />
                        </table>
                    </class>
                </schema>
                ]]>
            </code>
            <p>
                This declaration will cause the following trigger methods to be generated:
            </p>
            <ul>
                <li><code>Employee_Stub.BeforeFieldUpdate_Name()</code></li>
                <li><code>Employee_Stub.AfterFieldUpdate_Name()</code></li>
                <li><code>Employee_Stub.BeforeFieldUpdate_Salary()</code></li>
                <li><code>Employee_Stub.AfterFieldUpdate_Salary()</code></li>
                <li><code>Employee_Stub.BeforeFieldUpdate_HireDate()</code></li>
                <li><code>Employee_Stub.AfterFieldUpdate_HireDate()</code></li>
                <li><code>Employee_Stub.BeforeFieldUpdate_Active()</code></li>
                <li><code>Employee_Stub.AfterFieldUpdate_Active()</code></li>
                <li><code>Vehicle_Stub.BeforeFieldUpdate_Description()</code></li>
                <li><code>Vehicle_Stub.AfterFieldUpdate_Description()</code></li>
            </ul>
            <p>
                The following trigger methods will not be generated because of the <code>triggers="false"</code> attribute of <x><class name="Vehicle" /></x>:
            </p>
            <ul>
                <li><code>Vehicle_Stub.BeforeFieldUpdate_Price()</code></li>
                <li><code>Vehicle_Stub.AfterFieldUpdate_Price()</code></li>
            </ul>
            <p>
                Note that Sooda does not generate triggers for primary key fields. That is because they are immutable - you cannot the 
                value of a primary key once it has been set, as it would break the rules of reference identity. It would lead to a situation
                where two different objects would have the same primary key values which is forbidden.
            </p>
        </body>
        </section>
        <section id="keygeneration">
            <title>Key Generation</title>
            <body>
                <p>
                    Key generation is a process of generating unique identifiers to be used for primary keys of newly created objects.
                    Because primary keys must be known before objects can be committed, <b>you cannot use SQL Server identity columns</b> for key
                    generation. By default Sooda uses a table-based key generator that manages primary keys by storing their values in
                    a special database table, but you can write your own generator by creating a class that implements 
                    the <code>IPrimaryKeyGenerator</code> interface.
                </p>
                <p>
                    Table-based primary key generation uses a database table (called <code>KeyGen</code> by default) 
                    with 2 columns: <code>key_name</code> and <code>key_value</code> which store class name and
                    next primary key value to be generated respectively:
                </p>
                <img src="doc16.gif" />
                <p>
                    Because keys are stored in the database table, generating them requires two SQL statements to be executed. One is SELECT to
                    fetch the current value of the primary key, the other one is to update the database table so that next 
                    generation will not use the same value again. Because of this cost, Sooda allocates keys in batches of ten (the number is
                    configurable) so it only needs to make 2 round-trips to the server for every ten new keys generated.
                </p>
                <code lang="SQL">
                    -- fetch current value of the primary key
                    SELECT @kv = key_value FROM KeyGen where key_name = 'ClassName';

                    -- update KeyGen table with the new possible primary key
                    UPDATE KeyGen
                    SET key_value = @kv + 10
                    WHERE key_name = 'ClassName' AND key_value = @kv 
                </code>
                <p>
                    This algorithm is multi-process safe, so multiple processes can create new objects concurrently, 
                    but it does not guarantee that the primary keys of newly created objects will be monotonously increasing.
                </p>
                <p>
                    You can configure the name of the table and batch size on a per-datasource basis 
                    by using the configuration parameters:
                </p>
                <ul>
                    <li><code><b>datasourcename</b>.keygentable.name</code> - name of the keygen table (by default (<code>KeyGen</code>)</li>
                    <li><code><b>datasourcename</b>.keygentable.keycolumn</code> - name of the columns that holds key names (by default <code>key_name</code>)</li>
                    <li><code><b>datasourcename</b>.keygentable.valuecolumn</code> - name of the columns that holds values (by default <code>key_value</code>)</li>
                    <li><code><b>datasourcename</b>.keygentable.pool_size</code> - the number of keys to allocate at one (by default <code>10</code>)</li>
                </ul>
                <p>
                    The following example demonstrates using application configuration file to override default name
                    of the KeyGen table and names of its columns.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <appSettings>
                            <add key="default.keygentable.name" value="MyKeyGen" />
                            <add key="default.keygentable.keycolumn" value="keys" />
                            <add key="default.keygentable.valuecolumn" value="values" />
                        </appSettings>
                    </configuration>
                    ]]>
                </code>
            </body>
        </section>
        <section id="precommit">
            <title>Precommitting objects in transactions</title>
            <body>
                <p>
                    Sooda supports the <code>GetList()</code> method to get the list of objects matching the specified criteria. It is not possible
                    to calculate the list in memory because it would be very inefficient, therefore the criteria written in SOQL 
                    (textual or typed) are converted to SQL and executed by the database engine. 
                    Objects in transaction can be modified, created and deleted and RDBMS needs to be notified of all
                    such modifications or it will return an outdated list of matching objects.
                </p>
                <p>
                    Consider this example:
                </p>
                <code lang="C#">
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // create new person object but don't commit it

                        Person p = new Person();
                        p.Name = "Nancy Newcomer";

                        // now get a list of all persons

                        PersonList pl = Person.GetList(true);
                    }
                </code>
                <p>
                    The condition <code>true</code> passed to the <code>GetList()</code> method is always met, so you expect 
                    it to return all objects of class <code>Person</code> including the newly created 'Nancy Newcomer' object. 
                    <code>GetList()</code> ultimately results in an SQL query, whose result should
                    include the mentioned object. For this reason, Sooda needs to issue an <code>INSERT INTO Person</code> statement
                    before executing the <code>SELECT</code> statement on the database.
                </p>
                <p>
                    In general, Sooda ensures that any modifications made in transaction, which can affect the query results,
                    are saved to the database before the query is executed. Objects that need to be precommitted are:
                </p>
                <ul>
                    <li>all objects of the queried class (<code>Person</code> in the above example) and its subclasses</li>
                    <li>all objects of classes mentioned in the <code>WHERE</code> clause and their subclasses</li>
                    <li>all uncommitted, dependent objects of the above which are in insert mode</li>
                </ul>
                <p>
                    For example, the following code causes all objects of <code>Person</code>, 
                    <code>Group</code> and <code>OrganizationUnit</code> classes to be precommitted because they are mentioned
                    in the <code>WHERE</code> clause
                </p>
                <code lang="C#">
                    <![CDATA[
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        Person p;

                        Person.GetList(PersonField.Name == "Mary Manager" 
                                    && PersonField.Group.Name == "Managers" 
                                    && PersonField.OrgUnit.Name == "Sales Department");
                    }
                    ]]>
                </code>
                <p>
                    To disable precommit, you need to pass the <code>SoodaSnapshotOptions.NoWriteObjects</code> option 
                    to the <code>GetList()</code> method. To manually cause a precommit at any time, you can 
                    invoke the <code>SoodaTransaction.SaveObjectChanges()</code> method.
                </p>
                <p>
                    Note that if your query contains a <code>RAWQUERY()</code> clause, determining the list of
                    objects to be precommitted may not be possible, so all objects are precommitted to ensure consistent 
                    results.
                </p>
                <p>
                    Precommitting objects can become difficult if we have non-nullable fields in the database and
                    data for these fields has not been provided yet (this is only possible when the object is in insert mode). 
                    When inserting such objects, Sooda needs to provide SOME value for the column, otherwise the insert will fail.
                    You can specify what values should be written to the database for each column type, referenced table or you can
                    set them on a per-field basis as described <sectionlink id="schemaprecommitvalues" />.
                    It is important to specify correct precommit values for all referenced tables if you 
                    use foreign key constraints in the database. If you do not specify the precommit values, Sooda will insert 
                    the default value of zero into foreign key columns which may violate the constraints.
                </p>
            </body>
        </section>
        <section id="cachingapi">
            <title>Caching</title>
            <body>
                <p>
                    Sooda supports two caching levels:
                </p>
                <ul>
                    <li><b>transaction identity cache</b> - also called Level 1 cache, whose primary goal is to ensure object referential identity</li>
                    <li><b>Level 2 Cache</b> - which optimizes database access by caching results of SQL queries that read single objects and collections</li>
                </ul>
                <p>
                    First level of cache is totally transparent to the user, while the second level of cache is configurable
                    and may need to be tuned for the best performance. There are two aspects of the cache mechanism that are tunable:
                </p>
                <ul>
                    <li>caching policy</li>
                    <li>cache storage</li>
                </ul>
                <p>
                    Caching policy determines what objects should be stored in cache and how long they are kept there. 
                    There are many possible approaches here:
                </p>
                <ul>
                    <li><b>none</b> - do not use Level 2 cache</li>
                    <li><b>all</b> - all objects are subject to be cached - useful for small databases (up to 1 GB)</li>
                    <li><b>small</b> - cache small cardinality objects, large and medium cardinality objects are always reloaded from the database</li>
                    <li><b>smallmedium</b> - cache small and medium cardinality objects, large cardinality objects are always reloaded from the database</li>
                </ul>
                <p>
                    Objects are considered <code>Small</code>, <code>Medium</code> or <code>Large</code> depending on the
                    <code>cardinality</code> setting in the <a href="#schema">mapping schema</a>.
                </p>
                <p>
                    In addition to this, you can also create your own caching policy by creating a class that implements 
                    the <code>ISoodaCachingPolicy</code> interface. Your caching policy can use caching hints (<code>cached</code>, 
                    <code>cacheCollections</code>, <code>cardinality</code> as defined in the schema) or your algorithm to decide
                    which objects or collections should be put into cache.
                </p>
                <p>
                    To configure the caching policy for your application, just set the <code>sooda.cachingPolicy</code> key in the
                    <a href="#configuration">configuration file</a> to one of the predefined policy names or use the name
                    of your own class which implements the <code>ISoodaCachingPolicy</code>. To configure expiration timeout and
                    sliding expiration use <code>sooda.cachingPolicy.expirationTimeout</code> (timeout in seconds) and 
                    <code>sooda.cachingPolicy.slidingExpiration</code> (boolean <code>true</code> or <code>false</code>) respectively. 
                    The following example configures caching of small and medium objects, with the expiration timeout of one 
                    hour and sliding expiration set to true:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <appSettings>
                            <!-- cache small and medium objects -->
                            <add key="sooda.cachingPolicy" value="smallmedium" />

                            <!-- retain objects for 3600 seconds - one hour -->
                            <add key="sooda.cachingPolicy.expirationTimeout" value="3600" />

                            <!-- each access to an object resets the one-hour timeout -->
                            <add key="sooda.cachingPolicy.slidingExpiration" value="true" />
                        </appSettings>
                    </configuration>
                    ]]>
                </code>
                <p>
                    Alternatively you can configure caching in code, by setting the static property called <code>CachingPolicy</code>
                    of the <code>SoodaCache</code> class:
                </p>
                <code lang="C#">
                    // cache small and medium objects
                    SoodaCacheSmallAndMediumPolicy policy = new SoodaCacheSmallAndMediumPolicy();

                    // retain objects for one hour
                    policy.ExpirationTimeout = TimeSpan.FromHours(1);

                    // each access to an object resets the one-hour timeout
                    policy.SlidingExpiration = true;

                    // make the caching policy active for new transactions
                    SoodaCache.DefaultCachingPolicy = policy;
                </code>
                <p>
                    Newly created transactions default to the caching policy stored in <code>SoodaCache.DefaultCachingPolicy</code>, but
                    you can override it for each transaction separately. To disable caching for a particular transaction, use this code:
                </p>
                <code lang="C#">
                    <![CDATA[
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // don't use caching in this transaction
                        t.CachingPolicy = new SoodaNoCachingPolicy();
                    }
                    ]]>
                </code>
                <p>
                    In addition to various caching policies, Sooda supports pluggable storage engines. By default Sooda comes with two:
                </p>
                <ul>
                    <li><b>inprocess</b> - default - in-process LRU cache</li>
                    <li><b>none</b> - no caching</li>
                </ul>
                <p>
                    You can implement other cache storage mechanism by creating a class that 
                    implements the <code>ISoodaCache</code> interface. It should be possible to integrate with commercial
                    cache engines through this interface for great scalability.
                </p>
                <p>
                    To configure cache storage mechanism, just set the <code>sooda.cache</code> parameter in in the configuration file to
                    one of the mentioned caching implementations. You can also specify a fully qualified name of the class that implements
                    <code>ISoodaCache</code> interface:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <appSettings>
                            <add key="sooda.cache" value="MySuperCache.SoodaCachingProvider, MySuperCache, PublicKeyToken=..., Version=..." />
                        </appSettings>
                    </configuration>
                    ]]>
                </code>
                <p>
                    You can achieve the same thing in code, by setting the <code>DefaultCache</code> 
                    property of the <code>SoodaCache</code> class:
                </p>
                <code lang="C#">
                    MySuperCache.SoodaCachingProvider cache = MySuperCache.SoodaCachingProvider();

                    // configure 'cache' here - set some hypothetical properties
                    cache.Size = 1000000;
                    cache.Location = "c:\\mycache";
                    
                    // make the cache active for new transactions
                    SoodaCache.DefaultCache = cache;
                </code>
                <p>
                    As with the caching policies, you can also override the cache mechanism on a per-transaction basis:
                </p>
                <code lang="C#">
                    <![CDATA[
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // override default cache storage for this transaction
                        t.Cache = cache;
                    }
                    ]]>
                </code>
            </body>
        </section>
        <section id="sqldatasource">
            <title>Working with Data Sources</title>
            <body>
                <p>
                    Sooda supports pluggable data sources. In theory it should be possible to implement support backends 
                    other than relational databases, but current version of Sooda only supports SQL Data sources.
                </p>
                <p>
                    SQL Data source provides a way to programmatically execute SOQL queries against relational databases. It is 
                    also used internally by Sooda to provide low-level mapping functionality such as loading single
                    objects, collections and saving changes back to the database.
                    It currently supports the following RDBMSes:
                </p>
                <ul>
                    <li><code>mssql</code> - Microsoft SQL Server 2000, 2005, MSDE and SQL Server Express</li>
                    <li><code>postgresql</code> - PostgreSQL 8.x and higher</li>
                    <li><code>oracle</code> - Oracle 8i and higher</li>
                    <li><code>mysql4</code> - MySQL 4.x and higher</li>
                </ul>
                <p>
                    SQL Data Source is implemented in <code>Sooda.Sql.SqlDataSource</code> class. 
                    To use it in the <a href="#schema">mapping schema</a>, declare a <x><datasource /></x> with a type
                    of <code>Sooda.Sql.SqlDataSource</code>:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <datasource name="db" type="Sooda.Sql.SqlDataSource" />
                    </schema>
                    ]]>
                </code>
                <p>
                    Note that at this point, you do not specify the database connection type, connection string or SQL
                    dialect - these things are configured at runtime, so that applications can run unmodified with
                    a database engine of choice. Data source runtime configuration is explained 
                    <sectionlink id="configuringdatasources" />.
                </p>
                <p>
                    There are two ways to acquire a <code>SqlDataSource</code> object, depending on whether you
                    have an open transaction. If you do, getting the SQL data source is a matter of calling <code>OpenDataSource()</code>
                    method on a <code>SoodaTransaction</code> instance, passing the name of the data source to open.
                    SoodaTransaction manages a list of open data sources and will return the same data source object when <code>OpenDataSource()</code> 
                    is called with the same data source name twice.
                </p>
                <code lang="C#">
                    using (SoodaTransaction t = new SoodaTransaction())
                    {
                        // get a reference to open datasource
                        SqlDataSource ds = (SqlDataSource)t.OpenDataSource("default");

                        // you do not need to (and should not) close the data source 
                        // explicitly it will be closed when the transaction terminates.
                    }
                </code>
                <p>
                    If you are not within the context of a transaction or you want to create a 
                    detached <code>SqlDataSource</code> object, create a new object with <code>new</code>
                    passing the data source name as an argument to the constructor. To make sure that the SQL Data Source 
                    is properly closed, it is best to use the C# <code>using()</code> statement:
                </p>
                <code lang="C#">
                    using (SqlDataSource ds = new SqlDataSource("default"))
                    {
                    }
                </code>
                <p>
                    Before you can use the <code>SqlDataSource</code> object, you need to initialize its properties.
                    If you pass the name of the datasource in the constructor invocation, default values for
                    the properties are read automatically from the configuration file as 
                    described <sectionlink id="configuringdatasources" />. Once the properties have been initialized,
                    you should call the <code>Open()</code> method to connect to the database.
                </p>
                <p>
                    The following methods and properties of the <code>SqlDataSource</code> class can be invoked from user code:
                </p>
                <ul>
                    <li><code>Open()</code> method.
                        <blockquote>
                            Opens the data source which connects to the database and opens a new transaction (unless <code>DisableTransactions</code> has been set to <code>true</code>).
                        </blockquote>
                    </li>
                    <li><code>IsOpen</code> property.
                        <blockquote>
                            Returns <code>true</code> if the connection is open, <code>false</code> otherwise
                        </blockquote>
                    </li>
                    <li><code>Rollback()</code> method.
                        <blockquote>
                            Performs rollback of the open transaction and starts a new one. This method does nothing if <code>DisableTransactions</code> is set to <code>true</code>.
                        </blockquote>
                    </li>
                    <li><code>Commit()</code> method.
                        <blockquote>
                            Performs commit of the open transaction and starts a new one.
                        </blockquote>
                    </li>
                    <li><code>Close()</code> method.
                        <blockquote>
                            Closes the connection to the database.
                        </blockquote>
                    </li>
                    <li><code>IDataReader ExecuteQuery(SoqlQueryExpression query, SchemaInfo schema, object[] parameters)</code> method
                        <blockquote>
                            Executes SOQL <code>query</code> represented as <code>SoqlQueryExpression</code>, which can be retrieved
                            from a textual representation by calling <code>SoqlParser.ParseExpression(soqlText)</code>.
                            The <code>schema</code> parameter is an instance of the <a href="#schemaapischemainfo">SchemaInfo</a> class
                            and <code>parameters</code> is an array of values to be used for 
                            <code>{0}</code>, <code>{1}</code>, <code>{2}</code> ... parameter placeholders. See below for an example
                            use of this method.
                        </blockquote>
                    </li>
                    <li><code>IDataReader ExecuteRawQuery(string queryText, object[] parameters)</code> method
                        <blockquote>
                            Executes raw SQL query on an open data source. <code>parameters</code> is an array of values to be used for 
                            <code>{0}</code>, <code>{1}</code>, <code>{2}</code> ... parameter placeholders.
                            Other than that, this method is equivalent to <code>IDbCommand.ExecuteReader()</code>.
                        </blockquote>
                    </li>
                    <li><code>int ExecuteNonQuery(string queryText, object[] parameters);</code> method
                        <blockquote>
                            Executes raw SQL command that does not return any records (such as SQL <code>INSERT</code> or <code>UPDATE</code>)
                            on an open data source. <code>parameters</code> is an array of values to be used for 
                            <code>{0}</code>, <code>{1}</code>, <code>{2}</code> ... parameter placeholders.
                            Other than that, this method is equivalent to <code>IDbCommand.ExecuteNonQuery()</code>.
                        </blockquote>
                    </li>
                </ul>
                <p>
                    There are other public methods available in the <code>SqlDataSource</code> class, but they are reserved for
                    Sooda internal use. The following example demonstrates the most typical use of SqlDataSource which is executing
                    an SOQL query and iterating over the result set:
                </p>
                <code lang="C#">
                    <![CDATA[
                        using Sooda;
                        using Sooda.Sql;
                        using Sooda.Schema;
                        using Sooda.QL;

                        class Program
                        {
                            static void Main(string[] args)
                            {
                                // connect to the data source 'default' defined 
                                // in the configuration file

                                using (SqlDataSource sds = new SqlDataSource("default"))
                                {
                                    sds.Open();

                                    // SOQL textual query
                                    string soqlQuery = @"
                                        SELECT Name, PrimaryGroup.Name, PrimaryGroup.Members.Count
                                        FROM Contact 
                                        WHERE PrimaryGroup.Manager.Name = {0} OR Name = {1}";

                                    // parse the query to a SoqlQueryExpression object
                                    SoqlQueryExpression queryExpression = SoqlParser.ParseQuery(soqlQuery);

                                    // get the schema reference
                                    SchemaInfo schema = Sooda.UnitTests.BaseObjects._DatabaseSchema.GetSchema();

                                    // prepare parameters
                                    object[] parameters = new object[] 
                                    {
                                        "Mary Manager", // positional parameter {0}
                                        "Eva Employee" // positional parameter {1}
                                    };

                                    // execute query
                                    using (IDataReader reader = sds.ExecuteQuery(queryExpression, schema, parameters))
                                    {
                                        // iterate the result set
                                        while (reader.Read())
                                        {
                                            Console.WriteLine("name: {0} group: {1} members: {2}", 
                                                reader.GetString(0), 
                                                reader.GetString(1), 
                                                reader.GetInt32(2));
                                        }
                                    }
                                }
                            }
                        } // class Program
                    ]]>
                </code>
                <p>
                    When you run this example on the <code>SoodaUnitTests</code> database that comes with Sooda, it displays the following results:
                </p>
                <code lang="C#">
                    name: Mary Manager group: Group1 members: 4
                    name: Ed Employee group: Group1 members: 4
                    name: Eva Employee group: Group2 members: 1
                    name: Caroline Customer group: Group1 members: 4
                    name: Chuck Customer group: Group1 members: 4
                </code>
            </body>
        </section>
        <section id="dynamicfields">
            <title>Dynamic Fields</title>
            <body>
                <p>
                    In addition to fields defined in the mapping schema, Sooda supports creation and deletion of fields at runtime.
                    Fields created at runtime are called <i>dynamic</i>.
                    Dynamic fields are defined per-class and have the following properties:
                    name, type (optionally a reference), nullability and, for selected types, size and precision.
                    Dynamic fields can be accessed using a string indexer (<code>obj["MyField"]</code>)
                    or the .NET 4 <code>dynamic</code> type. The indexer can be used in <a href="#linq">LINQ queries</a>.
                </p>
                <p>
                    Definition of dynamic fields is stored in the database table called <code>SoodaDynamicField</code>
                    while field values are stored in separate tables, one table per dynamic field.
                    A table for dynamic field values is created when the field is added, and dropped when the field is removed.
                    The name of the table is the parent class and the field name combined with an underscore, e.g. <code>MyClass_MyDynamicField</code>.
                    Dynamic field table usually contains two columns: <code>id</code> and <code>value</code>,
                    where <code>id</code> is the object primary key and <code>value</code> is the value of the dynamic field.
                    There are more columns (<code>id2</code>, <code>id3</code>, ...) if the primary key is composite.
                    To conserve storage, null values are not stored in the database. Therefore the <code>value</code> column is never nullable.
                </p>
            </body>
            <section id="dynamicfieldsenabling">
                <title>Enabling Dynamic Fields</title>
                <body>
                    <p>
                        To enable dynamic fields in your project, first create the database table <code>SoodaDynamicField</code>
                        and grant permissions for the SQL user your application uses:
                    </p>
                    <code lang="SQL">
                        create table SoodaDynamicField (
                            class varchar(32) not null,
                            field varchar(32) not null,
                            type varchar(32) not null,
                            nullable int not null,
                            fieldsize int null,
                            precision int null,
                            constraint PK_SoodaDynamicField primary key (class, field)
                        );
                        grant create table to soodatest
                        grant references to soodatest -- SQL Server only
                    </code>
                    <p>
                        The next step is enabling dynamic fields support in your mapping schema. It is enabled per data source, e.g.
                    </p>
                    <code lang="XML">
                        <![CDATA[
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" dynamicFields="true" />
                        ]]>
                    </code>
                    <p>
                        The last step is re-generating stubs from the modified mapping schema.
                    </p>
                    <p>
                        Now your application supports dynamic fields.
                        The first time it creates a <code>SoodaTransaction</code>, it will query the <code>SoodaDynamicField</code> table
                        and use the dynamic fields defined there. When you add dynamic fields with the Sooda API, this table will get updated
                        and the dynamic field tables will get created or dropped.
                    </p>
                </body>
            </section>
            <section id="dynamicfieldsmanaging">
                <title>Managing Dynamic Fields</title>
                <body>
                    <p>
                        To create a dynamic field, create a <code>Sooda.Schema.FieldInfo</code> object and set the following properties:
                    </p>
                    <ul>
                        <li><code>ParentClass</code> - the class that the field is going to be added to.</li>
                        <li><code>Name</code> - identifier of the field within the class. It must not collide with the fields already defined in the mapping schema.</li>
                        <li><code>DataType</code>, <code>References</code>, <code>IsNullable</code> - type and nullability, see below for alternative ways.</li>
                        <li><code>Size</code> - required for string fields, optional for decimal/float/double.</li>
                        <li><code>Precision</code> - optional for decimal/float/double.</li>
                    </ul>
                    <p>
                        Instead of setting <code>DataType</code> and <code>References</code>, you can set <code>TypeName</code>.
                        It is either the string representation of <code>DataType</code> or the name of the referenced class without the namespace.
                    </p>
                    <p>
                        Another alternative is setting the <code>Type</code> property. For value types, it also sets nullability, e.g. <code>typeof(int)</code> is non-nullable
                        while <code>typeof(int?)</code> is nullable. You still need to set <code>IsNullable</code> for string and reference types.
                        Setting <code>Type</code> to <code>typeof(string)</code> will select the <code>String</code> data type and never an <code>AnsiString</code>.
                        <code>typeof(bool)</code> selects <code>BooleanAsInteger</code> and not <code>Boolean</code>.
                    </p>
                    <p>
                        Once your <code>FieldInfo</code> contains all the required information, pass it to the <code>Add</code> method
                        of <code>DynamicFieldManager</code>, together with a <code>SoodaTransaction</code>:
                    </p>
                    <code lang="C#">
                        Sooda.Schema.DynamicFieldManager.Add(fieldInfo, transaction);
                    </code>
                    <p>
                        Adding a dynamic field changes the internal structure of the objects.
                        Therefore, until you are finished with adding dynamic fields, you must not use any objects of the class you modify.
                        Currently this requirement is not verified by Sooda and failing to fulfill it can lead to exceptions and data corruption.
                        An exception from this rule is that you can read objects which won't be modified in this transaction.
                        Same applies to removing a dynamic field.
                    </p>
                    <p>
                        Adding and removing a dynamic field completely clears the Sooda <a href="#cachingapi">Level 2 cache</a>.
                    </p>
                    <p>
                        The field is now available for use (see below).
                    </p>
                    <p>
                        For large volumes of data, filtered by the dynamic field, consider creating a database index for the new field:
                    </p>
                    <code lang="C#">
                        Sooda.Schema.DynamicFieldManager.CreateIndex(fieldInfo, transaction);
                    </code>
                    <p>
                        Dynamic fields are available in the <a href="#schemaapi">schema API</a> just like the fields defined in the mapping schema:
                    </p>
                    <ul>
                        <li><code>classInfo.LocalFields</code> includes dynamic fields.</li>
                        <li><code>classInfo.UnifiedFields</code> includes dynamic fields, including the ones defined in base classes.</li>
                        <li><code>classInfo.FindFieldByName()</code> can return a dynamic field.</li>
                    </ul>
                    <p>
                        <code>fieldInfo.IsDynamic</code> returns <code>true</code> for a dynamic field.
                    </p>
                    <p>
                        After a dynamic field is added, you can only modify its nullability:
                    </p>
                    <code lang="C#">
                        fieldInfo.IsNullable = true;
                        Sooda.Schema.DynamicFieldManager.Update(fieldInfo, transaction);
                    </code>
                    <p>
                        To remove a dynamic field, call:
                    </p>
                    <code lang="C#">
                        Sooda.Schema.DynamicFieldManager.Remove(fieldInfo, transaction);
                    </code>
                    <p>
                        Beware that this removes all the existing field data by dropping the table.
                    </p>
                </body>
            </section>
            <section id="dynamicfieldsusing">
                <title>Using Dynamic Fields</title>
                <body>
                    <p>
                        Dynamic fields can be accessed with an indexer, passing a field name as a string:
                    </p>
                    <code lang="C#">
                        object value = obj["MyField"];
                    </code>
                    <p>
                        For value types, the indexer always returns a boxed object which can be unboxed by casting
                        to a raw value type or a <code>Nullable</code> type. That is, the indexer never returns an <code>SqlType</code>.
                        If a dynamic field is added when there are already objects of the parent class,
                        the field values for existing objects will be <code>null</code>, even if the field is non-nullable.
                    </p>
                    <p>
                        When you assign a dynamic field:
                    </p>
                    <code lang="C#">
                        obj["MyField"] = value;
                    </code>
                    <p>
                        the type and nullability of the field are validated.
                        <code>ArgumentNullException</code> will be thrown when <code>null</code> is assigned to a non-nullable field.
                        <code>InvalidCastException</code> will be thrown when value type is invalid.
                        On setting field value, <code>BeforeFieldUpdate(fieldName, oldValue, newValue)</code>
                        and <code>AfterFieldUpdate(fieldName, oldValue, newValue)</code> triggers will be called if enabled.
                    </p>
                    <p>
                        In addition to dynamic fields, the indexer can be also used to read (but not write) fields defined in the mapping schema.
                    </p>
                    <p>
                        Alternatively to the indexer, you can access dynamic fields with the .NET 4 <code>dynamic</code> type:
                    </p>
                    <code lang="C#">
                        dynamic dynamicObj = obj;
                        object value = dynamicObj.MyField;
                        ...
                        dynamicObj.MyField = newValue;
                    </code>
                    <p>
                        The indexer syntax can be used in <a href="#linq">LINQ</a> queries, e.g.:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                            MyObject.Linq().Where(o => o["MyField"] != null);
                            MyObject.Linq().Where(o => (int) o["MyField"] == 42);
                        ]]>
                    </code>
                </body>
            </section>
        </section>
    </section>
    <section id="soql">
        <title>Query Languages</title>
        <body>
            <p>
                Sooda supports a query language named SOQL which is similar to SQL (Structured Query Language)
                enhanced with path expressions, collections, named constants and inheritance support. Only SELECT operation is 
                supported which means no INSERT/UPDATE/DELETE support exists in SOQL.
            </p>
        </body>
        <section id="soqltext">
            <title>SOQL Queries</title>
            <body>
                <p>
                    SOQL queries have syntax similar to SQL SELECT statements. Each query has the following form:
                </p>
                <code lang="SQL">
                    SELECT     [TOP number] [DISTINCT] select_expressions
                    FROM       from_expressions
                    [WHERE     boolean_expression]
                    [GROUP BY  groupby_expressions]
                    [HAVING    boolean_expression]
                    [ORDER BY  sort_expressions]
                </code>
                <p>
                    SOQL queries are based on classes and fields as opposed to tables and columns. You should use names defined in the <a href="#schema">mapping schema</a> 
                    with <x><class name="..." /></x> and <x><field name="..." /></x>. Let's assume you have the following class definition that
                    maps table <code>ctct</code> to class <code>Contact</code> and uses field names different from column names:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Contact">
                        <table name="ctct">
                            <field name="ID" dbcolumn="contact_id" type="Integer" primaryKey="true" />
                            <field name="Name" dbcolumn="contact_name" type="String" size="40" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    You can write the following SOQL statement that gets the name of some particular contact:
                </p>
                <code lang="SQL">
                    select Name
                    from   Contact
                    where  ID=123
                </code>
                <p>
                    It is equivalent to the following SQL query:
                </p>
                <code lang="SQL">
                    select contact_name
                    from   ctct
                    where  contact_id = 123
                </code>
                <p>
                    SQL-like query from multiple classes with JOIN specified in the where clause is supported but rarely needed
                    because Sooda supports <a href="#soqlpathexpressions">path expressions</a> which greatly
                    simplify query code. There are other useful extensions to SQL, as described <sectionlink id="soqllanguageelements" />.
                </p>
            </body>
        </section>
        <section id="soqllanguageelements">
            <title>SOQL Language Elements</title>
            <body>
                <p>
                    SOQL supports the following language constructs known from SQL:
                </p>
                <ul>
                    <li>relational operators (<code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>LIKE</code>)</li>
                    <li>boolean operators (<code>AND</code>, <code>OR</code>)</li>
                    <li><code>EXISTS()</code>, <code>IN()</code>, <code>IS NULL</code> and <code>IS NOT NULL</code> predicates</li>
                    <li>arithmetic operators (<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code> and <code>%</code>) with natural precedence and associativity</li>
                    <li>arithmetic (<code>-</code>) and boolean (<code>NOT</code>) negation</li>
                </ul>
                <p>
                    In addition the following new constructs are supported:
                </p>
                <ul>
                    <li><a href="#soqlpathexpressions">path expressions</a> for specifying join-less criteria (<code>t.PrimaryGroup.Manager.Name</code>)</li>
                    <li><a href="#soqlcollections">one-to-many and many-to-many collections</a> supporting <code>Count</code> and <code>Contains</code> operations</li>
                    <li>named constants (as defined in the <a href="#schema">mapping schema</a>)</li>
                    <li><code>TRUE</code> and <code>FALSE</code> literals</li>
                    <li>simplified subqueries</li>
                    <li>functions</li>
                    <li>raw SQL queries</li>
                    <li><code>SoodaClass</code> operator</li>
                </ul>
                <p>
                    SOQL is case-insensitive on keywords, class names and property names. 
                    For readability, it is recommended to use the original casing when 
                    referring to fields and classes. Case sensitivity of string comparisons and SOQL <code>LIKE</code> operator are  database-dependent.
                </p>
            </body>
            <section id="soqlpathexpressions">
                <title>Path Expressions</title>
                <body>
                    <p>
                        Path expressions let you traverse many-to-one and one-to-one relationships
                        without JOIN operators. To access a property of a related object you simply prefix the name of the property
                        with the path of dot-separated property names that leads to the object. Path length is unlimited.
                    </p>
                    <p>
                        Here is an example of a SOQL query that retrieves all contacts who belong to groups managed by 'Mary Manager':
                    </p>
                    <code lang="SQL">
                        SELECT *
                        FROM   Contact
                        WHERE  PrimaryGroup.Manager.Name = 'Mary Manager'
                    </code>
                </body>
            </section>
            <section id="soqlcollections">
                <title>Collections</title>
                <body>
                    <p>
                        Sooda supports one-to-many and many-to-many collections in queries. SOQL queries 
                        can get the size of a collection as well as check if a particular 
                        object is contained in the collection. The following operations are supported:
                    </p>
                    <ul>
                        <li><code>collection.Count</code> - get the size of a collection</li>
                        <li><code>collection.Contains(object)</code> - check whether a particular object is included in the collection</li>
                        <li><code>collection.Contains(ClassName where condition)</code> - check whether any object from the collection matches the specified condition</li>
                    </ul>
                    <p>
                        To get the number of elements in the collection, just append the <code>.Count</code> after the collection name:
                    </p>
                    <code lang="SQL">
                        -- select all contacts that have more than one role
                        SELECT * 
                        FROM Contact
                        WHERE Roles.Count > 1
                    </code>
                    <p>
                        Using <code>Count</code> is supported in select expressions, not just in the WHERE clause:
                    </p>
                    <code lang="SQL">
                        -- return the name of each person followed by the number 
                        -- of members in his group
                        
                        select  Name, 
                                PrimaryGroup.Members.Count
                        from    Contact
                    </code>
                    <p>
                        To check if a given collection contains a particular object, use the <code>Contains(object)</code>. 
                        The <code>object</code> can be a value of a object field, a named constant or a literal value (an integer or a string):
                    </p>
                    <code lang="SQL">
                        -- get the names of all groups that Mary Manager belongs to
                        -- Contact.Mary is a named constant

                        select  Name
                        from    Group
                        where   Members.Contains(Contact.Mary);
                    </code>
                    <p>
                        The same condition can be specified by using the value of <code>1</code> (the primary key) instead of <code>Contact.Mary</code>.
                    </p>
                    <code lang="SQL">
                        -- get the names of all groups including Mary Manager

                        select  Name
                        from    Group
                        where   Members.Contains(1);
                    </code>
                    <p>
                        More complicated queries are possible of course:
                    </p>
                    <code lang="SQL">
                        -- return all groups where the manager
                        -- is not one of the members

                        select  *
                        from    Group 
                        where	not Members.Contains(Manager)
                    </code>
                    <p>
                        The argument of <code>Contains()</code> may be a subquery or a <a href="#soqlsimplifiedqueries">simplified sub-query</a>. 
                        The following query returns a list of all groups which have at least one female member:
                    </p>
                    <code lang="SQL">
                        select  * 
                        from    Group
                        where   Members.Contains(Contact where Sex = 'F')
                    </code>
                    <p>
                        Contains() expressions can be nested:
                    </p>
                    <code lang="SQL">
                        -- find all groups which have at least one contact who is 
                        -- in a role whose name starts with 'Admin'

                        select  *
                        from    Group
                        where   Members.Contains(Contact 
                                    where Roles.Contains(Role where Name like 'Admin%'))
                    </code>
                    <p>
                        You can see that <code>Count</code> and <code>Contains()</code> are 
                        quite powerful constructs that let you write simple and complex queries without
                        the use of explicit joins. Join-free SOQL queries can be translated to SQL
                        thanks to a translator provided by Sooda described <sectionlink id="soqltosqlconversion" />.
                    </p>
                </body>
            </section>
            <section id="soqlsoodaclass">
                <title>SoodaClass</title>
                <body>
                    <p>
                        <code>SoodaClass</code> is a virtual property that is present in all Sooda classes. It returns name
                        of the class as defined in the <a href="#schema">mapping schema</a>. 
                        It can be used to distinguish between subclasses in polymorphic queries.
                    </p>
                    <code lang="SQL">
                        -- select vehicles which are bikes or super bikes

                        select *
                        from   Vehicle v
                        where  v.SoodaClass = 'Bike' or v.SoodaClass = 'SuperBike'
                    </code>
                </body>
            </section>
            <section id="soqlsimplifiedqueries">
                <title>Simplified Subqueries</title>
                <body>
                    <p>
                        SOQL provides a convenient notation for specifying subqueries that are used as arguments to <code>EXISTS()</code> and <code>Contains()</code>
                        <code>SELECT id FROM class WHERE condition</code> can be shortened to <code>Class WHERE condition</code>. Thus the following two
                        SOQL queries are equivalent:
                    </p>
                    <code lang="SQL">
                        -- Using full subqueries
                        select *
                        from Group
                        where Members.Contains(select ID from Contact where Name = 'Mary Manager')
                    </code>
                    <code lang="SQL">
                        -- Using simplified subqueries:
                        select *
                        from Group
                        where Members.Contains(Contact where Name = 'Mary Manager')
                    </code>
                    <p>
                        The same rule applies to EXISTS():
                    </p>
                    <code lang="SQL">
                        <![CDATA[
                        select *
                        from Group g
                        where exists (Group g2 where g.ID <> g2.ID and g.Name = g2.Name)
                        ]]>
                    </code>
                </body>
            </section>
            <section id="soqlrawqueries">
                <title>Raw Queries</title>
                <body>
                    <p>
                    Raw queries can be used to take advantage of RDBMS-specific SQL constructs, such as full-text-search, custom
                    operators and built-in functions. Raw queries are passed unmodified by the <a href="#soqltosqlconversion">SOQL to SQL Conversion</a>.
                    </p>
                    <p>
                        To write a raw query, simply use <code>RAWQUERY(text)</code>. The <code>text</code> can be any SQL, but you
                        must be careful to correctly balance parenthesis. <code>RAWQUERY()</code> may also be a potential security risk
                        if you pass unvalidated user input as raw queries.
                    </p>
                    <code lang="SQL">
                        // use SQL Server-specific full-text search function "contains()"

                        select * 
                        from   Contact
                        where  rawquery(contains(*,'quick'))
                    </code>
                    <p>
                        Raw queries may include translated field and class names. You can escape back to SOQL by using the <code>SOQL{{...}}</code>
                        notation:
                    </p>
                    <code lang="SQL">
                        <![CDATA[
                        -- find all contacts employed earlier than 10 years ago

                        select * 
                        from   Contact
                        where  rawquery(datediff(y, SOQL{{HireDate}}, getdate() > 10)
                        ]]>
                    </code>
                    <p>
                        Double braces must be used because {0},{1},{2} notation is used to reference positional parameters.
                    </p>
                </body>
            </section>
        </section>
        <section id="soqlgrammar">
            <title>SOQL Grammar</title>
            <body>
                <p>
                    Formal syntax of SOQL is presented below. The following notation is used:
                </p>
                <ul>
                    <li><code>&lt;symbol&gt; ::= expression</code> - production</li>
                    <li><code>[X]</code> - X is optional</li>
                    <li><code>{X}</code> - X can be repeated zero or more times</li>
                    <li><code>a | b</code> - either a or b</li>
                    <li><code>'token'</code> or <code>TOKEN</code> - terminal symbol</li>
                </ul>
                <code lang="SQL" src="web/SOQL.bnf">
                    <![CDATA[
                    ]]>
                </code>
            </body>
        </section>
        <section id="soqlwhereclauses">
            <title>SOQL Where Clauses</title>
            <body>
                <p>
                    SOQL expressions can be used to filter objects returned by the <code>GetList()</code> or 
                    <code>LoadSingleObject()</code> methods. You simply pass the <code>WHERE</code> clause as a string 
                    argument to the constructor of the <code>SoodaWhereClause</code> class and pass the 
                    constructed where clause object to the appropriate method. You cannot specify a list of columns here, <code>GetList()</code> 
                    and <code>LoadSingleObject()</code> always operate on objects.
                </p>
                <code lang="C#">
                    ContactList cl;

                    // get the list of contacts whose names start with 'Mary'
                    cl = Contact.GetList(new SoodaWhereClause("Name like 'Mary%'"));
                </code>
                <p>
                    Manually concatenating string literals can be dangerous and lead 
                    to <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting vulnerabilities</a> in web applications.
                    Fortunately Sooda lets you separate string literals from the rest of the query code.
                    You can use the <code>{0}, {1}, {2}</code> notation similar to <code>Console.WriteLine()</code>.
                    Note that you do not need to quote the strings yourself nor surround <code>{0}</code> with apostrophes. In fact
                    this would cause the '{0}' string to be treated literally and not as a parameter reference.
                </p>
                <code lang="C#">
                    ContactList cl;
                    string lookFor = "Mary Manager";

                    // get the list of contacts matching the specified name
                    // note that {0} is not enclosed in apostrophes.
                    cl = Contact.GetList(new SoodaWhereClause("Name = {0}", lookFor));
                </code>
            </body>
        </section>
        <section id="soqltypedqueries">
            <title>Typed SOQL Queries</title>
            <body>
                <p>
                    Textual queries passed to <code>SoodaWhereClause</code> have one deficiency: property/field names
                    that you use are not validated at compilation time. It is possible to write code that contains
                    references to non-existing fields. The compilation will succeed, but you will get runtime
                    errors.
                </p>
                <p>
                    When developing large systems that change often (such as workflow applications with
                    ever-changing customer requirements) it may be beneficial to statically validate all queries used in 
                    the application to make sure that you only reference correct fields. This way, when you remove a field
                    from the schema or change its type, the application will simply not compile and the compiler will show
                    you statements that need to be corrected because of the original change.
                </p>
                <p>
                    Sooda implements typed SOQL queries, which let you write SOQL-like expressions in pure C# using a technique
                    called operator overloading. Sooda comes with a large set of classes that represent nodes in query expression
                    trees (such as relational operators, path expressions, <code>Count</code>, <code>Contains</code>, boolean <code>and</code>, 
                    <code>or</code>, <code>not</code> and so on).
                    These classes overload standard C# operators such as <code>+</code>,<code>-</code>,<code>&amp;&amp;</code>,
                    <code>||</code> so that they return elements of the syntax tree instead of performing actual computations.
                </p>
                <p>
                    To properly support path expressions, some schema-specific code needs to be generated as well 
                    which <a href="#soodastubgen">SoodaStubGen utility</a> takes care of. It generates a set of 
                    classes that let you build typed path expressions and typed collection expression builders. They both
                    let you express almost all SOQL features. In some rare cases (such as SQL functions or subqueries)
                    you can resort to text-based SOQL and even combine the two approaches in a single query.
                </p>
                <p>
                    Typed queries are very concise, because you do not need to wrap them with strings or use
                    any special objects (such as <code>SoodaWhereClause</code>) that will parse them. You do not need
                    to use any form of string escaping and because there is no parsing involved whatsoever you can be
                    sure that the code is cross-site-scripting-safe.
                </p>
                <p>
                    The following table compares features of typed queries and text-based SOQL. The syntax for typed queries
                    and operator precedence is based on the C# language. Note that other languages that support 
                    operator overloading may use different notation and/or different operator precedence.
                </p>

                <div class="table">
                    <table style="table-layout: fixed">
                        <col style="font-family: Consolas, Courier New; width: 3cm; text-align: center" />
                        <col style="font-family: Consolas, Courier New; width: 3cm; text-align: center" />
                        <thead>
                            <tr>
                                <th>SOQL</th>
                                <th>Typed Query</th>
                                <th>Remarks</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>path expressions</td>
                                <td>path expressions prefixed with ClassNameField</td>
                                <td>
                                        You need to prefix all path expressions in typed queries with the <code>ClassName<u>Field</u></code> where <code>ClassName</code> is 
                                    the name of the class the expression applies to. For example:
                                    <code lang="C#">
                                        ContactField.PrimaryGroup.Manager.Name
                                    </code>
                                    <p>
                                        is equivalent to the following SOQL expression:
                                    </p>
                                    <code lang="SQL">
                                        PrimaryGroup.Manager.Name
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>=</td>
                                <td>==</td>
                                <td>Equality operator</td>
                            </tr>
                            <tr>
                                <td>&lt;&gt;</td>
                                <td>!=</td>
                                <td>Inequality operator</td>
                            </tr>
                            <tr>
                                <td>&lt;=</td>
                                <td>&lt;=</td>
                                <td>Less than or equal operator</td>
                            </tr>
                            <tr>
                                <td>&lt;</td>
                                <td>&lt;</td>
                                <td>Less than</td>
                            </tr>
                            <tr>
                                <td>&gt;</td>
                                <td>&gt;</td>
                                <td>Greater than</td>
                            </tr>
                            <tr>
                                <td>&gt;=</td>
                                <td>&gt;=</td>
                                <td>Greater than or equal to</td>
                            </tr>
                            <tr>
                                <td>and</td>
                                <td>&amp;&amp;</td>
                                <td>Boolean conjunction</td>
                            </tr>
                            <tr>
                                <td>or</td>
                                <td>||</td>
                                <td>Boolean alternative</td>
                            </tr>
                            <tr>
                                <td>not</td>
                                <td>!</td>
                                <td>Boolean negation</td>
                            </tr>
                            <tr>
                                <td>+</td>
                                <td>+</td>
                                <td>Addition or string concatenation</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>-</td>
                                <td>Subtraction</td>
                            </tr>
                            <tr>
                                <td>*</td>
                                <td>*</td>
                                <td>Multiplication</td>
                            </tr>
                            <tr>
                                <td>/</td>
                                <td>/</td>
                                <td>Division</td>
                            </tr>
                            <tr>
                                <td>%</td>
                                <td>%</td>
                                <td>Modulus</td>
                            </tr>
                            <tr>
                                <td>-</td>
                                <td>-</td>
                                <td>Unary minus</td>
                            </tr>
                            <tr>
                                <td>like</td>
                                <td>Like() method</td>
                                <td>LIKE relational operator. Because C# does not support the definition of extra operators this is a method.
                                    The following C# expression:
                                    <code lang="C#">
                                        ContactField.Name.Like("Mary%");
                                    </code>
                                    is equivalent to the expression in SOQL:
                                    <code lang="SQL">
                                        Name like 'Mary%'
                                    </code>
                                    </td>
                            </tr>
                            <tr>
                                <td>Count</td>
                                <td>Count</td>
                                <td>Gets the number of elements in a collection.</td>
                            </tr>
                            <tr>
                                <td>Contains(obj)</td>
                                <td>Contains(obj)</td>
                                <td>Determines whether obj is contained in the collection.</td>
                            </tr>
                            <tr>
                                <td>Contains(X where condition)</td>
                                <td>ContainsXWhere( condition )</td>
                                <td>Determines whether any object contained in the collection meets the specified condition.</td>
                            </tr>
                            <tr>
                                <td>is null</td>
                                <td>IsNull() method</td>
                                <td>Determines whether the expression is null. This typed query predicate can be only used on nullable fields. It fails to compile when used on fields that are known to be not-null.
                                    The following C# expression:
                                    <code lang="C#">
                                        ContactField.PrimaryGroup.Manager.IsNull()
                                    </code>
                                    is equivalent to the expression in SOQL:
                                    <code lang="SQL">
                                        PrimaryGroup.Manager is null
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>is not null</td>
                                <td>IsNotNull() method</td>
                                <td>Determines whether the expression is not null. This typed query predicate can be only used on nullable fields. It fails to compile when used on fields that are known to be not-null.
                                    The following C# expression:
                                    <code lang="C#">
                                        ContactField.PrimaryGroup.Manager.IsNoNull()
                                    </code>
                                    is equivalent to the expression in SOQL:
                                    <code lang="SQL">
                                        PrimaryGroup.Manager is not null
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>in (a1,a2,...,aN)</td>
                                <td>In(a1,a2,...,aN) method</td>
                                <td>Determines whether the left hand side of the expression equals to any value on the right hand side
                                    of the expression.
                                    The following C# expression:
                                    <code lang="C#">
                                        ContactField.PrimaryGroup.Manager.FirstName.In("Mary","Edmund")
                                    </code>
                                    is equivalent to the expression in SOQL:
                                    <code lang="SQL">
                                        PrimaryGroup.Manager.FirstName in ('Mary','Edmund')
                                    </code>
                                </td>                                    
                            </tr>
                            <tr>
                                <td>rawquery (s)</td>
                                <td>Soql.RawQuery(s)</td>
                                <td>Pass <code>s</code> unmodified in an SQL query sent to the RDBMS.
                                    <p>
                                        The following example shows a typed query which uses MSSQL-specific 
                                        full-text search function <code>CONTAINS()</code>.
                                    </p>
                                    <code lang="C#">
                                        Contact.GetList(Soql.RawQuery("contains(*,'quick')"));
                                    </code>
                                    <p>
                                        It is equivalent to this SOQL query:
                                    </p>
                                    <code lang="SQL">
                                        select * 
                                        from   Contact
                                        where  rawquery(contains(*,'quick'))
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>soodaclass</td>
                                <td>SoodaClass property</td>
                                <td>Gets the concrete class name of the object as defined in the <a href="#schema">mapping schema</a>.
                                    <p>
                                        The following typed query retrieves a list of vehicles which are bikes or boats.
                                    </p>
                                    <code lang="C#">
                                        Vehicle.GetList(VehicleField.SoodaClass.In("Bike","Boat"))
                                    </code>
                                    <p>
                                        It is equivalent to this SOQL query:
                                    </p>
                                    <code lang="SQL">
                                        select *
                                        from Vehicle
                                        where SoodaClass in ('Bike','Boat')
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>in (subquery)</td>
                                <td>not supported</td>
                                <td>This feature is not supported in typed queries. You can use SoqlParser to parse it from a textual representation.</td>
                            </tr>
                            <tr>
                                <td>exists (subquery)</td>
                                <td>not supported</td>
                                <td>This feature is not supported in typed queries. You can use SoqlParser to parse it from a textual representation.</td>
                            </tr>
                            <tr>
                                <td>positional parameters: {0}, {1}, {2}</td>
                                <td>Soql.Param(0), Soql.Param(1), Soql.Param(2)</td>
                                <td>Reference to the positional parameter passed to the <code>SoodaWhereClause</code> constructor.
                                    Positional parameters are not usually needed in typed queries because string literals
                                    are safe by default.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Examples of queries that can be formulated with typed queries include:
                </p>
                <code lang="C#">
                    // find all contacts named 'Mary Manager'
                    Contact.GetList(ContactField.Name == "Mary Manager");

                    // find all contacts whose name starts with 'Mary' (using LIKE operator)
                    Contact.GetList(ContactField.Name.Like("Mary%"));

                    // find all employees hired in the last year
                    Employee.GetList(EmployeeField.HireDate > DateTime.Now.AddYears(-1));

                    // find all groups having at least one contact
                    Group.GetList(GroupField.Members.Count > 1);

                    // find all groups that Mary Manager is a member of
                    Group.GetList(GroupField.Members.ContainsContactWhere(ContactField.Name == "Mary Manager"));

                    // find all employees 
                    Employee.GetList(1 == 1);
                    Employee.GetList(true);

                    // return an empty list of employees by executing
                    // a database query with a WHERE clause that is never true.
                    // The same thing can be achieved without a database query
                    // by creating a new EmployeeList() object.
                    Employee.GetList(false);

                    // return a list of contacts who do not belong to any group
                    Contact.GetList(ContactField.PrimaryGroup.IsNull());

                    // find all contacts where Name is different from (FirstName + ' ' + LastName)
                    Contact.GetList(ContactField.Name != ContactField.FirstName + " " + ContactField.LastName);

                    // find all groups managed by Mary Manager (using named constant)
                    Group.GetList(GroupField.Manager == Contact.Mary);
                </code>
            </body>
        </section>
        <section id="linq">
            <title>Language Integrated Query - LINQ</title>
            <body>
                <p>
                    Sooda now supports LINQ, which has become the standard query language in .NET 3.5.
                    LINQ has all the benefits of Typed Queries, which existed in Sooda before LINQ appeared.
                    It is recommended that you use LINQ for all new code.
                    Typed Queries remain in Sooda for backward compatibility.
                </p>
            </body>
            <section id="linqsources">
                <title>LINQ sources</title>
                <body>
                    <p>
                        Each Sooda class contains a method called <code>Linq()</code>
                        which is the root of all LINQ queries.
                        If not followed by LINQ methods, <code>Linq()</code> returns all objects of the given class:
                    </p>
                    <code lang="C#">
                        foreach (Contact c in Contact.Linq())
                            Console.WriteLine(c.Name);
                    </code>
                    <p>
                        The <code>Linq()</code> method is overloaded and you can pass a <code>SoodaTransaction</code>
                        and <a href="#loadingbyquery">SoodaSnapshotOptions</a> to it:
                    </p>
                    <code lang="C#">
                        foreach (Contact c in Contact.Linq(SoodaSnapshotOptions.NoWriteObjects))
                            Console.WriteLine(c.Name);
                    </code>
                    <code lang="C#">
                        foreach (Contact c in Contact.Linq(transaction, SoodaSnapshotOptions.Default))
                            Console.WriteLine(c.Name);
                    </code>
                    <p>
                        The <code>AllQuery</code> property is a synonim for the <code>Linq()</code> method:
                    </p>
                    <code lang="C#">
                        foreach (Contact c in Contact.AllQuery)
                            Console.WriteLine(c.Name);
                    </code>
                    <p>
                        Each 1-N and N-N relation has a corresponding LINQ source exposed as a property composed
                        of the relation name with the <code>Query</code> suffix:
                    </p>
                    <code lang="C#">
                        Contact boss = Contact.GetRef(1);
                        foreach (Contact c in c.SubordinatesQuery)
                            Console.WriteLine(c.Name);
                    </code>
                    <p>
                        LINQ methods described below become available on LINQ sources
                        as you import the <code>System.Linq</code> namespace
                        (note <code>System.Linq</code> and not <code>Sooda.Linq</code>).
                        This is necessary for all LINQ queries except for the trivial cases such as the above.
                    </p>
                </body>
            </section>
            <section id="linqqueries">
                <title>LINQ queries</title>
                <body>
                    <p>
                        There are two ways of writing LINQ queries: method calls and LINQ keywords.
                        These two are equivalent: the C#/VB.NET compiler translates LINQ keywords to method calls.
                    </p>
                    <p>
                        Let's start with method calls. Most LINQ methods accept <i>lambda expressions</i>
                        where the only parameter is the so called <i>range variable</i>.
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Name == "Mary Manager");
                    ]]></code>
                    <p>
                        In the above code, the <code>Where()</code> method is called with the lambda expression
                        <code><![CDATA[c => c.Name == "Mary Manager"]]></code>.
                        In this expression, <code>c</code> is the range variable and
                        <code>c.Name == "Mary Manager"</code> is the <i>body</i> of the lambda expression.
                        This code is equivalent to:
                    </p>
                    <code lang="C#">
                        Contact.GetList(ContactField.Name == "Mary Manager");
                    </code>
                    <p>
                        The body of the lambda expression is specified in C#.
                        Therefore you get the advantages of compile-time type checking which can detect
                        errors such as misspelled property names and type mismatch
                        (e.g. comparing an integer field to a string).
                        However, you need to be aware that this code gets translated to SQL
                        and executed by the database engine. If you use a construct that cannot be
                        translated to SQL, you will get a <b>runtime</b> error.
                        Therefore you must write lambda expressions carefully.
                        <a href="#linqexpressions">A section below</a> lists the supported constructs.
                        When in doubt, always test your code.
                    </p>
                    <p>
                        The <code>Where()</code> method that we saw in the example is used to filter rows,
                        just like SQL <code>WHERE</code>.
                    </p>
                    <p>
                        To sort results, use <code>OrderBy()</code> and <code>OrderByDescending()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().OrderBy(c => c.Name);
                        Contact.Linq().OrderByDescending(c => c.ContactId);
                    ]]></code>
                    <p>
                        If you chain <code>OrderBy()</code> calls, they will be executed in order:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().OrderByDescending(c => c.ContactId).OrderBy(c => c.Name);
                    ]]></code>
                    <p>
                        Here, the list is first sorted by <code>ContactId</code> and then sorted again by <code>Name</code>.
                        The result is that <code>Name</code> has priority for ordering.
                        To write multiple order expressions as you are used to,
                        use <code>ThenBy()</code> and <code>ThenByDescending()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().OrderBy(c => c.Name).ThenByDescending(c => c.ContactId);
                        // same result as in the previous example
                    ]]></code>
                    <p>
                        Or, using LINQ keywords (more about them later):
                    </p>
                    <code lang="C#">
                        from c in Contact.Linq()
                        orderby c.Name, c.ContactId descending
                        select c;
                        // ditto
                    </code>
                    <p>
                        <code>Select()</code> can be used to transform Sooda objects into any .NET object you want:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Select(c => c.Name);
                        Contact.Linq().Select(c => new { Id = c.ContactId, Name = c.Name);
                    ]]></code>
                    <p>
                        <code>Select()</code> fetches only the mentioned data from the database
                        and skips the Sooda collection cache.
                    </p>
                    <p>
                        To limit the number of rows, use <code>Skip()</code> and <code>Take()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().OrderBy(c => c.Name).Skip(30).Take(10);
                    ]]></code>
                    <p>
                        There are syntax extensions to C# and VB.NET that make LINQ queries
                        look like SQL queries:
                    </p>
                    <code lang="C#"><![CDATA[
                        from c in Contact.Linq()
                        where c.Active && c != Contact.Mary
                        orderby c.LastSalary.Value descending, c.Name
                        select c.ContactId;
                    ]]></code>
                    <p>
                        <code>from</code> must come first, and <code>select</code> must come last.
                        The C# compiler will replace the above query with method calls:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq()
                        .Where(c => c.Active && c != Contact.Mary)
                        .OrderByDescending(c => c.LastSalary.Value).ThenBy(c => c.Name)
                        .Select(c => c.ContactId);
                    ]]></code>
                    <p>
                        There are LINQ keywords for some, but not all LINQ methods.
                        Sooda supports:
                    </p>
                    <ul>
                        <li><code>from ... in ...</code> - doesn't correspond to any method,
                            but merely introduces a LINQ source and a range variable</li>
                        <li><code>where</code> - corresponds to <code>Where()</code></li>
                        <li><code>orderby</code>, <code>ascending</code> (default), <code>descending</code>
                            - correspond to <code>OrderBy()</code>, <code>OrderByDescending()</code>,
                        <code>ThenBy()</code>, <code>ThenByDescending()</code></li>
                        <li><code>select</code> - corresponds to <code>Select()</code>,
                            except when given just the range variable
                            (<code>select</code> is mandatory in the C# LINQ keyword syntax)</li>
                        <li><code>group ... by ... into ...</code> - corresponds to <code>GroupBy()</code></li>
                    </ul>
                    <p>
                        Sooda doesn't support <code>join ... in ... on ... equals ...</code>
                        nor <code>let</code> LINQ keywords.
                    </p>
                    <p>
                        These were the most commonly used LINQ query methods.
                        The methods below might be useful especially when you build queries dynamically.
                    </p>
                    <p>
                        <code>Reverse()</code> reverses the order of results.
                    </p>
                    <p>
                        <code>OfType&lt;NewType&gt;()</code> filters results by their type, for example:
                    </p>
                    <code lang="C#"><![CDATA[
                        var vehicles = Vehicle.Linq().Where(v => v.Owner == Contact.Mary);
                        var cars = vehicles.OfType<Car>();
                        var bikes = vehicles.OfType<Bike>();
                    ]]></code>
                    <p>
                        <code>Except()</code>, <code>Intersect()</code> and <code>Union()</code>
                        are set operations on two queries:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.Any())
                        .Union(Contact.Linq().Where(c => c.LastSalary.Value > 100));
                    ]]></code>
                    <p>
                        or a query and a collection of objects:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Name.Like("E%")
                        .Except(new Contact[] { Contact.Ed });
                    ]]></code>
                    <p>
                        <code>Select()</code> has an overload that passes a zero-based row index
                        to the lambda expression:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Select((c, i) => new { RowNum = i, Name = c.Name });
                    ]]></code>
                    <p>
                        <code>Distinct()</code> can be applied on the result of <code>Select()</code>
                        in order to filter out duplicates:
                    </p>
                    <code lang="C#"><![CDATA[
                        IEnumerable<Contact> owners = Vehicle().Linq().Select(v => v.Owner).Distinct();
                    ]]></code>
                    <p>
                        Use <code>GroupBy()</code> for aggregate queries. <code>GroupBy()</code> must be followed by a <code>Select()</code>
                        and possibly <code>OrderBy()</code> and <code>Where()</code>. The result of <code>GroupBy()</code> is a <i>sequence</i>
                        of <code>IGrouping&lt;TKey, TElement&gt;</code>, of which you can access:
                    </p>
                    <ul>
                        <li><code>Key</code> - the grouping key</li>
                        <li>aggregates: <code>Count()</code>, <code>Count(predicate)</code>, <code>Min(selector)</code>, <code>Max(selector)</code>,
                        <code>Sum(selector)</code>, <code>Average(selector)</code>, <code>Any(predicate)</code>, <code>All(predicate)</code></li>
                    </ul>
                    <code lang="C#"><![CDATA[
                        var contactTypes = Contact.Linq().GroupBy(c => c.Type.Code).OrderBy(g => g.Key).Select(g => new { Type = g.Key, Count = g.Count() });
                        var contactTypes2 = from c in Contact.Linq() group c by c.Type.Code into g orderby g.Key select new { Type = g.Key, Count = g.Count() }; // same
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        var averageSalaryByContactType =
                            from c in Contact.Linq()
                            group c by c.Type.Code into g
                            orderby g.Key
                            select new { Type = g.Key, AvgSalary = g.Average(c => c.LastSalary.Value) };
                    ]]></code>
                    <p>
                        To group by multiple expressions, use anonymous type as the key:
                    </p>
                    <code lang="C#"><![CDATA[
                        var cheapestProducts =
                            from p in Product.Linq()
                            group p by new { p.Category, p.Vendor } into g
                            orderby g.Count() descending, g.Key.Category, g.Key.Vendor
                            select new { g.Key.Category, g.Key.Vendor, g.Count() };
                    ]]></code>
                </body>
            </section>
            <section id="linqdeferred">
                <title>Deferred query execution</title>
                <body>
                    <p>
                        It is important to understand <b>when</b> LINQ queries are executed.
                        Methods such as <code>Where()</code>, <code>Select()</code> and <code>OrderBy()</code>
                        construct queries but <b>do not</b> execute them nor even translate to SQL.
                    </p>
                    <code lang="C#"><![CDATA[
                        {
                            IEnumerable<Contact> ce = Contact.Linq().Where(c => c.Name == "Mary Manager");
                        }
                    ]]></code>
                    <p>
                        This code constructed a query, but didn't execute it.
                        Queries that return a sequence of objects (<code><![CDATA[IEnumerable<T>]]></code>)
                        get translated to SQL and executed as late as the sequence is enumerated.
                    </p>
                    <code lang="C#"><![CDATA[
                        IEnumerable<Contact> ce = Contact.Linq().Where(c => c.Subordinates.Any());
                        // no database access yet
                        // ...
                        foreach (Contact c in ce) // query gets translated to SQL and executed as soon as we reach "foreach"
                        {
                            Console.WriteLine(c.Name);
                        }
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        IEnumerable<Contact> ce = Contact.Linq().Where(c => c.Subordinates.Any());
                        for (int i = 0; i < 1000; i++)
                        {
                            // BAD idea: 1000 queries (subject to Sooda cache)
                            foreach (Contact c in ce)
                            {
                                Console.WriteLine(c.Name);
                            }
                        }
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        // CORRECT: one query inside ToList()
                        List<Contact> cl = Contact.Linq().Where(c => c.Subordinates.Any()).ToList();
                        for (int i = 0; i < 1000; i++)
                        {
                            foreach (Contact c in cl)
                            {
                                Console.WriteLine(c.Name);
                            }
                        }
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        // even better: only fetch data we need
                        List<string> sl = Contact.Linq().Where(c => c.Subordinates.Any()).Select(c => c.Name).ToList();
                        for (int i = 0; i < 1000; i++)
                        {
                            foreach (string s in sl)
                            {
                                Console.WriteLine(s);
                            }
                        }
                    ]]></code>
                    <p>
                        As a rule of thumb, if you need to iterate LINQ query results more than once,
                        you should materialize the results to a collection and then iterate over this collection.
                        The most efficient way is calling <code>ToList()</code> to get a generic list.
                        Alternatively you may call <code>ToArray()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact[] ca = Contact.Linq().OrderBy(c => c.Name).ToArray();
                    ]]></code>
                    <p>
                        Using LINQ with Sooda lists, such as <code>ContactList</code>, is discouraged.
                        However you may need them for interoperability with legacy code.
                        To convert LINQ query results to a Sooda list, import <code>Sooda.Linq</code>
                        (in addition to the usual <code>System.Linq</code>), call <code>ToSoodaObjectList()</code>
                        and pass the result to a Sooda list constructor:
                    </p>
                    <code lang="C#"><![CDATA[
                        using Sooda.Linq;
                        ContactList cl = new ContactList(Contact.Linq().OrderByDescending(c => c.ContactId).ToSoodaObjectList());
                    ]]></code>
                    <p>
                        This technique is not limited to LINQ.
                        You may use <code>ToSoodaObjectList()</code> to convert any generic collections,
                        such as <code><![CDATA[List<Contact>]]></code>, to Sooda lists.
                    </p>
                    <p>
                        Another interesting fact is that .NET execution of the lambda expressions
                        takes place during query execution, not construction:
                    </p>
                    <code lang="C#"><![CDATA[
                        string nameFilter = "Unused";
                        var ce = Contact.Linq().Where(c => c.Name == nameFilter);
                        nameFilter = "Mary Manager";
                        Assert.AreEqual("Mary Manager", ce.First().Name); // First() (see below) executes the query and uses current values of variables
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        var ce = Contact.Linq().Where(c => c.Name == MyMethod());
                        // MyMethod() not called yet
                        string result = ce.First().Name; // MyMethod() called from First()
                    ]]></code>
                    <p>
                        Sometimes you may want to build LINQ queries dynamically, e.g.
                    </p>
                    <code lang="C#"><![CDATA[
                        var query = Contact.Linq().OrderBy(c => c.Id);
                        if (nameFilter != null)
                            query = query.Where(c => c.Name == nameFilter);
                        foreach (Contact c in query)
                        {
                            ...
                        }
                    ]]></code>
                    <p>
                        The key thing here is the type of the <code>query</code> variable.
                        If you want LINQ methods to build the query for the database,
                        use <code>var</code> or <code><![CDATA[IQueryable<...>]]></code>.
                        In contrast, the following code will fetch all Contacts
                        from the database and do the filtering on the .NET side
                        (using LINQ2Objects):
                    </p>
                    <code lang="C#"><![CDATA[
                        IEnumerable<Contact> query = Contact.Linq().OrderBy(c => c.Id);
                        if (nameFilter != null)
                        {
                            // BAD idea: this is Enumerable.Where method
                            // which will execute the above query first
                            // and then do the filtering in memory.
                            query = query.Where(c => c.Name == nameFilter);
                        }
                        foreach (Contact c in query)
                        {
                            ...
                        }
                    ]]></code>
                    <p>
                        Deferred query execution applies only to methods that return a sequence of objects.
                        Below are described methods that return <a href="#linqsingle">single objects</a>
                        and <a href="#linqscalar">scalar results</a> - these methods actually execute queries
                        instead of constructing it.
                    </p>
                </body>
            </section>
            <section id="linqsingle">
                <title>Querying for single objects</title>
                <body>
                    <p>
                        Often you need a single object that meets the specific criteria.
                        There are LINQ methods that return a single object instead of a list.
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact c = Contact.Linq().OrderByDescending(c => c.LastSalary.Value).First();
                    ]]></code>
                    <p>
                        This code will return a person with highest last salary.
                        It throws <code>InvalidOperationException</code> if there are no Contacts.
                        If you want a <code>null</code> instead, use <code>FirstOrDefault()</code>
                        (origin of this name: <i>default</i> value for reference objects is <code>null</code>).
                        You may also want to use <code>Last()</code> or <code>LastOrDefault()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact c = Contact.Linq().OrderBy(c => c.LastSalary.Value).LastOrDefault();
                    ]]></code>
                    <p>
                        To make sure there is exactly one object that meets the criteria,
                        use <code>Single()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact c = Contact.Linq().Where(c => c.Name == "Mary Manager").Single();
                    ]]></code>
                    <p>
                        <code>Single()</code> throws an <code>InvalidOperationException</code>
                        if there isn't one match. <code>SingleOrDefault</code> will return
                        <code>null</code> if there are no matches, but still throw
                        <code>InvalidOperationException</code> if there is more than one match.
                    </p>
                    <p>
                        You almost certainly need a filter for <code>Single()</code>,
                        thus this method is overloaded:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact c = Contact.Linq().Single(c => c.Name == "Mary Manager");
                    ]]></code>
                    <p>
                        There are also overloads of <code>First()</code>, <code>FirstOrDefault()</code>,
                        <code>Last()</code>, <code>LastOrDefault()</code> that accept a filter.
                    </p>
                    <p>
                        In total, there are six methods, each with two overloads. The pattern is:
                        <code>{First|Last|Single}[OrDefault]([filter])</code>
                    </p>
                    <p>
                        The "OrDefault" methods can be used in <i>subqueries</i>.
                        The following code lists a name of the top paid <code>Contact</code> for each <code>ContactType</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        IEnumerable<string> se =
                            from t in ContactType.Linq()
                            orderby t.Code
                            select
                                (from c in Contact.Linq()
                                where c.Type == t
                                orderby c.LastSalary.Value
                                select c.Name).LastOrDefault();
                    ]]></code>
                    <p>
                        Note how the subquery uses the range variable of the outer query (<code>t</code> in this case).
                    </p>
                </body>
            </section>
            <section id="linqscalar">
                <title>Scalar queries</title>
                <body>
                    <p>
                        Many times you want to ask about the number of objects,
                        not caring about their contents. Use <code>Count()</code> for that:
                    </p>
                    <code lang="C#"><![CDATA[
                        int c = Contact.Linq().Where(c => c.LastSalary.Value > 100).Count();
                    ]]></code>
                    <p>
                        <code>Count()</code> also has an overload that accepts a filter:
                    </p>
                    <code lang="C#"><![CDATA[
                        int c = Contact.Linq().Count(c => c.LastSalary.Value > 100); // same as above
                    ]]></code>
                    <p>
                        If all you care is whether the count is zero or not,
                        <code>Any()</code> performs better:
                    </p>
                    <code lang="C#"><![CDATA[
                        bool b = Contact.Linq().Where(c => c.LastSalary.Value > 100).Any();
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        bool b = Contact.Linq().Any(c => c.LastSalary.Value > 100);
                    ]]></code>
                    <p>
                        You may also ask if all objects meet some criteria:
                    </p>
                    <code lang="C#"><![CDATA[
                        bool b = Contact.Linq().All(c => c.LastSalary.Value > 100);
                    ]]></code>
                    <p>
                        Use <code>Contains()</code> to check if the query would return a specific Sooda object:
                    </p>
                    <code lang="C#"><![CDATA[
                        bool b = Contact.Linq().Where(c => c.LastSalary.Value > 100).Contains(Contact.Mary);
                        // this example wasn't clever, because you could simply write: Contact.Mary.LastSalary.Value > 100
                    ]]></code>
                    <p>
                        There are also aggregate functions: <code>Average()</code>, <code>Min()</code>,
                        <code>Max()</code> and <code>Sum()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        decimal avgSalary = Contact.Linq().Average(c => c.LastSalary.Value);
                        decimal minEmployeeSalary = Contact.Linq().Where(c => c.Type == ContactType.Employee).Min(c => c.LastSalary.Value);
                        decimal maxManagerSalary = Contact.Linq().Where(c => c.Type == ContactType.Manager).Max(c => c.LastSalary.Value);
                        decimal maxManagerSalary2 = (from c in Contact.Linq() where c.Type == ContactType.Manager select c.LastSalary.Value).Max(); // same as above
                        decimal totalSalary = Contact.Linq().Sum(c => c.LastSalary.Value);
                    ]]></code>
                    <p>
                        If there are no objects for calculation, <code>Average()</code>, <code>Min()</code>
                        and <code>Max()</code> throw <code>InvalidOperationException</code>
                        whereas <code>Sum()</code> returns zero.
                    </p>
                    <p>
                        <code>Count()</code>, <code>Any()</code>, <code>All()</code>, <code>Contains()</code>,
                        <code>Average()</code>, <code>Min()</code>, <code>Max()</code> and <code>Sum()</code>
                        can also be used in subqueries.
                        The following query calculates top salary per <code>ContactType</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        var q =
                            from t in ContactType.Linq()
                            orderby t.Code
                            select new {
                                    ContactType = t.Code,
                                    TopSalary = Contact.Linq().Where(c => c.Type == t).Max(c => c.LastSalary.Value)
                                };
                    ]]></code>
                </body>
            </section>
            <section id="linqexpressions">
                <title>LINQ expressions</title>
                <body>
                    <p>
                        This section describes the subset of C# which Sooda can translate to SQL.
                    </p>
                    <p>
                        Path expressions are same as in SOQL, except that they start with a range variable:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Name == "Mary Manager");
                        Contact.Linq().Where(c => c.Manager.PrimaryGroup.Id == 10);
                    ]]></code>
                    <p>
                        For comparisons, use C# operators: ==, !=, &lt;, &lt;=, &gt;, &gt;=.
                        However, if your field is of a SqlType, you need to compare the <code>Value</code> property:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.LastSalary.Value > 123);
                    ]]></code>
                    <p>
                        Logical operators are: &amp;&amp;, ||, ! and a?b:c.
                        On numbers you may use arithmetic operators: +, -, *, /, % (modulo) and unary negation (-).
                        You can concatenate strings with the + operator.
                    </p>
                    <p>
                        The syntax of null tests depends on the field type.
                        You do the tests just like you would normally do in C#:
                    </p>
                    <ul>
                        <li>For reference types, compare with <code>null</code>.</li>
                        <li>For SqlTypes, check the <code>IsNull</code> property.</li>
                        <li>For Nullables, check the <code>HasValue</code> property.</li>
                    </ul>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Manager != null);
                        Contact.Linq().Where(c => !c.LastSalary.IsNull); // if using SqlTypes
                        Contact.Linq().Where(c => c.LastSalary.HasValue); // if using Nullable
                    ]]></code>
                    <p>
                        Sooda detects subexpressions that can be evaluated on the .NET side, before constructing the SQL.
                        For example:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Name == myVariable.MyMethod().MyOtherMethod());
                    ]]></code>
                    <p>
                        Here the SQL translation of <code>myVariable.MyMethod().MyOtherMethod()</code> is just a string literal
                        that is the result of this expression computed in .NET.
                        Remember about <a href="#linqdeferred">deferred query execution</a>.
                    </p>
                    <p>
                        To use the SQL LIKE operator, you need to import the <code>Sooda.Linq</code> namespace
                        (in addition to the usual <code>System.Linq</code>):
                    </p>
                    <code lang="C#"><![CDATA[
                        using Sooda.Linq;
                        Contact.Linq().Where(c => c.Name.Like("C%"));
                        // as a bonus, the Like() method becomes available on all .NET strings
                        bool ok = "Foo".Like("%o"); // computed in .NET, not the database engine
                    ]]></code>
                    <p>
                        Collection sizes are available either through the <code>Count</code> property
                        or the <code>Count()</code> LINQ extension method:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.Count == 2);
                        Contact.Linq().Where(c => c.Subordinates.Count() == 2); // same
                    ]]></code>
                    <p>
                        It makes no difference if you query for collection properties with or without the <code>Query</code> suffix:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.SubordinatesQuery.Count() == 2); // same as above
                    ]]></code>
                    <p>
                        You may test if collections contain a specific object:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.Contains(Contact.Ed));
                    ]]></code>
                    <p>
                        For more sophisticated collection tests, use <code>Any()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.Any(s => s.Name == "Ed Employee"));
                    ]]></code>
                    <p>
                        The above code was the LINQ counterpart to:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.GetList(ContactField.Subordinates.ContainsContactWhere(ContactField.Name == "Ed Employee"));
                    ]]></code>
                    <p>
                        The SQL/SOQL <code>IN</code> operator is expressed with the .NET <code>Contains()</code> method:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => new Contact[] { Contact.Mary, Contact.Ed }.Contains(c.Manager));
                    ]]></code>
                    <p>
                        which is equivalent to the Typed Query:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.GetList(ContactField.Manager.In(Contact.Mary, Contact.Ed));
                    ]]></code>
                    <p>
                        The <a href="#soqlsoodaclass">SoodaClass</a> property known from SOQL is written in LINQ as <code>GetType().Name</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Vehicle.Linq().Where(c => c.GetType().Name == "Car");
                    ]]></code>
                    <p>
                        The following constructs are unique to LINQ and have no SOQL counterparts.
                    </p>
                    <p>
                        ?? is the C#'s null-coalesce operator. When used in queries, it gets translated to SQL <code>COALESCE</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => (c.Manager ?? c.PrimaryGroup.Manager) == Contact.Mary);
                    ]]></code>
                    <p>
                        You may use the "is" type-test operator:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Vehicles.Any(v => v is Bike || c == Contact.Mary));
                    ]]></code>
                    <p>
                        Instead of comparing collection size against zero, you may use <code>Any()</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.Any());
                        // same as Contact.Linq().Where(c => c.Subordinates.Count > 0);
                    ]]></code>
                    <p>
                        <code>All()</code> is available for collections as well:
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => c.Subordinates.All(s => s.LastSalary.Value > 100));
                    ]]></code>
                    <p>
                        <code>GetPrimaryKeyValue()</code> is a generic way to access the primary key.
                    </p>
                    <p>
                        <code>GetLabel()</code> returns SoodaObject's label, as specified in the <a href="#schemaclasses">database schema</a>.
                        The boolean argument to <code>GetLabel()</code>is ignored in LINQ queries.
                    </p>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Select(c => new { ClassName = c.GetType().Name, Id = c.GetPrimaryKeyValue(), Label = c.GetLabel(false) );
                    ]]></code>
                    <code lang="C#"><![CDATA[
                        Contact.Linq().Where(c => (int) c.GetPrimaryKeyValue() > 3);
                    ]]></code>
                    <p>
                        The following string methods may be used: <code>Concat()</code>,
                        <code>IsNullOrEmpty()</code>, <code>Remove()</code>,
                        <code>Substring(startIndex, length)</code>,
                        <code>Replace()</code>, <code>ToLower()</code> and <code>ToUpper()</code>.
                        <code>StartsWith()</code>, <code>EndsWith()</code> and <code>Contains()</code>
                        can be used with the restriction that the argument cannot come from the database.
                    </p>
                    <p>
                        You can call <code>ToString()</code> on int, long, double, decimal and bool expressions.
                    </p>
                    <p>
                        Also, some static methods from the <code>System.Math</code> class are supported:
                        <code>Abs()</code>, <code>Acos()</code>, <code>Asin()</code>, <code>Atan()</code>,
                        <code>Cos()</code>, <code>Exp()</code>, <code>Floor()</code>, <code>Pow()</code>,
                        <code>Round()</code>, <code>Sign()</code>, <code>Sin()</code>, <code>Sqrt()</code>,
                        <code>Tan()</code>, however their support in databases other than SQL Server hasn't been verified.
                    </p>
                    <p>
                        Methods not mentioned above have no translation to SQL.
                        It is safe to call them if they can be evaluated before the SQL translation,
                        and in <code>Select()</code>.
                    </p>
                    <p>
                        You can also provide an extra method/property that returns a LINQ expression corresponding to your custom method/property.
                        This LINQ expression can then be translated to SQL.
                    </p>
                    <p>
                        Let's start with properties, which are simpler because they don't have parameters.
                        To specify an expression that corresponds to a property, create a <code>public static</code> property
                        which is by convention named the same as your custom property plus the <code>Expression</code> suffix.
                        The getter of the expression property must return <code><![CDATA[Expression<Func<TClass,TResult>]]></code>
                        where <code>TClass</code> is the class the properties are defined in and <code>TResult</code> is the type of your custom property.
                        Example for a property in the <code>Contact</code> class:
                    </p>
                    <code lang="C#"><![CDATA[
                        public string NameAndType
                        {
                            get
                            {
                                return Name + " (" + Type.Code + ")";
                            }
                        }

                        public static Expression<Func<Contact, string>> NameAndTypeExpression
                        {
                            get
                            {
                                return t => t.Name + " (" + t.Type.Code + ")";
                            }
                        }
                    ]]></code>
                    <p>
                        With the above code you can use <code>NameAndType</code> anywhere in LINQ and it will get translated to SQL.
                    </p>
                    <p>
                        Defining expressions for custom methods is similar: you write a method named with the <code>Expression</code> suffix.
                        If your custom method is not overloaded, you can keep the expression method parameterless.
                        Otherwise, use same parameter types as in your custom method.
                        Never use the parameters in the expression method. Instead, specify the corresponding parameters in the lambda expression.
                    </p>
                    <code lang="C#"><![CDATA[
                        public static double CircleArea(double r)
                        {
                            return Math.PI * r * r;
                        }

                        public static Expression<Func<double, double>> CircleAreaExpression(double dummyR)
                        {
                            return r => Math.PI * r * r;
                        }
                    ]]></code>
                    <p>
                        If the custom method is not static, the first lambda parameter must correspond to <code>this</code>:
                    </p>
                    <code lang="C#"><![CDATA[
                        public bool EarnsMoreThan(Contact other)
                        {
                            return this.LastSalary.HasValue && other.LastSalary.HasValue && this.LastSalary.Value > other.LastSalary.Value;
                        }

                        public static Expression<Func<Contact, Contact, bool>> EarnsMoreThan()
                        {
                            return (t, other) => t.LastSalary.HasValue && other.LastSalary.HasValue && t.LastSalary.Value > other.LastSalary.Value;
                        }
                    ]]></code>
                </body>
            </section>
        </section>
    </section>
    <section id="advancedtopics">
        <title>Advanced Topics</title>
        <body>
            <p>
                Information provided in the following sections can be useful if you want to understand the inner workings of Sooda or to perform advanced
                tasks using the command line tools that come with Sooda.
            </p>
        </body>
        <section id="tools">
            <title>Tools</title>
            <body>
                <p>
                    Sooda provides command-line tools that are used during the <a href="#compilationprocess">build process</a> to create
                    a Data Access Layer library and some additional tools that can help you manage <a href="#schema">mapping schema files</a>. 
                    The following sections explain each tool and provide guidelines for their use.
                </p>
            </body>
            <section id="soodastubgen">
                <title>SoodaStubGen</title>
                <body>
                    <p>
                        SoodaStubGen utility is responsible for generating stub code for a Data Access Layer. The generated code needs
                        to be compiled with the rest of the application code as described <sectionlink id="compilationprocess" />.

                        You usually invoke SoodaStubGen as part of your automated build process to ensure that the 
                        <a href="#generatedcode">generated code</a> is in sync with the <a href="#schema">mapping schema</a>.
                        Visual Studio 2003 and 2005 are also supported.
                    </p>
                    <p>
                        This section describes command line options supported by SoodaStubGen and provides guidelines on
                        usage of this tool.
                    </p>
                </body>
                <section id="soodastubgenlocation">
                    <title>Install Location</title>
                    <body>
                        <p>
                            By default SoodaStubGen is installed in:
                        </p>
                        <code lang="C#">
                            %SOODA_DIR%\bin\net-2.0\SoodaStubGen.exe
                        </code>
                        <p>
                            <code>%SOODA_DIR%</code> is Sooda installation path. Sooda Installer registers the <code>SOODA_DIR</code> 
                            environment variable to point to this directory so you can use <code>%SOODA_DIR%</code> instead 
                            of specifying the exact path in your build file.
                        </p>
                        <p>
                            If your project relies on a specific version of Sooda it is recommended to create a local copy
                            of the <code>%SOODA_DIR%\bin\net-X.Y</code> directory within your source code structure and
                            use relative paths.
                        </p>
                    </body>
                </section>
                <section id="soodastubgenoptions">
                    <title>Command-line options</title>
                    <body>
                        <p>
                            Options to SoodaStubGen can be passed in a <a href="#soodaproject">*.soodaproject</a> file 
                            or directly as command line parameters. The latter option is available for compatibility with older versions
                            of Sooda and using Sooda Project files is generally recommended.
                        </p>
                        <p>
                            SoodaStubGen.exe usage is:
                        </p>
                        <code lang="C#">
                            SoodaStubGen.exe path_to_soodaproject_file
                        </code>
                        <p>
                            <code>path_to_soodaproject_file</code> is a full path to a *.soodaproject file. Sooda Project files are described <sectionlink id="soodaproject" />.
                            If you prefer to use command-line options, the usage is:
                        </p>
                        <code lang="C#">
                            SoodaStubGen.exe [options]
                        </code>
                        <p>
                            <code>[options]</code> represents a whitespace-separated sequence of options.
                            Most options have equivalent Sooda Project settings which are described <sectionlink id="soodaproject" />. 
                            The following options are available:
                        </p>
                        <ul>
                            <li><code>--schema schemafile.xml</code> - path to schema file - equivalent to <x><schema-file /></x></li>
                            <li><code>--namespace NS</code> - output namespace - equivalent to <x><output-namespace /></x></li>
                            <li><code>--output PATH</code> - output path - equivalent to <x><output-path /></x></li>
                            <li><code>--lang N</code> or <code>-l N</code> - sets the stub language to <code>N</code> - equivalent to <x><language /></x></li>
                            <li><code>--assembly-name assemblyname</code> - output assembly name - equivalent to <x><output-assembly /></x></li>
                            <li><code>--project T</code> or <code>-p T</code> - sets external project type to <code>T</code> - equivalent to <x><external-projects /></x></li>
                            <li><code>--separate-subs</code> - enables <a href="#compilationprocessseparate">separate compilation of stubs</a> - equivalent to <x><stubs-compiled-separately>true</stubs-compiled-separately></x></li>
                            <li><code>--merged-subs</code> - enables <a href="#compilationprocessstandard">standard compilation of stubs</a><x><stubs-compiled-separately>false</stubs-compiled-separately></x></li>
                            <li><code>--schema-embed-xml</code> - generate <code>_DBSchema.xml</code> to be embedded in the output assembly - equivalent to <x><embedded-schema-type>Xml</embedded-schema-type></x></li>
                            <li><code>--schema-embed-bin</code> - generate <code>_DBSchema.bin</code> to be embedded in the output assembly - equivalent to <x><embedded-schema-type>Binary</embedded-schema-type></x></li>
                            <li><code>--nullable-as Boxed|Raw|RawWithIsNull|SqlType|Nullable</code> - sets the <a href="#soodaprojectprimitiverep">representation</a> of nullable fields - equivalent to <x><nullable-representation /></x></li>
                            <li><code>--not-null Boxed|Raw|RawWithIsNull|SqlType|Nullable</code> - sets the <a href="#soodaprojectprimitiverep">representation</a> of not-null fields - equivalent to <x><not-null-representation /></x></li>
                            <li><code>--base-class N</code> - use N as a base class for all generated stubs - equivalent to <x><base-class-name /></x></li>
                            <li><code>--null-propagation</code> - enable null propagation - equivalent to <x><null-propagation>true</null-propagation></x></li>
                            <li><code>--no-null-propagation</code> - disable null propagation - equivalent to <x><null-propagation>false</null-propagation></x></li>
                        </ul>
                        <p>
                            The following options have no project file equivalents:
                        </p>
                        <ul>
                            <li><code>--rebuild-if-changed</code> - rebuilds the stubs if the output files do not exist or are older than
                                the source file (schema and included files). This is the default behavior.</li>
                            <li><code>--force-rebuild</code> - rebuilds stub files unconditionally</li>
                            <li><code>--rewrite-skeletons</code> - rewrite all skeletons. <font color="red">This option destroys all customizations made to skeleton classes. Use with caution.</font></li>
                            <li><code>--rewrite-projects</code> - rewrite external project files instead of updating them <font color="red">This option destroys all non-standard project settings. Use with caution.</font></li>
                            <li><code>--write-project FN</code> - write a *.soodaproject file to the specified file</li>
                        </ul>
                    </body>
                </section>
                <section id="soodacompilestubs">
                    <title>SoodaCompileStubs</title>
                    <body>
                        <p>
                            SoodaCompileStubs utility can be used to precompile generated stubs into a separate DLL.
                            Separate stub compilation is an advanced feature of Sooda and should be used with caution as described <sectionlink id="compilationprocessseparate" />. 
                        </p>
                        <p>
                            The utility is located in the same directory as <a href="#soodastubgenlocation">SoodaStubGen</a>.
                            It is a commmand-line program (no GUI is provided) that is meant to be part of an automated build
                            process. You should run it after SoodaStubGen to automatically compile stub code generated by it.
                        </p>
                        <p>
                            The usage is:
                        </p>
                        <code lang="C#">
                            SoodaCompileStubs assembly_base_name stubs_dir [extra_files]
                        </code>
                        <ul>
                            <li><code>assembly_base_name</code> - is the base name of the output assembly.
                                SoodaCompileStubs will generate <code>assembly_base_name.Stubs.dll</code> that contains stubs for
                                skeleton classes contained in <code>assembly_base_name.dll</code>.
                            </li>
                            <li><code>stubs_dir</code> - is the path to the generated <code>Stubs</code> directory. The directory contains the following files:
                                <ul>
                                    <li>_DBSchema.bin</li>
                                    <li>_MiniSkeleton.csx</li>
                                    <li>_MiniStubs.csx</li>
                                    <li>_Stubs.csx</li>
                                </ul>
                                This set of files is generated automatically by SoodaStubGen when <x><stubs-compiled-separately /></x> parameter is set to <code>true</code>
                                or when <code>--separate-stubs</code> command line option is passed to it.
                            </li>
                            <li>
                                <code>extra_files</code> - is a list of additional source files to be compiled with the skeleton classes.
                                The files should be written in C# and they should include the same assembly-level attributes as
                                <code>assembly_base_name.dll</code> will have. It is recommended to reuse the same <code>AssemblyInfo.cs</code>
                                file for separate stub compilation and normal compilation of <code>assembly_base_name.dll</code>.
                            </li>
                        </ul>
                        <p>
                            Assuming your output DAL assembly is DAL.dll and the source files are located in the <code>DAL</code> directory,
                            typical command line options to generate DAL.Stubs.dll are:
                        </p>
                        <code lang="C#">
                            SoodaCompileStubs DAL source\DAL\Stubs source\DAL\AssemblyInfo.cs
                        </code>
                        <p>
                            When compiling the DAL.dll you should reference <code>source\DAL\Stubs\DAL.Stubs.dll</code>. It is important to
                            not to remove the <code>source\DAL\Stubs\DAL.dll</code> file as it is necessary for compilation.
                        </p>
                        <p>
                            SoodaCompileStubs checks modification dates on source files in the Stubs directory and recompiles the output only
                            if the files are newer than the resulting DLL or if the DLL does not exist.
                        </p>
                    </body>
                </section>
                <section id="soodafixkeygen">
                    <title>SoodaFixKeygen</title>
                    <body>
                        <p>
                            There are situations where you need to synchronize the contents of the <a href="#keygeneration"><code>KeyGen</code> table</a>
                            to match actual primary key values. Do this after running any SQL script that inserts new rows
                            into mapped tables. If you fail to synchronize the <code>KeyGen</code> table, Sooda will generate non-unique primary
                            keys which will cause primary key constraints to be violated.
                        </p>
                        <p>
                            For example, assume that the <code>KeyGen</code> table contains a record where key_name="Foo" and key_value="100".
                            You now run an SQL script that inserts new records into <code>Foo</code> table:
                        </p>
                        <code lang="SQL">
                            insert into Foo(id,...) values (101,...);
                            insert into Foo(id,...) values (102,...);
                            insert into Foo(id,...) values (103,...);
                            insert into Foo(id,...) values (104,...);
                            ...
                            insert into Foo(id,...) values (999,...);
                        </code>
                        <p>
                            After you do this, you need to update the appropriate KeyGen record to have key_value = 1000, because this is the next
                            value that should be generated for the primary key. If you fail to do so, newly created objects will get IDs of 100, 101, 102
                            which are invalid.
                        </p>
                        <p>
                            SoodaFixKeygen is a command-line utility that reads a <a href="#schema">mapping schema</a> file and generates an SQL
                            script to properly update the KeyGen table. The SQL is written to the specified file.
                        </p>
                        <p>
                            Usage is:
                        </p>
                        <code lang="C#">
                            SoodaFixKeygen soodaschema.xml outputFile.sql
                        </code>
                        <p>
                            After running the command, <code>outputFile.sql</code> will contain statements similar to:
                        </p>
                        <code lang="SQL">
        delete from KeyGen;
        insert into KeyGen
        select 'Role',coalesce(max(id),0) + 1 from _Role
        union
        select 'Contact',coalesce(max(id),0) + 1 from Contact
        union
        select 'Group',coalesce(max(id),0) + 1 from _Group
        union
        select 'Vehicle',coalesce(max(id),0) + 1 from Vehicle
        union
        select 'Car',coalesce(max(id),0) + 1 from Vehicle
        union
        select 'Bike',coalesce(max(id),0) + 1 from Vehicle
                        </code>
                        <p>
                            In order to properly update the KeyGen table, you should run the generated SQL code using 
                            SQL Query Analyzer or any other SQL client utility. Note that the SQL generated is specific to SQL Server, 
                            other databases may require some post-processing.
                        </p>
                    </body>
                </section>
                <section id="soodaschematool">
                    <title>SoodaSchemaTool</title>
                    <body>
                        <p>
                            SoodaSchemaTool utility can be used to perform various tasks related to <a href="#schema">mapping schema files</a>.
                        </p>
                        <ul>
                            <li>Generate SQL DDL statements from the mapping schema</li>
                        </ul>
                        <p>
                            Command-line Usage:
                        </p>
                        <code lang="C#">
                            SoodaSchemaTool command [command_options]
                        </code>
                        <p>
                            <code>command</code> is the action that should be performed, <code>command_options</code> are command-specific
                            options. The following commands are supported:
                        </p>
                        <ul>
                            <li><code>help</code> - displays an overview of available commands</li>
                            <li><code>genddl</code> - generates DDL (to create tables, public keys, foreign keys) from the mapping schema</li>
                            <li><code>genschema</code> - reverse-engineer database to create the approximate mapping schema</li>
                            <li><code>updateschema</code> - reverse-engineer database and update the mapping schema with changes made to the tables</li>
                        </ul>
                        <p>
                            The following sections describe command line options and usage information for all supported commands:
                        </p>
                    </body>
                    <section id="soodaschematoolhelp">
                        <title>help</title>
                        <body>
                            <p>
                                Usage:
                            </p>
                            <code lang="C#">
                                SoodaSchemaTool help [commandName]
                            </code>
                            <p>
                                Displays a list of available commands. When <code>commandName</code> is provided, 
                                a description of the command and a list of available options are displayed.
                            </p>
                        </body>
                    </section>
                    <section id="soodaschematoolgenddl">
                        <title>genddl</title>
                        <body>
                            <p>
                                Usage:
                            </p>
                            <code lang="C#">
                                SoodaSchemaTool genddl SoodaSchema.xml &gt; output.sql
                            </code>
                            <p>
                                Generates DDL commands to create tables, public keys, foreign keys based on the mapping schema 
                                and writes them to the standard output. The SQL uses T-SQL (Microsoft SQL-Server specific) syntax.
                                You should use shell redirection mechanism to output the SQL to a file.
                            </p>
                        </body>
                    </section>
                    <section id="soodaschematoolgenschema">
                        <title>genschema</title>
                        <body>
                            <p>
                                Usage:
                            </p>
                            <code lang="C#">
                                SoodaSchemaTool genschema -databaseType DBTYPE -connectionString CS -outputFile OF
                            </code>
                            <p>
                                Connects to the specified database and generates an approximate mapping schema file. The following parameters are accepted.
                            </p>
                            <ul>
                                <li><code>-databaseType DBTYPE</code>  - specifies database type. Currently only <code>mssql</code> is supported which 
                                    is also the default value, so you can omit this parameter when connecting to MS SQL Server</li>
                                <li><code>-connectionString CS</code> - specifies connection string. The connection string is database-dependent. 
                                    For Microsoft SQL, the connection string used for the local database named MyDatabase is:
                                    <code lang="C#">
                                        Integrated Security=true;Initial Catalog=MyDatabase;Server=.
                                    </code>
                                </li>
                                <li><code>-outputFile OF</code> - name of the output <a href="#schema">mapping schema file</a>.</li>
                            </ul>
                            <p>
                                Schema generation follows the following rules to convert between the database structure and the schema file:
                            </p>
                            <ul>
                                <li>Each database table is converted to a single <x><class /></x> based on a single <x><table /></x></li>
                                <li>Tables with no primary keys are converted with warnings. You should manually
                                    add the <code>primaryKey="true"</code> declarations to appropriate fields.</li>
                                <li>Referenced tables are detected automatically based on foreign key constraints. 
                                    Matching <x><collectionManyToMany /></x> entries are generated accordingly.</li>
                                <li>Tables which have exactly two columns that are foreign keys are converted to a <x><relation /></x> 
                                    and two <x><collectionManyToMany /></x></li>
                                <li>Inheritance is not supported.</li>
                                <li>Named constants cannot be generated automatically.</li>
                            </ul>
                        </body>
                    </section>
                    <section id="soodaschematoolupdateschema">
                        <title>updateschema</title>
                        <body>
                            <p>
                                Usage:
                            </p>
                            <code lang="C#">
                                SoodaSchemaTool updateschema -databaseType DBTYPE -connectionString CS 
                                                             -schemaFile IF [-outputSchemaFile OF]
                                                             [-updateTypes] [-updateSizes] [-updateNullable] 
                                                             [-updatePrimaryKeys] [-tableName T]
                            </code>
                            <p>
                                Connects to the specified database and updates the mapping schema file. The following parameters are accepted.
                            </p>
                            <ul>
                                <li><code>-databaseType DBTYPE</code>  - specifies database type. Currently only <code>mssql</code> is supported which 
                                    is also the default value, so you can omit this parameter when connecting to MS SQL Server</li>
                                <li><code>-connectionString CS</code> - specifies connection string. The connection string is database-dependent. 
                                    For Microsoft SQL, the connection string used for the local database named MyDatabase is:
                                    <code lang="C#">
                                        Integrated Security=true;Initial Catalog=MyDatabase;Server=.
                                    </code>
                                </li>
                                <li><code>-schemaFile IF</code> - name of the <a href="#schema">mapping schema file</a> to read.</li>
                                <li><code>-outputSchemaFile OF</code> - name of the output file to write. If not provided, the schema file is
                                    updated in place.</li>
                                <li><code>-updateTypes</code> - update <code>type</code> attribute of each <x><field /></x> based on 
                                    the actual database field types.</li>
                                <li><code>-updateSizes</code> - update <code>size</code> attribute of each <x><field /></x> based on 
                                    the actual database field sizes.</li>
                                <li><code>-updateNullable</code> - update <code>nullable</code> attribute of each <x><field /></x> based on 
                                    the actual database field nullability.</li>
                                <li><code>-updatePrimaryKeys</code> - update <code>primaryKey</code> attribute of each <x><field /></x> based on 
                                    the actual primary key constraints.</li>
                                <li><code>-tableName T</code> - limit updates to the table <code>T</code>. If you omit this parameter
                                    all <x><table /></x> elements will be updated</li>

                            </ul>
                        </body>
                    </section>
                </section>
                <!--
                <section id="soodaaddin">
                    <title>SoodaAddin</title>
                    <body>
                    </body>
                </section>
                -->
            </section>
        </section>
        <section id="logging">
            <title>Logging</title>
            <body>
                <p>
                    Logging in Sooda can be used to trace Sooda components such as transaction management, caching, 
                    data sources and SOQL to SQL conversion. Having a trace file in place can be useful for 
                    post-execution analysis of your program and to understand the inner workings of Sooda.
                </p>
                <p>
                    The following logging mechanisms are supported:
                </p>
                <ul>
                    <li><code>console</code> - write all log messages to the console</li>
                    <li><code>null</code> - no log messages are written</li>
                    <li><code>nlog</code> - use <a href="http://www.nlog-project.org/">NLog</a> to manage logs</li>
                    <li><code>log4net</code> - use <a href="http://logging.apache.org/log4net">log4net</a> to manage logs</li>
                </ul>
                <p>
                    To configure logging, add the <code>sooda.logging</code> entry to the appropriate configuration file, an application configuration file:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <appSettings>
                            <add key="sooda.logging" value="console" />
                        </appSettings>
                    </configuration>
                    ]]>
                </code>
                <p>
                    or a shared XML configuration file:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <sooda>
                            <logging>console</logging>
                        </sooda>
                    </configuration>
                    ]]>
                </code>
                <p>
                    To enable logging in code, you need to set the static <code>Implementation</code> property
                    of the <code>Sooda.Logging.LogManager</code> class to an instance of appropriate logging implementation class.
                </p>
                <ul>
                    <li><code>ConsoleLoggingImplementation</code> - for console logging</li>
                    <li><code>NullLoggingImplementation</code> - for no logging</li>
                    <li><code>NLogLoggingImplementation</code> - for logging with NLog</li>
                    <li><code>Log4NetLoggingImplementation</code> - for logging with log4net</li>
                </ul>
                <code lang="C#">
                    using Sooda.Logging;

                    class Program
                    {
                        static void Main(string[] args)
                        {
                            // turn on console logging
                            LogManager.Implementation = new ConsoleLoggingImplementation();
                        }
                    }
                </code>
                <p>
                    When using NLog or Log4Net you need to provide additional configuration files. Refer to 
                    the documentation of the product in question for more information.
                </p>
                <p>
                    To write your own logging provider, you need to create a class that implements the 
                    <code>Sooda.Logging.ILoggingImplementation</code>  interface defined by Sooda and 
                    put the fully qualified name of the class in <code>sooda.logging</code> configuration setting:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <configuration>
                        <appSettings>
                            <add key="sooda.logging" value="MyNamespace.MyLoggingProvider, MyAssembly, Version=..., PublicKeyToken=..." />
                        </appSettings>
                    </configuration>
                    ]]>
                </code>
                <p>
                    Each logging message in Sooda is associated with a source that identifies the component that emitted the log.
                    When using NLog or log4net, you can use the source to filter log messages. When console logging is used, there is no
                    way to specify which messages are emitted so it is recommended to use one of the mentioned log routing packages
                    or disable logging entirely, because emitting large amounts of tracing information can severely slow down the application.
                </p>
                <p>
                    The following sources are defined:
                </p>
                <ul>
                    <li><code>Sooda.Cache</code> - Level-2 caching related messages</li>
                    <li><code>Sooda.Config</code> - configuration-related messages</li>
                    <li><code>Sooda.FactoryCache</code> - factory cache messages</li>
                    <li><code>Sooda.ListSnapshot</code> - GetList()-related messages</li>
                    <li><code>Sooda.ManyToManyCollection</code> - many-to-many collections support</li>
                    <li><code>Sooda.OneToManyCollection</code> - one-to-many collections support</li>
                    <li><code>Sooda.Object</code> - per-object diagnostics messages (lazy loading, caching)</li>
                    <li><code>Sooda.Transaction</code> - transaction management</li>
                    <li><code>Sooda.SqlDataSource</code> - messages specific to SQL data source</li>
                    <li><code>Sooda.SQL</code> - SQL queries sent down to the RDBMS</li>
                </ul>
                <p>
                    Most logging messages are emitted with the lowest severity available (<code>Trace</code> for NLog, 
                    <code>Debug</code> for log4net), but Sooda also uses the <code>Error</code> and <code>Warning</code>
                    severities as necessary.
                </p>
                <p>
                    Typically you should keep detailed logging disabled, with the possible exception of tracing SQL queries
                    emitted through <code>Sooda.SQL</code> and increase log level to diagnose and fix bugs in your code 
                    or Sooda code. Error and warning messages should never be filtered out.
                </p>
            </body>
        </section>
        <section id="soqltosqlconversion">
            <title>SOQL to SQL Conversion</title>
            <body>
                <p>
                    Relational databases do not understand Sooda schemas nor SOQL language, 
                    therefore a translation from SOQL to SQL is necessary before any query can be executed.
                    Sooda comes with a <code>SoqlToSqlConverter</code> class that does the necessary translation.
                </p>
                <p>
                    The result of the conversion is dependent on the <a href="#schema">mapping schema</a>, because SOQL to SQL converter 
                    must translate classes to database table names and named constants to literals. As database engines implement
                    slightly different SQL dialects, you must also pass
                    an instance of an SQL builder class that implements <code>ISqlBuilder</code> interface and abstracts the SQL dialect
                    detail. Sooda comes with the following SQL builders for the most popular databases:
                </p>
                <ul>
                    <li><code>SqlServerBuilder</code> - Microsoft SQL Server 2000 and 2005</li>
                    <li><code>OracleBuilder</code> - Oracle 8i and above</li>
                    <li><code>MySqlBuilder</code> - MySQL 4.x and above</li>
                    <li><code>PostgreSqlBuilder</code> - PostgreSQL 7.3 and above</li>
                </ul>
                <p>
                    By default Sooda does the SOQL to SQL conversion automatically for all GetList-based queries.
                    <a href="#sqldatasource">Data Source</a> classes provide methods that can be used to issue
                    SOQL queries on a database. 
                    There are situations where you might want to do the conversion by hand, for example when you
                    need to modify/instrument the result of conversion before executing it.
                </p>
                <p>
                    To start the conversion, you need to pass the tree representation of your SOQL query, 
                    namely a <code>SoqlQueryExpression</code> object, obtained it by calling <code>SoqlParser.ParseQuery()</code>.
                    SoqlToSqlConverter writes the result of conversion to the specified <code>TextWriter</code> object - you can use an 
                    instance of the <code>StringWriter</code> class to store the result in a string variable.
                </p>
                <code lang="C#">
                    string soqlQueryText = "soql query";
                    SchemaInfo schemaInfo; // parsed schema

                    // SQL-Server specific SQL Builder object
                    ISqlBuilder builder = new SqlServerBuilder();

                    // parse the query
                    SoqlQueryExpression query = SoqlParser.ParseQuery(soqlQueryText);

                    // create a StringWriter to write the results to
                    StringWriter sw = new StringWriter();

                    // create an instance of converter
                    SoqlToSqlConverter converter = new SoqlToSqlConverter(sw, schemaInfo, builder);

                    // set various options
                    converter.IndentOutput = this.IndentQueries;
                    converter.GenerateColumnAliases = false;
                    converter.ConvertQuery(queryExpression);

                    // put the results in a string
                    string sqlText = sw.ToString();
                </code>
                <p>
                    The following sections provide an overview of the SOQL to SQL conversion process. 
                    Knowing the SQL that is generated from various SOQL constructs may be
                    useful to fully understand the cost of some Sooda features, but it is not
                    generally needed for normal use of Sooda.
                </p>
            </body>
            <section id="soqltosqlconversionpathexpressions">
                <title>Path Expressions</title>
                <body>
                    <p>
                        During the SOQL to SQL Translation, path expressions are converted to ordinary SQL joins.
                        Consider this example SOQL query:
                    </p>
                    <code lang="SQL">
                        SELECT *
                        FROM   Contact
                        WHERE  PrimaryGroup.Manager.Name = 'Mary Manager'
                    </code>
                    <p>
                        During conversion, each path expression prefix gets a unique table alias and appropriate joins
                        are generated:
                    </p>
                    <code lang="SQL">
select   t0.id as [ContactId],
         t0.primary_group as [PrimaryGroup],
         t0.type as [Type],
         t0.name as [Name],
         t0.active as [Active],
         t0.last_salary as [LastSalary]
from     Contact t0
         left outer join _Group t1 on (t0.primary_group = t1.id)
         left outer join Contact t2 on (t1.manager = t2.id)
where    (t2.name = 'Mary Manager')
                    </code>
                    <p>
                        We have the following prefixes:
                    </p>
                    <ul>
                        <li><b>(empty)</b> - maps to <code>t0</code></li>
                        <li><b>PrimaryGroup</b> - maps to <code>t1</code></li>
                        <li><b>PrimaryGroup.Manager</b> - maps to <code>t2</code></li>
                    </ul>
                    <p>
                        The number of joins required is always equal to the number of dots in the path expression. 
                        SOQL to SQL converter is smart enough to use the minimal number of joins when you reuse path expression prefixes. 
                        Consider a query that finds all contacts who belong to groups managed by 'Mary Manager' or whose 
                        managers earn more than one million is:
                    </p>
                    <code lang="SQL">
                        <![CDATA[
    select  *
    from    Contact
    where 	PrimaryGroup.Manager.Name = 'Mary Manager'
            or PrimaryGroup.Manager.LastSalary > 1000000
                        ]]>
                    </code>
                    <p>The same query translated to SQL has only two joins because both LastSalary and Name use the same prefix 't2':</p>
                    <code lang="SQL">
                            <![CDATA[
    select   t0.id as [ContactId],
             t0.primary_group as [PrimaryGroup],
             t0.type as [Type],
             t0.name as [Name],
             t0.active as [Active],
             t0.last_salary as [LastSalary]
    from     Contact t0
             left outer join _Group t1 on (t0.primary_group = t1.id)
             left outer join Contact t2 on (t1.manager = t2.id)
    where    ((t2.name = 'Mary Manager') OR (t2.last_salary > 1000000))
                        ]]>
                    </code>
                </body>
            </section>
            <section id="soqltosqlconversioncollections">
                <title>Collections</title>
                <body>
                    <p>
                        The result of SOQL to SQL conversion of collection operators depends 
                        on the type of collection and the operation used. There are 3 possible operations on collections:
                    </p>
                    <ul>
                        <li><code>Count</code></li>
                        <li><code>Contains(obj)</code> - where obj is an object</li>
                        <li><code>Contains(subquery)</code></li>
                    </ul>
                    <p>
                        The following sections demonstrate the result of SOQL to SQL conversion for 
                        <a href="#soqltosqlconversioncollections1N">one-to-many</a> and 
                        <a href="#soqltosqlconversioncollectionsMN">many-to-many</a> collections.
                    </p>
                </body>
                <section id="soqltosqlconversioncollections1N">
                    <title>One-To-Many Collections</title>
                    <body>
                        <p>
                            Operations on one-to-many collections (such as <code>Group.Members</code> where each person may belong to one group),
                            are translated to subqueries on the "child" table (<code>Contact</code> in this example).
                        </p>
                        <p>
                            The <code>Count</code> operation gets converted to a subquery containing the <code>select count(*)</code> expression.
                            Consider this query:
                        </p>
                        <code lang="SQL">
        select  * 
        from    Group
        where   Members.Count > 3
                        </code>
                        <p>
                            It translates to:
                        </p>
                        <code lang="SQL">
        select   t0.id as [Id],
                 t0.manager as [Manager],
                 t0.name as [Name]
        from     _Group t0
        where    ((select count(*) from Contact where primary_group=t0.id) > 3)
                        </code>
                        <p>
                            Converting <code>Contains()</code> on one-to-many collections is easy, because the expression 
                            <code>parentObject.collection.Contains(childObject)</code> can be translated to
                            <code>childObject.ReferenceField = parentObject</code>, so this query:
                        </p>
                        <code lang="SQL">
        select * 
        from			Group
        where	 Members.Contains(Contact.Mary)
                        </code>
                        <p>
                            translates to
                        </p>
                        <code lang="SQL">
        select   t0.id as [Id],
                 t0.manager as [Manager],
                 t0.name as [Name]
        from     _Group t0
        where    exists (select * from Contact where primary_group=t0.id and id in (1))
                        </code>
                        <p>
                            As you can see <code>Contains()</code> has
                            been translated to SQL <code>EXISTS()</code> clause. Note that <code>Contact.Mary</code> has been replaced with <code>1</code>.
                        </p>
                        <p>
                            <code>Contains(subquery)</code> translates to similar <code>EXISTS()</code> expression with numeric literals replaced
                            with the translated subquery. SOQL code:
                        </p>
                        <code lang="SQL">
        select * 
        from     Group
        where	 Members.Contains(Contact where Name like 'Mary%')
                        </code>
                        <p>
                            And the resulting SQL query is:
                        </p>
                        <code lang="SQL">
        select   t0.id as [Id],
                 t0.manager as [Manager],
                 t0.name as [Name]
        from     _Group t0
        where    exists (select * from Contact where primary_group=t0.id and id in (
            select   t1.id as [ContactId]
            from     Contact t1
            where    (t1.name like 'Mary%')))
                        </code>
                    </body>
                </section>
                <section id="soqltosqlconversioncollectionsMN">
                    <title>Many-To-Many Collections</title>
                    <body>
                        <p>
                            Operations on many-to-many collections (such as <code>Contact.Roles</code> where each contact may hold many roles and
                            a role can be held by many persons), are translated to subqueries on the resolving table 
                            (declared with the <x><relation /></x> element in the <a href="#schema">mapping schema</a>).
                        </p>
                        <p>
                            The <code>Count</code> operation gets converted to ta subquery containing the <code>select count(*)</code> expression.
                            Consider this query:
                        </p>
                        <code lang="SQL">
        select  * 
        from    Contact
        where   Roles.Count > 3
                        </code>
                        <p>
                            It translates to the following SQL:
                        </p>
                        <code lang="SQL">
    select   t0.id as [ContactId],
             t0.primary_group as [PrimaryGroup],
             t0.type as [Type],
             t0.name as [Name],
             t0.active as [Active],
             t0.last_salary as [LastSalary]
    from     Contact t0
    where    ((select count(*) from ContactRole where contact_id=t0.id) > 3)
                        </code>
                        <p>
                            Translating <code>Contains()</code> that operates on single objects is only slightly more complicated 
                            than in the one-to-many case. It gets converted to an SQL <code>EXISTS()</code> clause,
                            but it requires additional expression to join back to the "parent" table:
                        </p>
                        <p>
                            Given this SQOL:
                        </p>
                        <code lang="SQL">
                        select  * 
                        from    Contact
                        where   Roles.Contains(Role.Manager)
                        </code>
                        <p>
                            SOQL to SQL Converter produces:
                        </p>
                        <code lang="SQL">
    select   t0.id as [ContactId],
             t0.primary_group as [PrimaryGroup],
             t0.type as [Type],
             t0.name as [Name],
             t0.active as [Active],
             t0.last_salary as [LastSalary]
    from     Contact t0
    where    exists (select * from ContactRole where contact_id=t0.id and role_id in (2))
                        </code>
                        <p>
                            <code>Contains()</code> with subquery as an argument produces the most complicated
                            result, still using SQL <code>EXISTS()</code> clause and a subquery.
                        </p>
                        <code lang="SQL">
    select  * 
    from    Contact
    where   Roles.Contains(Role where Name like 'Admin%')
                        </code>
                        <p>
                            Produces:
                        </p>
                        <code lang="SQL">
    select   t0.id as [ContactId],
             t0.primary_group as [PrimaryGroup],
             t0.type as [Type],
             t0.name as [Name],
             t0.active as [Active],
             t0.last_salary as [LastSalary]
    from     Contact t0
    where    exists (select * from ContactRole where contact_id=t0.id and role_id in (
        select   t1.id as [Id]
        from     _Role t1
        where    (t1.name like 'Admin%')))
                        </code>
                    </body>
                </section>
                <section id="soqltosqlconversionnamedconstants">
                    <title>Named constants</title>
                    <body>
                        <p>
                            Named constants in SOQL are simply replaced by their numeric or string values. In the following
                            example, named constant <code>Contact.Mary</code> gets replaced with its numeric value of one.
                        </p>
                        <p>
                            SOQL:
                        </p>
                        <code lang="SQL">
        select  * 
        from    Contact
        where   PrimaryGroup.Manager = Contact.Mary
                        </code>
                        <p>
                            SQL:
                        </p>
                        <code lang="SQL">
    select   t0.id as [ContactId],
             t0.primary_group as [PrimaryGroup],
             t0.type as [Type],
             t0.name as [Name],
             t0.active as [Active],
             t0.last_salary as [LastSalary]
    from     Contact t0
             left outer join _Group t1 on (t0.primary_group = t1.id)
    where    (t1.manager = 1)
                        </code>
                    </body>
                </section>
                <section id="soqltosqlconversionsoodaclassandinheritance">
                    <title>SoodaClass and Inheritance</title>
                    <body>
                        <p>
                            <code>SoodaClass</code> returns class name as a string. In cases where the class is known statically (when the class
                            is known to have no subclasses), it is emitted directly into the SQL output. When the class has
                            subclasses, Sooda needs to resort to runtime evaluation using SQL <code>CASE ... WHEN ... END</code>
                            construct.
                        </p>
                        <p>
                            For example, this SOQL code:
                        </p>
                        <code lang="SQL">
                            select SoodaClass
                            from Contact
                        </code>
                        <p>
                            Is equivalent to the following SQL, because class <code>Contact</code> does not have any subclasses.
                        </p>
                        <code lang="SQL">
                            select   'Contact' as SoodaClass
                            from     Contact t0
                        </code>
                        <p>
                            On the contrary, the class <code>Vehicle</code> has many subclasses, so translating a similar query 
                            returns very different result:
                        </p>
                        <code lang="SQL">
                            select  SoodaClass
                            from    Vehicle
                        </code>
                        <p>
                            The result of the translation is shown below. Note the <code>CASE</code> expression that
                            returns <code>'Car'</code> when type is <code>1</code>, <code>'Bike'</code> when type is <code>2</code>,
                            and so on. The mapping is taken from <code>subclassSelectorValue</code> attributes 
                            defined in the <a href="#schemainheritance">mapping schema</a>.
                        </p>
                        <code lang="SQL">
                            select   (case t0.type 
                                            when 1 then 'Car' 
                                            when 2 then 'Bike' 
                                            when 3 then 'SuperBike' 
                                            when 4 then 'MegaSuperBike' 
                                            when 5 then 'ConcreteMegaSuperBikeA' 
                                            when 6 then 'ConcreteMegaSuperBikeB' 
                                            when 7 then 'ExtendedBike' else null end) as SoodaClass
                            from     Vehicle t0
                            where    t0.type in (1,2,3,4,5,6,7)
                        </code>
                        <p>
                            Pay attention to the extra <code>WHERE</code> clause that has been added by the conversion routine. This is needed to
                            ensure that the result of this query will be limited to instances of <code>Vehicle</code> and <code>Bike</code>
                            subclasses. The additional where clause always includes the identifiers of all concrete types that 
                            may be returned. If we wanted to limit ourselves to the bikes, we cold have written:
                        </p>
                        <code lang="SQL">
                            select   *
                            from     Bike
                        </code>
                        <p>
                            The result of the translation would be (note that the identifiers of possible subclasses are 
                            different from the previous case, even though the Bike class is based on the same database table):
                        </p>
                        <code lang="SQL">
    select   t0.id as [Id],
             t0.type as [Type],
             t0.name as [Name],
             t0_pkjoin_Bike.two_wheels as [TwoWheels]
    from     Vehicle t0
             left outer join Bike t0_pkjoin_Bike on (t0.id = t0_pkjoin_Bike.id)
    where    t0.type in (3,4,5,6,7,2)
                        </code>
                        <p>
                            Please also note how additional fields from the Bike class are made available in the results. There is a special
                            join, called "primary key join" and a special table alias "tk_pkjoin_Bike" which gives access to <code>two_wheels</code>
                            column in the <code>Bike</code> table.
                        </p>
                    </body>
                </section>
            </section>
        </section>
        <section id="generatedcode">
            <title>Generated Code</title>
            <body>
                <a href="#soodastubgen">SoodaStubGen utility</a> generates a number of classes, such as stub classes, factory classes, list wrappers, and more.
                This section describes each piece of generated code in detail.
            </body>
            <section id="generatedclasses">
                <title>Classes</title>
                <body>
                    <p>
                        Each <x><class /></x> declaration in the <a href="#schema">mapping schema</a> translates into at least five classes:
                    </p>
                    <ul>
                        <li><b>stub class</b> - contains properties generated based on <x><field /></x> elements in the schema and utility methods</li>
                        <li><b>skeleton class</b> - generated only once, inherits from a stub class</li>
                        <li><b>factory class</b> - contains methods to create single instances and lists of objects of particular class in a polymorphic manner - following the Abstract Factory design pattern</li>
                        <li><b>value class</b> - contains field values - used for lazy loading</li>
                        <li><b>list wrapper class</b> - type-safe wrapper around <code>ISoodaObjectList</code></li>
                    </ul>
                </body>
                <section id="generatedstubclasses">
                    <title>Stub Classes</title>
                    <body>
                        <p>
                            Each stub class <code>NNN_Stub</code> generated by SoodaStubGen corresponds to a <x><class name="NNN" /></x> declaration in the <a href="#schema">mapping schema</a>.
                            The stub class is enclosed in the output namespace defined in the <a href="#soodaproject">Sooda Project File</a> followed by <code>.Stubs</code>. It ultimately
                            derives from the <code>SoodaObject</code> class as described <sectionlink id="generatedclasshierarchy" />:
                        </p>
                        <code lang="C#">
                            namespace OutputNamespace.Stubs
                            {
                                public class NNN_Stub : SoodaObject
                                {
                                }
                            }
                        </code>
                        <p>
                            Each stub class has:
                        </p>
                        <ul>
                            <li>constructors</li>
                            <li>one public instance property for each <x><field /></x> declared locally in the <a href="#schema">schema file</a>. The name of the property matches the name defined in the schema and exact type
                                depends on chosen <a href="#soodaprojectprimitiverep">primitive representation</a> and field nullability as described <sectionlink id="generatedproperties" />.</li>
                            <li>one public static property for each <x><const /></x> declared locally in the schema as described <sectionlink id="generatedenums" />.</li>
                            <li><code>GetClassInfo()</code> method that returns the <a href="#schemaapiclassinfo">ClassInfo</a> object
                                describing mapping metadata</li>
                            <li><code>GetFieldHandler(int ordinal)</code> method that returns a field handler given for a field ordinal</li>
                            <li>static <code>GetKeyGenerator()</code> method that returns the key generator for the class</li>
                            <li><code>InitNewObject()</code> method that initializes the primary key of the newly created objects from the key generator</li>
                            <li>
                                <p>
                                    Loader methods:
                                </p>
                                <ul>
                                    <li><code>LoadSingleObject()</code> method overloads</li>
                                    <li><code>GetAllObjects()</code> method overloads</li>
                                    <li><code>GetList()</code> method overloads</li>
                                    <li><code>Load()</code> method overloads</li>
                                    <li><code>GetRef()</code> method overloads</li>
                                    <li><code>TryGet()</code> method overloads</li>
                                </ul>
                                <p>
                                    Note that these methods are located in a separate class named <code>NNNLoader</code>
                                    when the <x><loader-class /></x> option is set to <code>true</code> in the <a href="#soodaproject">Sooda Project File</a>.
                                </p>
                            </li>
                        </ul>
                    </body>
                </section>
            </section>
            <section id="generatedclasshierarchy">
                <title>Class hierarchy</title>
                <body>
                    <p>
                        Each <x><class /></x> element defined in the <a href="#schema">mapping schema</a> is represented 
                        in generated code by two classes: skeleton and stub. Stub classes typically inherit from the <code>SoodaObject</code>
                        class, but when Sooda class inheritance is used, the stub classes may inherit from parent skeleton classes.
                    </p>
                    <p>
                        In addition to this, you may "inject" your own class into the inheritance hierarchy at two levels:
                    </p>
                    <ul>
                        <li>by specifying the <x><base-class-name /></x> in the <a href="#soodaproject">Sooda Project File</a></li>
                        <li>by overriding the base class name in the schema with the <code>extBaseClassName</code> attribute.</li>
                    </ul>
                    <p>
                        The class you inject must provide 2 constructors required by Sooda and must ultimately derive from <code>SoodaObject</code>.
                        Typical declaration of the injectable class looks like this:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                            public class SoodaObjectExtensions: SoodaObject
                            {
                                public SoodaObjectExtensions(SoodaTransaction t): base(t){}
                                protected SoodaObjectExtensions(SoodaConstructor c): base(c){}
                            }
                        ]]>
                    </code>
                    <p>
                        Consider a simple schema with five classes (fields and tables omitted for brevity):
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="Vehicle" subclassSelectorField="Type" subclassSelectorValue="0">
                            </class>

                            <class name="Bicycle" inheritFrom="Vehicle" subclassSelectorValue="1">
                            </class>
                                
                            <class name="Car" inheritFrom="Vehicle" subclassSelectorValue="2">
                            </class>
                                
                            <class name="Boat" inheritFrom="Vehicle" subclassSelectorValue="3">
                            </class>

                            <class name="Person">
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <p>
                        Assuming the Sooda Project File sets the <x><base-class-name /></x> option:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <sooda-project xmlns="http://www.sooda.org/schemas/SoodaProject.xsd">
                            <base-class-name>AdditionalBaseClass</base-class-name>
                        </sooda-project>                
                        ]]>
                    </code>
                    <p>
                        The generated class hierarchy is presented in the following figure. 
                        Note how all classes ultimately derive from the <code>SoodaObject</code> class
                        and how <code>Bicycle_Stub</code>, <code>Car_Stub</code> and <code>Boat_Stub</code>
                        classes inherit from <code>Vehicle</code> skeleton class.
                    </p>
                    <img src="doc15.png" alt="Demonstration of base-class-name effect" />
                </body>
            </section>
            <section id="generatedproperties">
                <title>Properties</title>
                <body>
                    <p>
                        SoodaStubGen generates one property for each <x><field /></x> declared in the mapping schema. The
                        name of the property is taken from the <code>name</code> attribute and the property type 
                        depends on two factors:
                    </p>
                    <ul>
                        <li>the nullability of the field</li>
                        <li>the primitive representation as defined in the Sooda Project File</li>
                    </ul>
                    <p>
                        If the field is nullable, SoodaStubGen uses the representation passed in <x><nullable-representation /></x> parameter.
                        If the field is not nullable, the representation passed in <x><not-null-representation /></x> is used. 
                        Particular representations are presented in the following sections.
                    </p>
                </body>
                <section id="generatedpropertiesboxed">
                    <title>Boxed</title>
                    <body>
                        <p>
                            <code>Boxed</code> representation causes the property to have <code>System.Object</code> return type
                            which maps to <code>object</code> keyword in C#, so the property declaration looks like this:
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                // Boxed object representation, note that there is
                                // no static type checking
                                public object Field1
                                {
                                    get { ... } 
                                    set { ... }
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
                <section id="generatedpropertiessqltypes">
                    <title>SqlTypes</title>
                    <body>
                        <p>
                            <code>SqlTypes</code> representation causes the property to have the type that is a structure from the
                            <code>System.Data.SqlTypes</code> namespace:
                        </p>
                        <ul>
                            <li><code>System.Data.SqlTypes.SqlInt32</code> - for the <code>Integer</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlInt64</code> - for the <code>Long</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlString</code> - for the <code>String</code> and <code>AnsiString</code> data types</li>
                            <li><code>System.Data.SqlTypes.SqlBoolean</code> - for <code>Boolean</code> and <code>BooleanAsInteger</code> data types</li>
                            <li><code>System.Data.SqlTypes.SqlDateTime</code> - for the <code>DateTime</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlDecimal</code> - for the <code>Decimal</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlSingle</code> - for the <code>Float</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlDouble</code> - for the <code>Double</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlBinary</code> - for the <code>Blob</code> data type</li>
                            <li><code>System.Data.SqlTypes.SqlGuid</code> - for the <code>Guid</code> data type</li>
                        </ul>
                        <p>
                            Example:
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                // SqlTypes object representation
                                public System.Data.SqlTypes.SqlInt32 Field1
                                {
                                    get { ... } 
                                    set { ... }
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
                <section id="generatedpropertiesraw">
                    <title>Raw</title>
                    <body>
                        <p>
                            <code>Raw</code> property representation does not care about null values at all. The property type is simply
                            the raw type of the field:
                        </p>
                        <ul>
                            <li><code>System.Int32</code> - for the <code>Integer</code> data type</li>
                            <li><code>System.Int64</code> - for the <code>Long</code> data type</li>
                            <li><code>System.String</code> - for the <code>String</code> and <code>AnsiString</code> data types</li>
                            <li><code>System.Boolean</code> - for <code>Boolean</code> and <code>BooleanAsInteger</code> data types</li>
                            <li><code>System.DateTime</code> - for the <code>DateTime</code> data type</li>
                            <li><code>System.Decimal</code> - for the <code>Decimal</code> data type</li>
                            <li><code>System.Single</code> - for the <code>Float</code> data type</li>
                            <li><code>System.Double</code> - for the <code>Double</code> data type</li>
                            <li><code>byte[]</code> - for the <code>Blob</code> data type</li>
                            <li><code>System.Drawing.Image</code> - for the <code>Image</code> data type</li>
                            <li><code>System.Guid</code> - for the <code>Guid</code> data type</li>
                        </ul>
                        <p>
                            Example:
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                // Raw object representation
                                public System.Int32 Field1
                                {
                                    get { ... } 
                                    set { ... }
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
                <section id="generatedpropertiesrawwithisnull">
                    <title>RawWithIsNull</title>
                    <body>
                        <p>
                            <code>RawWithIsNull</code> generates a pair of properties: <code>P</code> and <code>P_IsNull</code>,
                            the latter being read-only returning <code>true</code> when the field value is <code>null</code>. In addition to this
                            the <code>P_SetNull()</code> method is generated that can be used to set the field value to null.
                        </p>
                        <ul>
                            <li><code>System.Int32</code> - for the <code>Integer</code> data type</li>
                            <li><code>System.Int64</code> - for the <code>Long</code> data type</li>
                            <li><code>System.String</code> - for the <code>String</code> and <code>AnsiString</code> data types</li>
                            <li><code>System.Boolean</code> - for <code>Boolean</code> and <code>BooleanAsInteger</code> data types</li>
                            <li><code>System.DateTime</code> - for the <code>DateTime</code> data type</li>
                            <li><code>System.Decimal</code> - for the <code>Decimal</code> data type</li>
                            <li><code>System.Single</code> - for the <code>Float</code> data type</li>
                            <li><code>System.Double</code> - for the <code>Double</code> data type</li>
                            <li><code>byte[]</code> - for the <code>Blob</code> data type</li>
                            <li><code>System.Drawing.Image</code> - for the <code>Image</code> data type</li>
                            <li><code>System.Guid</code> - for the <code>Guid</code> data type</li>
                        </ul>
                        <p>
                            Example:
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                // RawWithIsNull object representation
                                public System.Int32 Field1
                                {
                                    get { ... } 
                                    set { ... }
                                }

                                public bool Field1_IsNull
                                {
                                    get { ... }
                                }

                                public void Field1_SetNull()
                                {
                                    ...
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
                <section id="generatedpropertiesnullable">
                    <title>Nullable</title>
                    <body>
                        <p>
                            <code>Nullable</code> property uses <code>System.Nullable&lt;T&gt;</code> generic type available in .NET 2.0.
                            The actual type of the property depends on the field data type:
                        </p>
                        <ul>
                            <li><code>Nullable&lt;Int32&gt;</code> - for the <code>Integer</code> data type</li>
                            <li><code>Nullable&lt;Int64&gt;</code> - for the <code>Long</code> data type</li>
                            <li><code>Nullable&lt;Boolean&gt;</code> - for <code>Boolean</code> and <code>BooleanAsInteger</code> data types</li>
                            <li><code>Nullable&lt;DateTime&gt;</code> - for the <code>DateTime</code> data type</li>
                            <li><code>Nullable&lt;Decimal&gt;</code> - for the <code>Decimal</code> data type</li>
                            <li><code>Nullable&lt;Single&gt;</code> - for the <code>Float</code> data type</li>
                            <li><code>Nullable&lt;Double&gt;</code> - for the <code>Double</code> data type</li>
                            <li><code>Nullable&lt;Guid&gt;</code> - for the <code>Guid</code> data type</li>
                        </ul>
                        <p>
                            Note that <code>String</code>, <code>AnsiString</code>, <code>Blob</code> and <code>Image</code> types are handled in a special way, because nullable
                            types cannot be used to "wrap" reference types):
                        </p>
                        <ul>
                            <li><code>string</code> - for the <code>String</code> and <code>AnsiString</code> data types</li>
                            <li><code>byte[]</code> - for the <code>Blob</code> data type</li>
                            <li><code>System.Drawing.Image</code> - for the <code>Image</code> data type</li>
                        </ul>
                        <p>
                            Example:
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                // Nullable object representation
                                public Nullable<System.Int32> Field1
                                {
                                    get { ... } 
                                    set { ... }
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
                <section id="generatedpropertiesreference">
                    <title>Reference fields</title>
                    <body>
                        <p>
                            For reference fields, the property return type is the class that is referred. Null reference is
                            passed as <code>null</code>.
                        </p>
                        <code lang="C#">
                            <![CDATA[

                            class NNN_Stub
                            {
                                public ReferencedClass RefField1
                                {
                                    get { ... } 
                                    set { ... }
                                }
                            }

                            ]]>
                        </code>
                    </body>
                </section>
            </section>
            <section id="generatedcollections">
                <title>Collections</title>
                <body>
                    <p>
                        Each collection (both one-to-many and many-to-many) is represented as a read-only property whose type is
                        <code>MMMList</code> where <code>MMM</code> is the type of the collection element. The <code>MMMList</code> is a
                        list wrapper described <sectionlink id="generatedlistwrappers" />.
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="NNN">
                                <collectionOneToMany name="Members" class="MMM" foreignField="..." />
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <p>
                        The following code is generated from the above declaration:
                    </p>
                    <code lang="C#">
                        <![CDATA[

                        class NNN_Stub
                        {
                            public MMMList Members
                            {
                                get { ... } 
                            }
                        }

                        ]]>
                    </code>
                </body>
            </section>
            <section id="generatedtriggers">
                <title>Triggers</title>
                <body>
                    <p>
                        Sooda generates two methods for each <x><field /></x>, one called before and the other called after the field is modified
                        is modified. Assuming the following schema:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="NNN">
                                <table name="Table1">
                                    <field name="Field1" type="Integer" />
                                </table>
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <p>
                        The trigger method signatures are:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        class NNN_Stub
                        {
                            protected virtual void BeforeFieldUpdate_Field1(object oldValue, object newValue)
                            {
                            }

                            protected virtual void AfterFieldUpdate_Field1(object oldValue, object newValue)
                            {
                            }
                        }    
                        ]]>
                    </code>
                    <p>
                        <code>oldValue</code> and <code>newValue</code> passed to these methods are old and new values of the field
                        being set, respectively. The values are boxed to represent the <code>null</code>. For reference fields, the type
                        of <code>objValue</code> and <code>newValue</code> arguments is the referenced class itself.
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="NNN">
                                <table name="Table1">
                                    <field name="RefField1" type="Integer" references="ReferencedClass" />
                                </table>
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <p>
                        This schema causes the following pair of trigger methods to be generated:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        class NNN_Stub
                        {
                            protected virtual void BeforeFieldUpdate_RefField1(ReferencedClass oldValue, ReferencedClass newValue)
                            {
                            }

                            protected virtual void AfterFieldUpdate_RefField1(ReferencedClass oldValue, ReferencedClass newValue)
                            {
                            }
                        }    
                        ]]>
                    </code>
                    <p>
                        The methods are declared <code>protected virtual</code> so that you can override them in your skeleton classes
                        but you cannot call them from outside of the class.
                    </p>
                </body>
            </section>
            <section id="generatedenums">
                <title>Constants/Enumerations</title>
                <body>
                    <p>
                        Constants declared with <x><const /></x> are generated as public static properties of the stub class:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="NNN">
                                <const name="MyConstant1" key="1" />
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <p>
                        The above declaration translates to:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        class NNN_Stub
                        {
                            public static NNN MyConstant1
                            {
                                get { ... }
                            }
                        }    
                        ]]>
                    </code>
                </body>
            </section>
            <section id="generatedlistwrappers">
                <title>List wrappers</title>
                <body>
                    <p>
                        List wrappers are type-safe wrappers around <code>ISoodaObjectList</code> that can be used in all places
                        where the interface is expected. They provide typed <code>Add()</code>, <code>Remove()</code> and <code>Contains()</code>
                        methods and a number of convenience methods. The following wrapper is generated for each class NNN:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                          public class NNNList : Sooda.ObjectMapper.SoodaObjectCollectionWrapperGeneric<NNN> {
                            public NNNList() {
                            }
                            public NNNList(ISoodaObjectList list) : 
                                base(list) {
                            }
                            public new NNN this[int pos] {
                              get {
                                return ((NNN)(base.GetItem(pos)));
                              }
                            }
                            public int Add(NNN obj) {
                              return base.Add2(obj);
                            }
                            public void Remove(NNN obj) {
                              base.Remove2(obj);
                            }
                            public bool Contains(NNN obj) {
                              return base.Contains2(obj);
                            }
                            public NNNList Sort(IComparer comparer) {
                              return new NNNList(base.Sort2(comparer));
                            }
                            public NNNList Sort(string sortOrder) {
                              return new NNNList(base.Sort2(sortOrder));
                            }
                            public NNNList Sort(Sooda.QL.SoqlExpression sortExpression) {
                              return new NNNList(base.Sort2(sortExpression));
                            }
                            public NNNList Sort(Sooda.QL.SoqlExpression sortExpression, Sooda.SortOrder sortOrder) {
                              return new NNNList(base.Sort2(sortExpression, sortOrder));
                            }
                            public NNNList SelectFirst(int count) {
                              return new NNNList(base.SelectFirst2(count));
                            }
                            public NNNList SelectLast(int count) {
                              return new NNNList(base.SelectLast2(count));
                            }
                            public NNNList SelectRange(int _from, int _to) {
                              return new NNNList(base.SelectRange2(_from, _to));
                            }
                            public NNNList Filter(SoodaObjectFilter f) {
                              return new NNNList(base.Filter2(f));
                            }
                            public NNNList Filter(Sooda.QL.SoqlBooleanExpression sortExpression) {
                              return new NNNList(base.Filter2(sortExpression));
                            }
                            public NNNList Filter(SoodaWhereClause whereClause) {
                              return new NNNList(base.Filter2(whereClause));
                            }
                            public NNNList GetSnapshot() {
                              return new NNNList(base.GetSnapshot2());
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        The class that <code>NNNList</code> inherits from 
                        is <code>Sooda.ObjectMapper.SoodaObjectCollectionWrapperGeneric&lt;NNN&gt;</code> for .NET 2.0 and above
                        and <code>Sooda.ObjectMapper.SoodaObjectCollectionWrapper</code> for .NET 1.x.
                    </p>
                </body>
            </section>
            <section id="generatedfindmethods">
                <title>Find Methods</title>
                <body>
                    <p>
                        The <code>FindByNNN</code> and <code>FindListByNNN</code> methods are used to quickly locate one or all objects such that
                        their <code>NNN</code> is equal to the provided value. The finders are generated as public static methods of 
                        stub classes:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <class name="NNN">
                                <table name="Table1">
                                    <field name="Field1" type="Integer" find="true" />
                                    <field name="Field2" type="String" findList="true" />
                                </table>
                            </class>
                        </schema>
                        ]]>
                    </code>
                    <code lang="C#">
                        class NNN_Stub
                        {
                            public static void NNN FindByField1(Int32 field1)
                            {
                            }

                            public static void NNNList FindByField2(String field2)
                            {
                            }
                        }
                    </code>
                </body>
            </section>
            <section id="generatedfactories">
                <title>Abstract Factories</title>
                <body>
                    <p>
                        Each Sooda class has an associated abstract factory that can create instances of the class and 
                        return mapping metadata. The abstract factory is a class that 
                        implements <code>ISoodaObjectFactory</code>. The following factory code is generated for 
                        each class <code>NNN</code>:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        namespace OutputNamespace.Stubs
                        {
                          [SoodaObjectFactoryAttribute("NNN", typeof(NNN))]
                          public class NNN_Factory : ISoodaObjectFactory
                          {
                            public NNN_Factory()
                            {
                            }
                            public static NNN_Factory TheFactory
                            {
                                get { ... }
                            }
                            public virtual Type TheType
                            {
                                get { ... }
                            }
                            public static ClassInfo TheClassInfo
                            {
                                get { ... }
                            }
                            public virtual SoodaObject GetRef(SoodaTransaction tran, object keyValue)
                            {
                            }
                            public virtual SoodaObject TryGet(SoodaTransaction tran, object keyValue)
                            {
                            }
                            public virtual IList GetList(SoodaTransaction tran, 
                                    SoodaWhereClause whereClause, 
                                    SoodaOrderBy orderBy, 
                                    SoodaSnapshotOptions options)
                            {
                            }
                            public virtual ClassInfo GetClassInfo()
                            {
                            }
                            public virtual SoodaFieldHandler GetPrimaryKeyFieldHandler()
                            {
                            }
                            public virtual SoodaFieldHandler GetFieldHandler(int ordinal)
                            {
                            }
                            internal static SoodaFieldHandler InternalGetFieldHandler(int ordinal)
                            {
                            }
                            public virtual SoodaObject CreateNew(SoodaTransaction tran)
                            {
                            }
                            public virtual SoodaObject GetRawObject(SoodaTransaction tran)
                            {
                            }
                          }
                        }
                      ]]>
                  </code>
                  <p>
                      Thanks to factory classes, Sooda can create instances of materialized objects without using reflection, which helps
                      speed things up.
                  </p>
                </body>
            </section>
            <section id="generatedschema">
                <title>Schema</title>
                <body>
                    <p>
                        SoodaStubGen generates the <code>_DatabaseSchema</code> schema that provides access to runtime
                        mapping metadata and instances of all class factories for the schema. The declaration of the class is:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        public class _DatabaseSchema : ISoodaSchema
                        {
                            public _DatabaseSchema()
                            {
                            }
                            public virtual Sooda.Schema.SchemaInfo Schema
                            {
                                get { ... }
                            }
                            public static Sooda.Schema.SchemaInfo GetSchema()
                            {
                            }
                            public virtual Sooda.ISoodaObjectFactory[] GetFactories() {
                            }
                        }
                        ]]>
                    </code>
                </body>
            </section>
            <section id="generatedtypedqueries">
                <title>Typed Queries</title>
                <body>
                    <p>
                        There are two sets of classes that support typed queries: public classes and supporting classes. Public 
                        classes are named <code>OutputNamespace.TypedQueries.NNNField</code> where <code>NNN</code> is the name 
                        of the appropriate class. Supporting classes are located in the <code>OutputNamespace.Stubs</code> namespace
                        and are named: <code>NNNWrapperExpression</code> and <code>NNNNullableWrapperExpression</code>:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        namespace OutputNamespace.TypedQueries
                        {
                            public class NNNField
                            {
                            }
                        }

                        namespace OutputNamespace.Stubs
                        {
                            public class NNNWrapperExpression : Sooda.QL.SoqlPathExpression
                            {
                            }

                            public class NNNNullableWrapperExpression : NNNWrapperExpression
                            {
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        Each <code>NNNField</code>
                    </p>
                </body>
            </section>
        </section>
        <section id="schemaapi">
            <title>Schema API</title>
            <body>
                <p>
                    Sooda provides runtime access to the <a href="#schema">mapping schema</a> through a set of metadata classes.
                    Each class represents a single mapping element. The following classes are available:
                </p>
                <ul>
                    <li><a href="#schemaapischemainfo"><code>SchemaInfo</code></a> - represents the <x><schema /></x> root element and provides access to classes, 
                        relations, data sources, precommit values and included files</li>
                    <li><a href="#schemaapiclassinfo"><code>ClassInfo</code></a> - represents the <x><class /></x> schema element</li>
                    <li><a href="#schemaapirelationinfo"><code>RelationInfo</code></a> - represents the <x><relation /></x> schema element</li>
                    <li><a href="#schemaapitableinfo"><code>TableInfo</code></a> - represents the <x><table /></x> schema element</li>
                    <li><a href="#schemaapifieldinfo"><code>FieldInfo</code></a> - represents the <x><field /></x> schema element</li>
                    <li><a href="#schemaapiincludeinfo"><code>IncludeInfo</code></a> - represents the <x><include /></x> schema element</li>
                    <li><a href="#schemaapiconstantinfo"><code>ConstantInfo</code></a> - represents the <x><const /></x> schema element</li>
                    <li><a href="#schemaapidatasourceinfo"><code>DataSourceInfo</code></a> - represents the <x><datasource /></x> schema element</li>
                    <li><a href="#schemaapiprecommitvalueinfo"><code>PrecommitValueInfo</code></a> - represents the <x><precommitValue /></x> schema element</li>
                    <li><a href="#schemaapicollectiononetomanyinfo"><code>CollectionOneToManyInfo</code></a> - represents the <x><collectionOneToMany /></x> schema element</li>
                    <li><a href="#schemaapicollectionmanytomanyinfo"><code>CollectionManyToManyInfo</code></a> - represents the <x><collectionManyToMany /></x> schema element</li>
                </ul>
            </body>
            <section id="schemaapischemainfo">
                <title>SchemaInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.SchemaInfo</code> class represents the <x><schema /></x> element of the <a href="#schema">mapping schema</a>. 
                        You typically acquire a reference to the <code>SchemaInfo</code> object that matches the compiled
                        stubs assembly by calling <code>_DatabaseSchema.GetSchema()</code> method as in the following example.
                        The <code>_DatabaseSchema</code> class is generated by the <a href="#soodastubgen">SoodaStubGen utility</a> and
                        so the namespace depends on your <a href="soodaproject">code generation settings</a>.
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using Sooda;
                        using SoodaSchema;

                        class Program
                        {
                            static void Main()
                            {
                                SchemaInfo schema = MyBusinessObjects._DatabaseSchema.GetSchema();

                                foreach (ClassInfo cl in schema.Classes)
                                {
                                    Console.WriteLine("class: {0}", cl.Name);
                                }
                            }
                        ]]>
                    </code>
                    <p>
                        <code>SchemaInfo</code> class has following properties:
                    </p>
                    <ul>
                        <li><code>Namespace</code> - schema namespace</li>
                        <li><code>AssemblyName</code> - schema assembly name</li>
                        <li><code>Includes</code> - collection of <a href="#schemaapiincludeinfo"><code>IncludeInfo</code></a> objects representing included schema.</li>
                        <li><code>DataSources</code> - collection of <a href="#schemaapidatasourceinfo"><code>DataSourceInfo</code></a> objects representing defined data sources.</li>
                        <li><code>Classes</code> - collection of <a href="#schemaapiclassinfo"><code>ClassInfo</code></a> objects representing defined classes.</li>
                        <li><code>Relations</code> - collection of <a href="#schemaapirelationinfo"><code>RelationInfo</code></a> objects representing defined relations.</li>
                        <li><code>DefaultPrecommitValues</code> - determines per-schema precommit strategy, explained <sectionlink id="schemaprecommitvalues" />.</li>
                        <li><code>PrecommitValues</code> - collection of <a href="#schemaapiprecommitvalueinfo"><code>PrecommitValueInfo</code></a> objects representing defined precommit values.</li>
                        <li><code>LocalClasses</code> - same as <code>Classes</code> but is limited to classes defined in the schema (excluding those defined in included schema files)</li>
                        <li><code>LocalRelations</code> - same as <code>Relations</code> but is limited to relations defined in the schema (excluding those defined in included schema files)</li>
                    </ul>
                    <p>
                        <code>SchemaInfo</code> also exposes some public methods, but they are not meant to be used in user code. The methods must be public 
                        so they can be called from generated code.
                    </p>
                </body>
            </section>
            <section id="schemaapiclassinfo">
                <title>ClassInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.ClassInfo</code> class represents the <x><class /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve class-level mapping metadata.
                        Objects of this class are stored in <code>SchemaInfo.Classes</code> and <code>SchemaInfo.LocalClasses</code> collections. 
                    </p>
                    <p>
                        <code>ClassInfo</code> has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - class name</li>
                        <li><code>ExtBaseClassName</code> - Specifies the name of the base class that this class should inherit from. </li>
                        <li><code>DataSourceName</code> - name of the data source</li>
                        <li><code>LocalTables</code> - collection of <a href="#schemaapitableinfo"><code>TableInfo</code></a> objects representing local tables of this class (excluding any tables defined in parent classes in the inheritance hierarchy)</li>
                        <li><code>UnifiedTables</code> - collection of <a href="#schemaapitableinfo"><code>TableInfo</code></a> objects representing all tables that this class is based on (including tables defined in parent classes in the inheritance hierarchy)</li>
                        <li><code>DatabaseTables</code> - collection of <a href="#schemaapitableinfo"><code>TableInfo</code></a> objects representing database tables of this class ignoring any vertical partitions (so two <x><table /></x> declarations
                            based on a single physical table are merged together. This structure is used to properly <code>INSERT</code> objects
                            into the database.
                        </li>
                        <li><code>LocalFields</code> - collection of <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> objects defined in all tables defined in this class (primary key fields are not duplicated)</li>
                        <li><code>UnifiedFields</code> - collection of <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> objects defined in all tables defined in this class and all parent classes in the inheritance hierarchy (primary key fields are not duplicated)</li>
                        <li><code>OrderedFieldNames</code> - array of ordered field names (as in <code>UnifiedFields</code>)</li>
                        <li><code>Collections1ToN</code> - one-to-many collections defined in this class</li>
                        <li><code>CollectionsNToN</code> - many-to-many collections defined in this class</li>
                        <li><code>LocalCollections</code> - all collections (one-to-many and many-to-many) defined in this class</li>
                        <li><code>UnifiedCollections</code> - all collections (one-to-many and many-to-many) defined in this class and all parent classes in the inheritance hierarchy</li>
                        <li><code>Constants</code> - collection of <a href="#schemaapiconstantinfo"><code>ConstantInfo</code></a> that define named constants for this class</li>
                        <li><code>DefaultPrecommitValue</code> - default precommit value to be used for reference fields that refer to this class</li>
                        <li><code>Cached</code> - caching hint. Actual interpretation depends on the active <a href="#cachingapi">caching policy</a>.</li>
                        <li><code>CacheCollections</code> - caching hint. Actual interpretation depends on the active <a href="#cachingapi">caching policy</a>.</li>
                        <li><code>Cardinality</code> - caching hint. Actual interpretation depends on the active <a href="#cachingapi">caching policy</a>.</li>
                        <li><code>Triggers</code> - determines whether per-field triggers are generated for this class.</li>
                        <li><code>ReadOnly</code> - read-only class (no property setters are generated)</li>
                        <li><code>LabelField</code> - name of the label field for this class</li>
                        <li><code>SubclassSelectorFieldName</code> - name of the subclass selector field (propagated from parent classes if necessary)</li>
                        <li><code>SubclassSelectorField</code> - a <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> object that represents the subclass selector field</li>
                        <li><code>SubclassSelectorStringValue</code> - string value of the subclass selector field</li>
                        <li><code>SubclassSelectorValue</code> - typed value of the subclass selector field (string or integer)</li>
                        <li><code>InheritFrom</code> - name of the base Sooda class in the inheritance hierarchy</li>
                        <li><code>InheritsFromClass</code> - a <a href="#schemaapiclassinfo"><code>ClassInfo</code></a> object that represents the base class in the inheritance hierarchy</li>
                        <li><code>KeyGenName</code> - name of the key generator that provides keys for this class</li>
                        <li><code>OuterReferences</code> - collection of <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> objects that are references to this class</li>
                        <li><code>DisableTypeCache</code> - whether type cache is disabled for this class</li>
                    </ul>
                    <p>
                        In addition to the properties, <code>ClassInfo</code> exposes the following public methods:
                    </p>
                    <ul>
                        <li><code>FindCollectionOneToMany(name)</code> - finds the specified one-to-many collection in this class or any
                            ancestors in the inheritance hierarchy</li>
                        <li><code>FindCollectionManyToMany(name)</code> - finds the specified many-to-many collection in this class or any
                            ancestors in the inheritance hierarchy</li>
                        <li><code>ContainsCollection(name)</code> - determines whether the specified collection is defined in this class
                            or any ancestor class</li>
                        <li><code>GetPrimaryKeyFields()</code> - returns an array of <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> objects which are marked as primary keys</li>
                        <li><code>GetFirstPrimaryKey()</code> - returns the <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> object for the first primary key field</li>
                        <li><code>GetSubclassesForSchema(schema)</code> - returns the collection of <a href="#schemaapiclassinfo"><code>ClassInfo</code></a> objects that are subclasses of this class in the specified schema. 
                            Note that the list of subclasses may be different depending on the schema you use if you define a root class in one
                            <a href="#schema">schema file</a> and classes inheriting from it in another one.</li>
                    </ul>
                    <p>
                        Let's assume that you have defined the following classes in the <a href="#schema">mapping schema</a>:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                            <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                                <class name="A">
                                    <table name="TA">
                                        <field name="Id" type="Integer" primaryKey="true" />
                                        <field name="F1" type="Integer" />
                                    </table>
                                    <table name="TA">
                                        <field name="Id" type="Integer" primaryKey="true" />
                                        <field name="F2" type="Integer" />
                                    </table>
                                </class>
                                <class name="B" inheritFrom="A">
                                    <table name="TA">
                                        <field name="Id" type="Integer" primaryKey="true" />
                                        <field name="F3" type="Integer" />
                                    </table>
                                    <table name="TB">
                                        <field name="Id" type="Integer" primaryKey="true" />
                                        <field name="F4" type="Integer" />
                                    </table>
                                    <table name="TB">
                                        <field name="Id" type="Integer" primaryKey="true" />
                                        <field name="F5" type="Integer" />
                                    </table>
                                </class>
                            </schema>
                        ]]>
                    </code>
                    <p>
                        The <code>LocalTables</code> collection of class <code>A</code> contains two items, because we have defined two
                        <x><table /></x> elements inside the <x><class name="A" /></x> element. The <code>DatabaseTables</code> of
                        this class contains one item, which is a table <code>TA</code> containing the
                        <code>Id</code>, <code>F1</code> and <code>F2</code>, because both <x><table /></x>s that define them are 
                        based on the same database table. The <code>UnifiedTables</code> contents are the same as <code>LocalTables</code>
                        because the class does not inherit from any other class.
                    </p>
                    <p>
                        The <code>LocalTables</code> collection of class <code>B</code> contains three items, because this is the number of
                        <x><table /></x> elements defined within <x><class name="B" /></x>. There are two items in the 
                        <code>DatabaseTables</code> collection, because there are two physical database tables: 
                        <code>TA</code> and <code>TB</code>. The <code>UnifiedTables</code> of class <code>B</code> contains
                        five objects of class <code>TableInfo</code>, one for each defined table in class <code>B</code> and
                        its parent class <code>A</code>.
                    </p>
                </body>
            </section>
            <section id="schemaapirelationinfo">
                <title>RelationInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.RelationInfo</code> class represents the <x><relation /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve relation-level mapping metadata.
                        Objects of this class are stored in <code>SchemaInfo.Relations</code> and <code>SchemaInfo.LocalRelations</code> collections. 
                    </p>
                    <p>
                        <code>RelationInfo</code> has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - relation name</li>
                        <li><code>DataSourceName</code> - data source name for this relation</li>
                        <li><code>Table</code> - the table that holds the fields referencing objects in relation</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapitableinfo">
                <title>TableInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.TableInfo</code> class represents the <x><table /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve table-level mapping metadata.
                        Objects of this class are stored in <code>ClassInfo.LocalTables</code> and <code>ClassInfo.UnifiedTables</code> collections.
                        <code>RelationInfo</code> maintains a reference to the underlying <code>TableInfo</code> as well.
                    </p>
                    <p>
                        <code>TableInfo</code> has the following public properties:
                    </p>
                    <ul>
                        <li><code>DBTableName</code> - name of the database table</li>
                        <li><code>Fields</code> - collection of <a href="#schemaapifieldinfo"><code>FieldInfo</code></a> objects that
                            represent <x><field /></x> elements defined for this table</li>
                        <li><code>OrdinalInClass</code> - the ordinal of this <code>TableInfo</code> object in the <code>UnifiedTables</code> collection of the parent class</li>
                        <li><code>NameToken</code> - is a unique table name (auto-generated)</li>
                        <li><code>OwnerClass</code> - reference to the <a href="#schemaapiclassinfo"><code>ClassInfo</code></a> object that owns this table (<code>null</code> for table in releation)</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapifieldinfo">
                <title>FieldInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.FieldInfo</code> class represents the <x><field /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve field-level mapping metadata.
                    </p>
                    <p>
                        <code>FieldInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - field name</li>
                        <li><code>DBColumnName</code> - name of the database column (defaults to <code>Name</code> it not specified).</li>
                        <li><code>Type</code> - field type</li>
                        <li><code>Size</code> - field size</li>
                        <li><code>Precision</code> - field precision</li>
                        <li><code>References</code> - name of the referenced class</li>
                        <li><code>PrecommitValue</code> - precommit value string</li>
                        <li><code>PrimaryKey</code> - <code>true</code> if the field is (part of) the primary key</li>
                        <li><code>PrecommitTypedValue</code> - typed precommit value (integer, string, datetime)</li>
                        <li><code>Nullable</code> - <code>true</code> if the field is nullable</li>
                        <li><code>ReadOnly</code> - <code>true</code> if the field is read-only</li>
                        <li><code>ForceTrigger</code> - <code>true</code> if the triggers for this field have been generated, regardless of
                            a value of the <code>ClassInfo.Triggers</code> for the parent <x><class /></x>.</li>
                        <li><code>DeleteAction</code> - specifies the action that should be taken when referenced object is deleted. Equivalent of the <code>onDelete</code> attribute.</li>
                        <li><code>PrefetchLevel</code> - The value of <code>prefetch</code> attribute for this field.</li>
                        <li><code>FindMethod</code> - whether to generate <code>FindByNNN()</code> method.</li>
                        <li><code>FindListMethod</code> - whether to generate <code>FindListByNNN()</code> method.</li>
                        <li><code>OrdinalInTable</code> - ordinal of the field in enclosing <x><table /></x></li>
                        <li><code>ClassLocalOrdinal</code> - ordinal of the field in the <code>LocalFields</code> collection of the enclosing class</li>
                        <li><code>ClassUnifiedOrdinal</code> - ordinal of the field in the <code>UnifiedTables</code> collection of the enclosing class</li>
                        <li><code>Table</code> - enclosing <x><table /></x></li>
                        <li><code>ParentClass</code> - enclosing <x><class /></x> - null if field defined in a relation</li>
                        <li><code>ParentRelation</code> - enclosing <x><relation /></x> - null if field defined in a class</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapiincludeinfo">
                <title>IncludeInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.IncludeInfo</code> class represents the <x><include /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about included schemas.
                    </p>
                    <p>
                        <code>IncludeInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>SchemaFile</code> - name of the schema file</li>
                        <li><code>AssemblyName</code> - name of the DAL assembly</li>
                        <li><code>Namespace</code> - namespace of the generated DAL</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapiconstantinfo">
                <title>ConstantInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.ConstantInfo</code> class represents the <x><const /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about defined named constants.
                    </p>
                    <p>
                        <code>ConstantInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - name of the constant</li>
                        <li><code>Key</code> - key value of the object that should be associated with 
                            the constant. Compount primary keys are not supported.</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapidatasourceinfo">
                <title>DataSourceInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.DataSourceInfo</code> class represents the <x><datasource /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about defined data sources.
                    </p>
                    <p>
                        <code>DataSourceInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - name of the data source</li>
                        <li><code>Type</code> - type of the data source - name of the class that inherits from <code>SoodaDataSource</code></li>
                    </ul>
                </body>
            </section>
            <section id="schemaapiprecommitvalueinfo">
                <title>PrecommitValueInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.PrecommitValueInfo</code> class represents the <x><precommitValue /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about 
                        defined precommit values for each data type.
                    </p>
                    <p>
                        <code>PrecommitValueInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>DataName</code> - data type (Integer, String, DateTime and so on)</li>
                        <li><code>ValueText</code> - textual precommit value</li>
                        <li><code>Value</code> - typed precommit value</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapicollectiononetomanyinfo">
                <title>CollectionOneToManyInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.CollectionOneToManyInfo</code> class represents the <x><collectionOneToMany /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about 
                        defined one-to-many collections of a class:
                    </p>
                    <p>
                        <code>CollectionOneToManyInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - collection name</li>
                        <li><code>ClassName</code> - collection element type name</li>
                        <li><code>Class</code> - collection element <a href="#schemaapiclassinfo"><code>ClassInfo</code></a>.</li>
                        <li><code>ForeignFieldName</code> - name of the field in <code>Class</code> that references at the object that defines the collection</li>
                        <li><code>Cache</code> - caching hint</li>
                    </ul>
                </body>
            </section>
            <section id="schemaapicollectionmanytomanyinfo">
                <title>CollectionManyToManyInfo class</title>
                <body>
                    <p>
                        <code>Sooda.Schema.CollectionManyToManyInfo</code> class represents the <x><collectionManyToMany /></x> element of 
                        the <a href="#schema">mapping schema</a>. It can be used to retrieve information about 
                        defined many-to-many collections of a class:
                    </p>
                    <p>
                        <code>CollectionManyToManyInfo</code> class has the following public properties:
                    </p>
                    <ul>
                        <li><code>Name</code> - collection name</li>
                        <li><code>Relation</code> - name of the relation that resolves many-to-many relationship</li>
                        <li><code>ForeignField</code> - name of the field in <code>Relation</code> that references at the object that defines the collection</li>
                    </ul>
                </body>
            </section>
        </section>
        <section id="factorycache">
            <title>Factory Cache</title>
            <body>
                <p>
                    Factory cache is a mechanism that is meant to optimize the <code>GetRef()</code> operation for classes
                    that are part of inheritance relationships. For all other cases <code>GetRef()</code> can be very cheap, 
                    constant-time operation, but if a class has subclasses, Sooda needs to issue a database query to
                    determine the concrete class that should be instantiated. Once the query has been executed and the concrete
                    class is known, we can cache it so that further <code>GetRef()s</code> can be done without any database queries.
                </p>
                <p>
                    By default Sooda comes with eternal factory cache that stores the primary key to concrete class association in 
                    a hashtable that is never emptied. This is sufficient for most databases with less than a few million records. For
                    larger databases you should implement your own factory cache by creating a class that implements the <code>ISoodaObjectFactoryCache</code>
                    interface.
                </p>
                <p>
                    Once you have defined your own factory cache, you should assign it to the static 
                    property <code>SoodaObjectFactoryCache</code> of the <code>SoodaTransaction</code> class:
                </p>
                <code lang="C#">
                    SoodaTransaction.SoodaObjectFactoryCache = new MyFactoryCache();
                </code>
            </body>
        </section>
        <section id="activetransactionmanagement">
            <title>ActiveTransaction management</title>
            <body>
                <p>
                    Implicit transaction (stored in <code>SoodaTransaction.ActiveTransaction</code>) is kept in 
                    thread's local storage (TLS). It means that as long as you access the objects from the thread
                    that created the transaction, you do not need to pass the transaction reference explicitly.
                    There are situations where storing the transaction on per-thread basis is not feasible. For example
                    events in the ASP.NET environment are not guaranteed to be thread-bound so you cannot store
                    implicit <code>SoodaTransaction</code> in TLS.
                </p>
                <p>
                    Fortunately, Sooda supports multiple strategies for managing the implicit transaction reference.
                    There are three predefined strategies:
                </p>
                <ul>
                    <li><code>SoodaThreadBoundTransactionStrategy</code> - default thread-bound implementation</li>
                    <li><code>SoodaHttpContextBoundTransactionStrategy</code> - ASP.NET HttpContext-bound implementation</li>
                    <li><code>SoodaProcessBoundTransactionStrategy</code> - process-bound implementation</li>
                </ul>
                <p>
                    To change the active strategy, create an instance of the appropriate strategy class and assign 
                    it to the <code>SoodaTransaction.DefaultTransactionStrategy</code> static property:
                </p>
                <code lang="C#">
                    SoodaTransaction.DefaultTransactionStrategy = new SoodaHttpContextBoundTransactionStrategy();
                </code>
                <p>
                    To implement your own strategy, create a class that implements the 
                    <code>IDefaultSoodaTransactionStrategy</code> interface. Two methods need to be implemented: one that
                    gets current transaction and the other that sets it and returns a previous value.
                </p>
            </body>
        </section>
        <section id="prefetch">
            <title>Prefetching</title>
            <body>
                <p>
                    Prefetching is a technique that allows object references to be pre-loaded from the database 
                    at the same time the object is loaded. This is possible thanks to the SQL <code>OUTER JOIN</code>
                    operators. Normally Sooda issues a simple SQL statement to load an object from the database::
                </p>
                <code lang="C#">
                    select column1, column2, ..., columnN
                    from   table1
                    where  id=123
                </code>
                <p>
                    Assuming that <code>columnR</code> is a foreign key reference to <code>table2</code>, we can load two
                    objects in a single query by using an outer join:
                </p>
                <code lang="C#">
                    select t1.column1, t1.column2, ..., t1.columnN
                           t2.column1, t2.column2, ..., t2.columnM
                    from   table1 t1
                           left outer join table2 t2 on (t1.columnR = t2.id)
                    where  t1.id=123
                </code>
                <p>
                    Note that columns 1..N belong to objects stored in "<code>table1</code>" and 
                    columns N+1..N+M are from "<code>table2</code>".
                </p>
                <p>
                    Sooda extends this concept with the possibility to include arbitrary number of objects being prefetched
                    on each load. This can be controlled by the <code>prefetch</code> attribute of the <x><field /></x> element in the
                    <a href="#schema">mapping schema</a>. By default it is zero, meaning that no prefetch should be performed,
                    but you can set it to a higher value to indicate level of objects that should be prefetched.
                </p>
                <p>
                    Consider this example of a simple movie management system:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <class name="Movie">
                            <table name="Movie">
                                <field name="ID" type="Integer" primaryKey="true" />
                                <field name="Title" type="String" size="40" />
                                <field name="Genre" type="Integer" references="MovieGenre" prefetch="1" />
                                <field name="Subgenre" type="Integer" references="MovieGenre" prefetch="2" />
                                <field name="AudioLanguage" type="Integer" references="AudioLanguage" />
                                <field name="VideoFormat" type="Integer" references="VideoFormat" prefetch="1" />
                                <field name="ParentalGuidance" type="Integer" references="ParentalRating" />
                            </table>
                        </class>
                        <class name="MovieGenre">
                            <table name="MovieGenre">
                                <field name="ID" type="Integer" primaryKey="true" />
                                <field name="Name" type="String" size="40" />
                                <field name="ParentGenre" type="Integer" references="MovieGenre" prefetch="1" />
                            </table>
                        </class>
                        <class name="VideoFormat">
                            <table name="VideoFormat">
                                <field name="ID" type="Integer" primaryKey="true" />
                                <field name="FrameWidth" type="Integer" />
                                <field name="FrameHeight" type="Integer" />
                                <field name="ColorDepth" type="Integer" />
                                <field name="Compression" type="Integer" />
                            </table>
                        </class>
                        <class name="ParentalRating">
                            <table name="ParentalRating">
                                <field name="ID" type="Integer" primaryKey="true" />
                                <field name="Name" type="String" size="40" />
                                <field name="MinimumAge" type="Integer" />
                            </table>
                        </class>
                        <class name="AudioLanguage">
                            <table name="AudioLanguage">
                                <field name="ID" type="Integer" primaryKey="true" />
                                <field name="Name" type="String" size="40" />
                                <field name="ISOTwoLetterName" type="String" size="40" />
                                <field name="ISOThreeLetterName" type="String" size="40" />
                            </table>
                        </class>
                    </schema>
                    ]]>
                </code>
                <p>
                    When you load a movie object <code>m</code> Sooda automatically prefetches related objects, so that 
                    the following properties can be accessed with no additional SQL queries:
                </p>
                <code lang="C#">
                    <![CDATA[
                    m.ID
                    m.Title
                    m.Genre
                    m.Subgenre
                    m.AudioLanguage
                    m.VideoFormat
                    m.ParentalGuidance

                    // these fields are prefetched because field Genre has prefetch="1"
                    m.Genre.Name

                    // these fields are prefetched because field Subgenre has prefetch="2"
                    m.Subgenre.Name
                    m.Subgenre.ParentGenre.ID
                    m.Subgenre.ParentGenre.Name

                    // these fields are prefetched because field VideoFormat has prefetch="1"
                    m.VideoFormat.FrameWidth
                    m.VideoFormat.FrameHeight
                    m.VideoFormat.ColorDepth
                    m.VideoFormat.Compression
                    ]]>
                </code>
                <p>
                    Note that the following fields are NOT prefetched automatically and will involve 
                    a database access when first accessed:
                </p>
                <code lang="C#">
                    <![CDATA[
                    m.AudioLanguage.Name
                    m.AudioLanguage.ISOTwoLetterName
                    m.AudioLanguage.ISOThreeLetterName
                    m.ParentalGuidance.Name
                    m.ParentalGuidance.MinimumAge
                    ]]>
                </code>
                <p>
                    Because primary keys are always present in memory, accessing following fields will never
                    cause a database roundtrip, even if the <code>prefetch</code> properties were not set:
                </p>
                <code lang="C#">
                    <![CDATA[
                    m.Genre.ID
                    m.Subgenre.ID
                    m.VideoFormat.ID
                    m.AudioLanguage.ID
                    m.ParentalGuidance.ID
                    ]]>
                </code>
                <p>
                    Prefetch can be used to optimize preloading of hierarchies, such as Employee-Manager relationship which is effectively
                    a tree. Let's assume you have a class named <code>Employee</code> which includes a reference to its manager:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Manager" type="Integer" reference="Employee" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    We can print all the managers of some particular employee with a simple <code>for()</code> loop:
                </p>
                <code lang="C#">
                    <![CDATA[
                    for (Employee e = this.Manager; e != null; e = e.Manager)
                    {
                        Console.WriteLine("manager: {0}", e.Name);
                    }
                    ]]>
                </code>
                <p>
                    Without the prefetch, Sooda would have to issue the SQL query to retrieve each Employee object separately.
                    Assuming you have 10 levels of management in your company, that would be 10 SQL queries. To minimize the number of queries, you can add prefetch="3"
                    to the "<code>Manager</code>" field declaration:
                </p>
                <code lang="XML">
                    <![CDATA[
                        <field name="Manager" type="Integer" reference="Employee" prefetch="3" />
                    ]]>
                </code>
                <p>
                    When you load an <code>Employee</code> object <code>e</code>, Sooda preloads the following referenced objects, so you can access 
                    their properties without an SQL query:
                </p>
                <code lang="C#">
                    e.Manager
                    e.Manager.Manager
                    e.Manager.Manager.Manager
                </code>
                <p>
                    Once you access <code>e.Manager.Manager.Manager.Manager</code>, Sooda will preload:
                </p>
                <code lang="C#">
                    e.Manager.Manager.Manager.Manager.Manager
                    e.Manager.Manager.Manager.Manager.Manager.Manager
                    e.Manager.Manager.Manager.Manager.Manager.Manager.Manager
                </code>
                <p>
                    If there are at most three managers in the hierarchy, setting the <code>prefetch</code> to <code>3</code> ensures that
                    the entire structure will be fetched in a single SQL query. 
                    The cost of prefetch is usually very small, but the number of columns returned in a query grows as you 
                    prefetch, so you should limit the depth of the prefetch operation. Prefetch value of one is usually sufficient.
                </p>
            </body>
        </section>
    </section>
</content>
